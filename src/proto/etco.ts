// @generated by protobuf-ts 2.9.0 with parameter ts_nocheck,server_none,long_type_number
// @generated from protobuf file "etco.proto" (package "eve_trading_co_proto", syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message eve_trading_co_proto.OptionalInt32
 */
export interface OptionalInt32 {
    /**
     * @generated from protobuf field: int32 inner = 1;
     */
    inner: number;
}
/**
 * @generated from protobuf message eve_trading_co_proto.AuthRequest
 */
export interface AuthRequest {
    /**
     * @generated from protobuf field: string token = 1;
     */
    token: string; // native token
}
/**
 * @generated from protobuf message eve_trading_co_proto.AuthResponse
 */
export interface AuthResponse {
    /**
     * @generated from protobuf field: string token = 1;
     */
    token: string; // native token
    /**
     * @generated from protobuf field: bool authorized = 2;
     */
    authorized: boolean; // whether the request was authorized
}
/**
 * @generated from protobuf message eve_trading_co_proto.ErrorResponse
 */
export interface ErrorResponse {
    /**
     * @generated from protobuf field: string error = 1;
     */
    error: string; // error message
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorCode code = 2;
     */
    code: ErrorCode; // error code
}
/**
 * @generated from protobuf message eve_trading_co_proto.CfgTypePricing
 */
export interface CfgTypePricing {
    /**
     * @generated from protobuf field: bool is_buy = 1;
     */
    isBuy: boolean;
    /**
     * @generated from protobuf field: uint32 percentile = 2;
     */
    percentile: number;
    /**
     * @generated from protobuf field: uint32 modifier = 3;
     */
    modifier: number;
    /**
     * @generated from protobuf field: string market = 4;
     */
    market: string; // MarketKey
}
/**
 * @generated from protobuf message eve_trading_co_proto.CfgBuybackTypePricing
 */
export interface CfgBuybackTypePricing {
    /**
     * at least one of these must be set
     *
     * @generated from protobuf field: eve_trading_co_proto.CfgTypePricing pricing = 1;
     */
    pricing?: CfgTypePricing;
    /**
     * @generated from protobuf field: uint32 reprocessing_efficiency = 2;
     */
    reprocessingEfficiency: number; // 0 - 100
}
/**
 * wrapper for TypePricing
 *
 * @generated from protobuf message eve_trading_co_proto.CfgShopTypePricing
 */
export interface CfgShopTypePricing {
    /**
     * @generated from protobuf field: eve_trading_co_proto.CfgTypePricing inner = 1;
     */
    inner?: CfgTypePricing;
}
/**
 * wrapper for map<BuybackTypeMapKey, BuybackTypeValue>
 *
 * @generated from protobuf message eve_trading_co_proto.CfgBuybackSystemTypeBundle
 */
export interface CfgBuybackSystemTypeBundle {
    /**
     * @generated from protobuf field: map<string, eve_trading_co_proto.CfgBuybackTypePricing> inner = 1;
     */
    inner: {
        [key: string]: CfgBuybackTypePricing;
    };
}
/**
 * wrapper for map<ShopTypeMapKey, ShopTypeValue>
 *
 * @generated from protobuf message eve_trading_co_proto.CfgShopLocationTypeBundle
 */
export interface CfgShopLocationTypeBundle {
    /**
     * @generated from protobuf field: map<string, eve_trading_co_proto.CfgShopTypePricing> inner = 1;
     */
    inner: {
        [key: string]: CfgShopTypePricing;
    };
}
/**
 * @generated from protobuf message eve_trading_co_proto.CfgBuybackSystem
 */
export interface CfgBuybackSystem {
    /**
     * @generated from protobuf field: string bundle_key = 1;
     */
    bundleKey: string; // BuybackSystemBundleKey
    /**
     * @generated from protobuf field: double m3_fee = 2;
     */
    m3Fee: number; // fee per m3
}
/**
 * @generated from protobuf message eve_trading_co_proto.CfgShopLocation
 */
export interface CfgShopLocation {
    /**
     * @generated from protobuf field: string bundle_key = 1;
     */
    bundleKey: string; // ShopLocationBundleKey
    /**
     * @generated from protobuf field: repeated string banned_flags = 2;
     */
    bannedFlags: string[]; // banned asset flags
}
/**
 * @generated from protobuf message eve_trading_co_proto.CfgMarket
 */
export interface CfgMarket {
    /**
     * @generated from protobuf field: string refresh_token = 1;
     */
    refreshToken: string; // web token
    /**
     * @generated from protobuf field: int64 location_id = 2;
     */
    locationId: number;
    /**
     * @generated from protobuf field: bool is_structure = 3;
     */
    isStructure: boolean;
}
/**
 * list of valid IDs for authentication
 *
 * @generated from protobuf message eve_trading_co_proto.AuthList
 */
export interface AuthList {
    /**
     * authentication is checked in this exact order, stopping on first match
     *
     * @generated from protobuf field: repeated int32 banned_character_ids = 1;
     */
    bannedCharacterIds: number[]; // denied
    /**
     * @generated from protobuf field: repeated int32 permit_character_ids = 2;
     */
    permitCharacterIds: number[]; // allowed
    /**
     * @generated from protobuf field: repeated int32 banned_corporation_ids = 3;
     */
    bannedCorporationIds: number[]; // denied
    /**
     * @generated from protobuf field: repeated int32 permit_corporation_ids = 4;
     */
    permitCorporationIds: number[]; // allowed
    /**
     * @generated from protobuf field: repeated int32 permit_alliance_ids = 5;
     */
    permitAllianceIds: number[]; // allowed
}
/**
 * @generated from protobuf message eve_trading_co_proto.IncludeTypeNaming
 */
export interface IncludeTypeNaming {
    /**
     * @generated from protobuf field: bool include_name = 1;
     */
    includeName: boolean;
    /**
     * @generated from protobuf field: bool include_market_groups = 2;
     */
    includeMarketGroups: boolean;
    /**
     * @generated from protobuf field: bool include_group = 3;
     */
    includeGroup: boolean;
    /**
     * @generated from protobuf field: bool include_category = 4;
     */
    includeCategory: boolean;
}
/**
 * @generated from protobuf message eve_trading_co_proto.TypeNamingIndexes
 */
export interface TypeNamingIndexes {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string; // "" if nil
    /**
     * @generated from protobuf field: sint32 group_index = 2;
     */
    groupIndex: number; // -1 if nil
    /**
     * @generated from protobuf field: sint32 category_index = 3;
     */
    categoryIndex: number; // -1 if nil
    /**
     * @generated from protobuf field: repeated int32 market_group_indexes = 4;
     */
    marketGroupIndexes: number[]; // length 0 if nil
}
/**
 * @generated from protobuf message eve_trading_co_proto.TypeNamingLists
 */
export interface TypeNamingLists {
    /**
     * @generated from protobuf field: repeated string groups = 1;
     */
    groups: string[];
    /**
     * @generated from protobuf field: repeated string categories = 2;
     */
    categories: string[];
    /**
     * @generated from protobuf field: repeated string market_groups = 3;
     */
    marketGroups: string[];
}
/**
 * @generated from protobuf message eve_trading_co_proto.LocationInfo
 */
export interface LocationInfo {
    /**
     * @generated from protobuf field: bool is_structure = 1;
     */
    isStructure: boolean;
    /**
     * @generated from protobuf field: bool forbidden_structure = 2;
     */
    forbiddenStructure: boolean;
    /**
     * @generated from protobuf field: int32 system_id = 3;
     */
    systemId: number; // SystemId
    /**
     * @generated from protobuf field: int32 region_id = 4;
     */
    regionId: number; // RegionId
}
/**
 * @generated from protobuf message eve_trading_co_proto.IncludeLocationNaming
 */
export interface IncludeLocationNaming {
    /**
     * @generated from protobuf field: bool include_location_name = 1;
     */
    includeLocationName: boolean;
    /**
     * @generated from protobuf field: bool include_system_name = 2;
     */
    includeSystemName: boolean;
    /**
     * @generated from protobuf field: bool include_region_name = 3;
     */
    includeRegionName: boolean;
}
/**
 * @generated from protobuf message eve_trading_co_proto.LocationNamingMaps
 */
export interface LocationNamingMaps {
    /**
     * @generated from protobuf field: map<int64, string> location_names = 1;
     */
    locationNames: {
        [key: string]: string;
    }; // LocationId
    /**
     * @generated from protobuf field: map<int32, string> system_names = 2;
     */
    systemNames: {
        [key: number]: string;
    }; // SystemId
    /**
     * @generated from protobuf field: map<int32, string> region_names = 3;
     */
    regionNames: {
        [key: number]: string;
    }; // RegionId
}
/**
 * @generated from protobuf message eve_trading_co_proto.NamedType
 */
export interface NamedType {
    /**
     * @generated from protobuf field: int32 type_id = 1;
     */
    typeId: number;
    /**
     * @generated from protobuf field: eve_trading_co_proto.TypeNamingIndexes type_naming_indexes = 2;
     */
    typeNamingIndexes?: TypeNamingIndexes;
}
/**
 * @generated from protobuf message eve_trading_co_proto.BasicItem
 */
export interface BasicItem {
    /**
     * @generated from protobuf field: int32 type_id = 1;
     */
    typeId: number;
    /**
     * @generated from protobuf field: int64 quantity = 2;
     */
    quantity: number;
}
/**
 * @generated from protobuf message eve_trading_co_proto.NamedBasicItem
 */
export interface NamedBasicItem {
    /**
     * @generated from protobuf field: int32 type_id = 1;
     */
    typeId: number;
    /**
     * @generated from protobuf field: int64 quantity = 2;
     */
    quantity: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
}
/**
 * @generated from protobuf message eve_trading_co_proto.BuybackAppraisal
 */
export interface BuybackAppraisal {
    /**
     * @generated from protobuf field: repeated eve_trading_co_proto.BuybackParentItem items = 1;
     */
    items: BuybackParentItem[];
    /**
     * @generated from protobuf field: string code = 2;
     */
    code: string; // AppraisalCode
    /**
     * @generated from protobuf field: double price = 3;
     */
    price: number; // sum of []parent.price_total
    /**
     * @generated from protobuf field: int64 time = 4;
     */
    time: number; // time of the appraisal
    /**
     * @generated from protobuf field: string version = 5;
     */
    version: string; // version of the pricing scheme
    /**
     * @generated from protobuf field: int32 system_id = 6;
     */
    systemId: number; // system used for the appraisal
}
/**
 * @generated from protobuf message eve_trading_co_proto.BuybackParentItem
 */
export interface BuybackParentItem {
    /**
     * @generated from protobuf field: int32 type_id = 1;
     */
    typeId: number;
    /**
     * @generated from protobuf field: int64 quantity = 2;
     */
    quantity: number;
    /**
     * @generated from protobuf field: double price_per_unit = 3;
     */
    pricePerUnit: number;
    /**
     * @generated from protobuf field: string description = 4;
     */
    description: string; // source of the price
    /**
     * @generated from protobuf field: repeated eve_trading_co_proto.BuybackChildItem children = 5;
     */
    children: BuybackChildItem[];
    /**
     * @generated from protobuf field: eve_trading_co_proto.TypeNamingIndexes type_naming_indexes = 6;
     */
    typeNamingIndexes?: TypeNamingIndexes;
}
/**
 * @generated from protobuf message eve_trading_co_proto.BuybackChildItem
 */
export interface BuybackChildItem {
    /**
     * @generated from protobuf field: int32 type_id = 1;
     */
    typeId: number;
    /**
     * @generated from protobuf field: double quantity_per_parent = 2;
     */
    quantityPerParent: number;
    /**
     * @generated from protobuf field: double price_per_unit = 3;
     */
    pricePerUnit: number;
    /**
     * @generated from protobuf field: string description = 4;
     */
    description: string; // source of the price
    /**
     * @generated from protobuf field: eve_trading_co_proto.TypeNamingIndexes type_naming_indexes = 5;
     */
    typeNamingIndexes?: TypeNamingIndexes;
}
/**
 * @generated from protobuf message eve_trading_co_proto.ShopAppraisal
 */
export interface ShopAppraisal {
    /**
     * @generated from protobuf field: repeated eve_trading_co_proto.ShopItem items = 1;
     */
    items: ShopItem[];
    /**
     * @generated from protobuf field: string code = 2;
     */
    code: string; // AppraisalCode
    /**
     * @generated from protobuf field: double price = 3;
     */
    price: number; // sum of []item.price_total
    /**
     * @generated from protobuf field: int64 time = 4;
     */
    time: number; // time of the appraisal
    /**
     * @generated from protobuf field: string version = 5;
     */
    version: string; // version of the pricing scheme
    /**
     * @generated from protobuf field: int64 location_id = 6;
     */
    locationId: number; // location used for the appraisal
}
/**
 * @generated from protobuf message eve_trading_co_proto.ShopItem
 */
export interface ShopItem {
    /**
     * @generated from protobuf field: int32 type_id = 1;
     */
    typeId: number;
    /**
     * @generated from protobuf field: int64 quantity = 2;
     */
    quantity: number;
    /**
     * @generated from protobuf field: double price_per_unit = 3;
     */
    pricePerUnit: number;
    /**
     * @generated from protobuf field: string description = 4;
     */
    description: string; // source of the price
    /**
     * @generated from protobuf field: eve_trading_co_proto.TypeNamingIndexes type_naming_indexes = 5;
     */
    typeNamingIndexes?: TypeNamingIndexes;
}
/**
 * @generated from protobuf message eve_trading_co_proto.ContractItem
 */
export interface ContractItem {
    /**
     * @generated from protobuf field: int32 type_id = 1;
     */
    typeId: number;
    /**
     * @generated from protobuf field: int64 quantity = 2;
     */
    quantity: number;
    /**
     * @generated from protobuf field: eve_trading_co_proto.TypeNamingIndexes type_naming_indexes = 3;
     */
    typeNamingIndexes?: TypeNamingIndexes;
}
/**
 * @generated from protobuf message eve_trading_co_proto.Contract
 */
export interface Contract {
    /**
     * @generated from protobuf field: int32 contract_id = 1;
     */
    contractId: number;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ContractStatus status = 2;
     */
    status: ContractStatus;
    /**
     * @generated from protobuf field: int64 issued = 3;
     */
    issued: number;
    /**
     * @generated from protobuf field: int64 expires = 4;
     */
    expires: number;
    /**
     * @generated from protobuf field: int64 location_id = 5;
     */
    locationId: number;
    /**
     * @generated from protobuf field: double price = 6;
     */
    price: number;
    /**
     * @generated from protobuf field: bool has_reward = 7;
     */
    hasReward: boolean;
    /**
     * @generated from protobuf field: int32 issuer_corp_id = 8;
     */
    issuerCorpId: number;
    /**
     * @generated from protobuf field: int32 issuer_char_id = 9;
     */
    issuerCharId: number;
    /**
     * @generated from protobuf field: int32 assignee_id = 10;
     */
    assigneeId: number;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ContractAssigneeType assignee_type = 11;
     */
    assigneeType: ContractAssigneeType;
}
/**
 * @generated from protobuf message eve_trading_co_proto.BuybackContractQueueEntry
 */
export interface BuybackContractQueueEntry {
    /**
     * @generated from protobuf field: string code = 1;
     */
    code: string; // AppraisalCode
    /**
     * @generated from protobuf field: eve_trading_co_proto.Contract contract = 2;
     */
    contract?: Contract;
    /**
     * @generated from protobuf field: repeated eve_trading_co_proto.ContractItem contract_items = 3;
     */
    contractItems: ContractItem[]; // null unless include_items
    /**
     * @generated from protobuf field: eve_trading_co_proto.LocationInfo contract_location_info = 4;
     */
    contractLocationInfo?: LocationInfo; // null unless include_location_info
    /**
     * @generated from protobuf field: eve_trading_co_proto.BuybackAppraisal code_appraisal = 5;
     */
    codeAppraisal?: BuybackAppraisal; // null unless include_code_appraisal
    /**
     * @generated from protobuf field: int32 appraisal_character_id = 6;
     */
    appraisalCharacterId: number; // 0 unless include_code_appraisal + non-anonymous appraisal
    /**
     * @generated from protobuf field: eve_trading_co_proto.BuybackAppraisal new_appraisal = 7;
     */
    newAppraisal?: BuybackAppraisal; // null unless include_new_appraisal + include_code_appraisal + include_items
}
/**
 * @generated from protobuf message eve_trading_co_proto.ShopContractQueueEntry
 */
export interface ShopContractQueueEntry {
    /**
     * @generated from protobuf field: string code = 1;
     */
    code: string; // AppraisalCode
    /**
     * @generated from protobuf field: eve_trading_co_proto.Contract contract = 2;
     */
    contract?: Contract;
    /**
     * @generated from protobuf field: repeated eve_trading_co_proto.ContractItem contract_items = 3;
     */
    contractItems: ContractItem[]; // null unless include_items
    /**
     * @generated from protobuf field: eve_trading_co_proto.LocationInfo contract_location_info = 4;
     */
    contractLocationInfo?: LocationInfo; // null unless include_location_info
    /**
     * @generated from protobuf field: eve_trading_co_proto.ShopAppraisal code_appraisal = 5;
     */
    codeAppraisal?: ShopAppraisal; // null unless include_code_appraisal
    /**
     * @generated from protobuf field: int32 appraisal_character_id = 6;
     */
    appraisalCharacterId: number; // 0 unless include_code_appraisal + non-anonymous appraisal
    /**
     * @generated from protobuf field: eve_trading_co_proto.ShopAppraisal new_appraisal = 7;
     */
    newAppraisal?: ShopAppraisal; // null unless include_new_appraisal + include_code_appraisal + include_items
}
/**
 * @generated from protobuf message eve_trading_co_proto.PurchaseQueueEntry
 */
export interface PurchaseQueueEntry {
    /**
     * @generated from protobuf field: string code = 1;
     */
    code: string; // AppraisalCode
    /**
     * @generated from protobuf field: eve_trading_co_proto.ShopAppraisal code_appraisal = 2;
     */
    codeAppraisal?: ShopAppraisal; // null unless include_code_appraisal
    /**
     * @generated from protobuf field: int32 appraisal_character_id = 3;
     */
    appraisalCharacterId: number; // 0 unless include_code_appraisal
    /**
     * @generated from protobuf field: eve_trading_co_proto.ShopAppraisal new_appraisal = 4;
     */
    newAppraisal?: ShopAppraisal; // null unless include_new_appraisal + include_code_appraisal
}
/**
 * @generated from protobuf message eve_trading_co_proto.BuybackAppraisalStatus
 */
export interface BuybackAppraisalStatus {
    /**
     * @generated from protobuf field: string code = 1;
     */
    code: string;
    /**
     * @generated from protobuf field: eve_trading_co_proto.Contract contract = 2;
     */
    contract?: Contract;
}
/**
 * @generated from protobuf message eve_trading_co_proto.ShopAppraisalStatus
 */
export interface ShopAppraisalStatus {
    /**
     * @generated from protobuf field: string code = 1;
     */
    code: string;
    /**
     * @generated from protobuf field: eve_trading_co_proto.Contract contract = 2;
     */
    contract?: Contract;
    /**
     * @generated from protobuf field: bool in_purchase_queue = 3;
     */
    inPurchaseQueue: boolean;
}
/**
 * @generated from protobuf message eve_trading_co_proto.CfgGetAuthListRequest
 */
export interface CfgGetAuthListRequest {
    /**
     * @generated from protobuf field: string domain_key = 1;
     */
    domainKey: string; // DomainKey
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthRequest auth = 2;
     */
    auth?: AuthRequest;
}
/**
 * @generated from protobuf message eve_trading_co_proto.CfgGetAuthListResponse
 */
export interface CfgGetAuthListResponse {
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthList auth_list = 1;
     */
    authList?: AuthList;
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthResponse auth = 2;
     */
    auth?: AuthResponse;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message eve_trading_co_proto.CfgSetAuthListRequest
 */
export interface CfgSetAuthListRequest {
    /**
     * @generated from protobuf field: string domain_key = 1;
     */
    domainKey: string; // DomainKey
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthList auth_list = 2;
     */
    authList?: AuthList;
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthRequest auth = 3;
     */
    auth?: AuthRequest;
}
/**
 * wrapper for CfgModifyResponse
 *
 * @generated from protobuf message eve_trading_co_proto.CfgSetAuthListResponse
 */
export interface CfgSetAuthListResponse {
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthResponse auth = 1;
     */
    auth?: AuthResponse;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 2;
     */
    error?: ErrorResponse;
}
/**
 * wrapper for AuthRequest
 *
 * @generated from protobuf message eve_trading_co_proto.CfgGetBuybackSystemTypeMapsBuilderRequest
 */
export interface CfgGetBuybackSystemTypeMapsBuilderRequest {
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthRequest auth = 1;
     */
    auth?: AuthRequest;
}
/**
 * @generated from protobuf message eve_trading_co_proto.CfgGetBuybackSystemTypeMapsBuilderResponse
 */
export interface CfgGetBuybackSystemTypeMapsBuilderResponse {
    /**
     * @generated from protobuf field: map<int32, eve_trading_co_proto.CfgBuybackSystemTypeBundle> builder = 1;
     */
    builder: {
        [key: number]: CfgBuybackSystemTypeBundle;
    };
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthResponse auth = 2;
     */
    auth?: AuthResponse;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message eve_trading_co_proto.CfgMergeBuybackSystemTypeMapsBuilderRequest
 */
export interface CfgMergeBuybackSystemTypeMapsBuilderRequest {
    /**
     * the program itself converts this to multiple map<TypeId, BuybackTypeMap>
     *
     * @generated from protobuf field: map<int32, eve_trading_co_proto.CfgBuybackSystemTypeBundle> builder = 1;
     */
    builder: {
        [key: number]: CfgBuybackSystemTypeBundle;
    };
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthRequest auth = 2;
     */
    auth?: AuthRequest;
}
/**
 * wrapper for CfgModifyResponse
 *
 * @generated from protobuf message eve_trading_co_proto.CfgMergeBuybackSystemTypeMapsBuilderResponse
 */
export interface CfgMergeBuybackSystemTypeMapsBuilderResponse {
    /**
     * @generated from protobuf field: bool Modified = 1 [json_name = "Modified"];
     */
    modified: boolean;
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthResponse auth = 2;
     */
    auth?: AuthResponse;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * wrapper for AuthRequest
 *
 * @generated from protobuf message eve_trading_co_proto.CfgGetShopLocationTypeMapsBuilderRequest
 */
export interface CfgGetShopLocationTypeMapsBuilderRequest {
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthRequest auth = 1;
     */
    auth?: AuthRequest;
}
/**
 * @generated from protobuf message eve_trading_co_proto.CfgGetShopLocationTypeMapsBuilderResponse
 */
export interface CfgGetShopLocationTypeMapsBuilderResponse {
    /**
     * @generated from protobuf field: map<int32, eve_trading_co_proto.CfgShopLocationTypeBundle> builder = 1;
     */
    builder: {
        [key: number]: CfgShopLocationTypeBundle;
    };
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthResponse auth = 2;
     */
    auth?: AuthResponse;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message eve_trading_co_proto.CfgMergeShopLocationTypeMapsBuilderRequest
 */
export interface CfgMergeShopLocationTypeMapsBuilderRequest {
    /**
     * the program itself converts this to multiple map<TypeId, ShopTypeMap>
     *
     * @generated from protobuf field: map<int32, eve_trading_co_proto.CfgShopLocationTypeBundle> builder = 1;
     */
    builder: {
        [key: number]: CfgShopLocationTypeBundle;
    };
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthRequest auth = 2;
     */
    auth?: AuthRequest;
}
/**
 * wrapper for CfgModifyResponse
 *
 * @generated from protobuf message eve_trading_co_proto.CfgMergeShopLocationTypeMapsBuilderResponse
 */
export interface CfgMergeShopLocationTypeMapsBuilderResponse {
    /**
     * @generated from protobuf field: bool Modified = 1 [json_name = "Modified"];
     */
    modified: boolean;
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthResponse auth = 2;
     */
    auth?: AuthResponse;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * wrapper for AuthRequest
 *
 * @generated from protobuf message eve_trading_co_proto.CfgGetBuybackSystemsRequest
 */
export interface CfgGetBuybackSystemsRequest {
    /**
     * @generated from protobuf field: bool include_location_info = 1;
     */
    includeLocationInfo: boolean;
    /**
     * @generated from protobuf field: eve_trading_co_proto.IncludeLocationNaming include_location_naming = 2;
     */
    includeLocationNaming?: IncludeLocationNaming; // ignored if 1 is false
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthRequest auth = 3;
     */
    auth?: AuthRequest;
}
/**
 * @generated from protobuf message eve_trading_co_proto.CfgGetBuybackSystemsResponse
 */
export interface CfgGetBuybackSystemsResponse {
    /**
     * @generated from protobuf field: map<int32, eve_trading_co_proto.CfgBuybackSystem> systems = 1;
     */
    systems: {
        [key: number]: CfgBuybackSystem;
    };
    /**
     * @generated from protobuf field: map<int32, int32> system_region_map = 2;
     */
    systemRegionMap: {
        [key: number]: number;
    }; // SystemId -> RegionId
    /**
     * @generated from protobuf field: eve_trading_co_proto.LocationNamingMaps location_naming_maps = 3;
     */
    locationNamingMaps?: LocationNamingMaps;
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthResponse auth = 4;
     */
    auth?: AuthResponse;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 5;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message eve_trading_co_proto.CfgMergeBuybackSystemsRequest
 */
export interface CfgMergeBuybackSystemsRequest {
    /**
     * @generated from protobuf field: map<int32, eve_trading_co_proto.CfgBuybackSystem> systems = 1;
     */
    systems: {
        [key: number]: CfgBuybackSystem;
    };
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthRequest auth = 2;
     */
    auth?: AuthRequest;
}
/**
 * wrapper for CfgModifyResponse
 *
 * @generated from protobuf message eve_trading_co_proto.CfgMergeBuybackSystemsResponse
 */
export interface CfgMergeBuybackSystemsResponse {
    /**
     * @generated from protobuf field: bool Modified = 1 [json_name = "Modified"];
     */
    modified: boolean;
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthResponse auth = 2;
     */
    auth?: AuthResponse;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * wrapper for AuthRequest
 *
 * @generated from protobuf message eve_trading_co_proto.CfgGetShopLocationsRequest
 */
export interface CfgGetShopLocationsRequest {
    /**
     * @generated from protobuf field: bool include_location_info = 1;
     */
    includeLocationInfo: boolean;
    /**
     * @generated from protobuf field: eve_trading_co_proto.IncludeLocationNaming include_location_naming = 2;
     */
    includeLocationNaming?: IncludeLocationNaming; // ignored if 1 is false
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthRequest auth = 3;
     */
    auth?: AuthRequest;
}
/**
 * @generated from protobuf message eve_trading_co_proto.CfgGetShopLocationsResponse
 */
export interface CfgGetShopLocationsResponse {
    /**
     * @generated from protobuf field: map<int64, eve_trading_co_proto.CfgShopLocation> locations = 1;
     */
    locations: {
        [key: string]: CfgShopLocation;
    };
    /**
     * @generated from protobuf field: map<int64, eve_trading_co_proto.LocationInfo> location_info_map = 2;
     */
    locationInfoMap: {
        [key: string]: LocationInfo;
    }; // LocationId -> LocationInfo
    /**
     * @generated from protobuf field: eve_trading_co_proto.LocationNamingMaps location_naming_maps = 3;
     */
    locationNamingMaps?: LocationNamingMaps;
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthResponse auth = 4;
     */
    auth?: AuthResponse;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 5;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message eve_trading_co_proto.CfgMergeShopLocationsRequest
 */
export interface CfgMergeShopLocationsRequest {
    /**
     * @generated from protobuf field: map<int64, eve_trading_co_proto.CfgShopLocation> locations = 1;
     */
    locations: {
        [key: string]: CfgShopLocation;
    };
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthRequest auth = 2;
     */
    auth?: AuthRequest;
}
/**
 * wrapper for CfgModifyResponse
 *
 * @generated from protobuf message eve_trading_co_proto.CfgMergeShopLocationsResponse
 */
export interface CfgMergeShopLocationsResponse {
    /**
     * @generated from protobuf field: bool Modified = 1 [json_name = "Modified"];
     */
    modified: boolean;
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthResponse auth = 2;
     */
    auth?: AuthResponse;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * wrapper for AuthRequest
 *
 * @generated from protobuf message eve_trading_co_proto.CfgGetMarketsRequest
 */
export interface CfgGetMarketsRequest {
    /**
     * @generated from protobuf field: bool include_location_info = 1;
     */
    includeLocationInfo: boolean;
    /**
     * @generated from protobuf field: eve_trading_co_proto.IncludeLocationNaming include_location_naming = 2;
     */
    includeLocationNaming?: IncludeLocationNaming; // ignored if 1 is false
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthRequest auth = 3;
     */
    auth?: AuthRequest;
}
/**
 * @generated from protobuf message eve_trading_co_proto.CfgGetMarketsResponse
 */
export interface CfgGetMarketsResponse {
    /**
     * @generated from protobuf field: map<string, eve_trading_co_proto.CfgMarket> markets = 1;
     */
    markets: {
        [key: string]: CfgMarket;
    };
    /**
     * @generated from protobuf field: map<int64, eve_trading_co_proto.LocationInfo> location_info_map = 2;
     */
    locationInfoMap: {
        [key: string]: LocationInfo;
    }; // LocationId -> LocationInfo
    /**
     * @generated from protobuf field: eve_trading_co_proto.LocationNamingMaps location_naming_maps = 3;
     */
    locationNamingMaps?: LocationNamingMaps;
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthResponse auth = 4;
     */
    auth?: AuthResponse;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 5;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message eve_trading_co_proto.CfgMergeMarketsRequest
 */
export interface CfgMergeMarketsRequest {
    /**
     * @generated from protobuf field: map<string, eve_trading_co_proto.CfgMarket> markets = 1;
     */
    markets: {
        [key: string]: CfgMarket;
    };
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthRequest auth = 2;
     */
    auth?: AuthRequest;
}
/**
 * wrapper for CfgModifyResponse
 *
 * @generated from protobuf message eve_trading_co_proto.CfgMergeMarketsResponse
 */
export interface CfgMergeMarketsResponse {
    /**
     * @generated from protobuf field: bool Modified = 1 [json_name = "Modified"];
     */
    modified: boolean;
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthResponse auth = 2;
     */
    auth?: AuthResponse;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * anonymous or authenticated
 * returns a code if save is true
 *
 * @generated from protobuf message eve_trading_co_proto.NewBuybackAppraisalRequest
 */
export interface NewBuybackAppraisalRequest {
    /**
     * @generated from protobuf field: int32 system_id = 1;
     */
    systemId: number; // SystemId
    /**
     * @generated from protobuf field: repeated eve_trading_co_proto.BasicItem items = 2;
     */
    items: BasicItem[];
    /**
     * @generated from protobuf field: bool save = 3;
     */
    save: boolean; // whether to store the appraisal and return a code
    /**
     * @generated from protobuf field: eve_trading_co_proto.IncludeTypeNaming include_type_naming = 4;
     */
    includeTypeNaming?: IncludeTypeNaming;
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthRequest auth = 5;
     */
    auth?: AuthRequest; // optional
}
/**
 * @generated from protobuf message eve_trading_co_proto.NewBuybackAppraisalResponse
 */
export interface NewBuybackAppraisalResponse {
    /**
     * @generated from protobuf field: eve_trading_co_proto.BuybackAppraisal appraisal = 1;
     */
    appraisal?: BuybackAppraisal;
    /**
     * @generated from protobuf field: eve_trading_co_proto.TypeNamingLists type_naming_lists = 2;
     */
    typeNamingLists?: TypeNamingLists;
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthResponse auth = 3;
     */
    auth?: AuthResponse;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 4;
     */
    error?: ErrorResponse;
}
/**
 * authenticated
 * returns a code if save is true (but doesn't add it to the purchase queue)
 *
 * @generated from protobuf message eve_trading_co_proto.NewShopAppraisalRequest
 */
export interface NewShopAppraisalRequest {
    /**
     * @generated from protobuf field: int64 location_id = 1;
     */
    locationId: number; // LocationId
    /**
     * @generated from protobuf field: repeated eve_trading_co_proto.BasicItem items = 2;
     */
    items: BasicItem[];
    /**
     * bool save = 3; // whether to store the appraisal and return a code
     *
     * @generated from protobuf field: eve_trading_co_proto.IncludeTypeNaming include_type_naming = 3;
     */
    includeTypeNaming?: IncludeTypeNaming; // AuthRequest auth = 4;
}
/**
 * @generated from protobuf message eve_trading_co_proto.NewShopAppraisalResponse
 */
export interface NewShopAppraisalResponse {
    /**
     * @generated from protobuf field: eve_trading_co_proto.ShopAppraisal appraisal = 1;
     */
    appraisal?: ShopAppraisal;
    /**
     * @generated from protobuf field: eve_trading_co_proto.TypeNamingLists type_naming_lists = 2;
     */
    typeNamingLists?: TypeNamingLists;
    /**
     * AuthResponse auth = 3;
     *
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message eve_trading_co_proto.GetBuybackAppraisalRequest
 */
export interface GetBuybackAppraisalRequest {
    /**
     * @generated from protobuf field: string code = 1;
     */
    code: string; // AppraisalCode
    /**
     * @generated from protobuf field: eve_trading_co_proto.IncludeTypeNaming include_type_naming = 2;
     */
    includeTypeNaming?: IncludeTypeNaming;
    /**
     * @generated from protobuf field: bool admin = 3;
     */
    admin: boolean; // whether to use admin auth
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthRequest auth = 4;
     */
    auth?: AuthRequest; // optional, admin only (ignored if admin is false)
}
/**
 * @generated from protobuf message eve_trading_co_proto.GetBuybackAppraisalResponse
 */
export interface GetBuybackAppraisalResponse {
    /**
     * @generated from protobuf field: eve_trading_co_proto.BuybackAppraisal appraisal = 1;
     */
    appraisal?: BuybackAppraisal;
    /**
     * @generated from protobuf field: string hash_character_id = 2;
     */
    hashCharacterId: string; // obfuscated character id ("" if admin is true)
    /**
     * @generated from protobuf field: int32 character_id = 3;
     */
    characterId: number; // admin only, 0 otherwise
    /**
     * @generated from protobuf field: eve_trading_co_proto.TypeNamingLists type_naming_lists = 4;
     */
    typeNamingLists?: TypeNamingLists;
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthResponse auth = 5;
     */
    auth?: AuthResponse; // admin only
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 6;
     */
    error?: ErrorResponse; // code not exists
}
/**
 * @generated from protobuf message eve_trading_co_proto.GetShopAppraisalRequest
 */
export interface GetShopAppraisalRequest {
    /**
     * @generated from protobuf field: string code = 1;
     */
    code: string; // AppraisalCode
    /**
     * @generated from protobuf field: eve_trading_co_proto.IncludeTypeNaming include_type_naming = 2;
     */
    includeTypeNaming?: IncludeTypeNaming;
    /**
     * @generated from protobuf field: bool admin = 3;
     */
    admin: boolean; // whether to use admin auth
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthRequest auth = 4;
     */
    auth?: AuthRequest; // optional, admin only (ignored if admin is false)
}
/**
 * @generated from protobuf message eve_trading_co_proto.GetShopAppraisalResponse
 */
export interface GetShopAppraisalResponse {
    /**
     * @generated from protobuf field: eve_trading_co_proto.ShopAppraisal appraisal = 1;
     */
    appraisal?: ShopAppraisal;
    /**
     * @generated from protobuf field: string hash_character_id = 2;
     */
    hashCharacterId: string; // obfuscated character id ("" if admin is true)
    /**
     * @generated from protobuf field: int32 character_id = 3;
     */
    characterId: number; // 0 if admin is false
    /**
     * @generated from protobuf field: eve_trading_co_proto.TypeNamingLists type_naming_lists = 4;
     */
    typeNamingLists?: TypeNamingLists;
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthResponse auth = 5;
     */
    auth?: AuthResponse; // null if admin is false
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 6;
     */
    error?: ErrorResponse; // code not exists
}
/**
 * @generated from protobuf message eve_trading_co_proto.StatusBuybackAppraisalRequest
 */
export interface StatusBuybackAppraisalRequest {
    /**
     * @generated from protobuf field: string code = 1;
     */
    code: string; // AppraisalCode
    /**
     * @generated from protobuf field: bool include_items = 2;
     */
    includeItems: boolean;
    /**
     * @generated from protobuf field: bool include_location_info = 3;
     */
    includeLocationInfo: boolean;
    /**
     * @generated from protobuf field: eve_trading_co_proto.IncludeTypeNaming include_type_naming = 4;
     */
    includeTypeNaming?: IncludeTypeNaming;
    /**
     * @generated from protobuf field: eve_trading_co_proto.IncludeLocationNaming include_location_naming = 5;
     */
    includeLocationNaming?: IncludeLocationNaming; // ignored if 3 is false
    /**
     * @generated from protobuf field: bool admin = 6;
     */
    admin: boolean; // whether to use admin auth
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthRequest auth = 7;
     */
    auth?: AuthRequest;
}
/**
 * @generated from protobuf message eve_trading_co_proto.StatusBuybackAppraisalResponse
 */
export interface StatusBuybackAppraisalResponse {
    /**
     * @generated from protobuf field: eve_trading_co_proto.Contract contract = 1;
     */
    contract?: Contract;
    /**
     * @generated from protobuf field: repeated eve_trading_co_proto.ContractItem contract_items = 2;
     */
    contractItems: ContractItem[]; // null if not requested
    /**
     * @generated from protobuf field: eve_trading_co_proto.LocationInfo location_info = 3;
     */
    locationInfo?: LocationInfo; // null unless requested
    /**
     * @generated from protobuf field: eve_trading_co_proto.TypeNamingLists type_naming_lists = 4;
     */
    typeNamingLists?: TypeNamingLists; // null if not requested
    /**
     * @generated from protobuf field: eve_trading_co_proto.LocationNamingMaps location_naming_maps = 5;
     */
    locationNamingMaps?: LocationNamingMaps; // null if not requested
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthResponse auth = 6;
     */
    auth?: AuthResponse;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 7;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message eve_trading_co_proto.StatusShopAppraisalRequest
 */
export interface StatusShopAppraisalRequest {
    /**
     * @generated from protobuf field: string code = 1;
     */
    code: string; // AppraisalCode
    /**
     * @generated from protobuf field: bool include_items = 2;
     */
    includeItems: boolean;
    /**
     * @generated from protobuf field: bool include_location_info = 3;
     */
    includeLocationInfo: boolean;
    /**
     * @generated from protobuf field: eve_trading_co_proto.IncludeTypeNaming include_type_naming = 4;
     */
    includeTypeNaming?: IncludeTypeNaming;
    /**
     * @generated from protobuf field: eve_trading_co_proto.IncludeLocationNaming include_location_naming = 5;
     */
    includeLocationNaming?: IncludeLocationNaming; // ignored if 3 is false
    /**
     * @generated from protobuf field: bool admin = 6;
     */
    admin: boolean; // whether to use admin auth
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthRequest auth = 7;
     */
    auth?: AuthRequest;
}
/**
 * @generated from protobuf message eve_trading_co_proto.StatusShopAppraisalResponse
 */
export interface StatusShopAppraisalResponse {
    /**
     * @generated from protobuf field: eve_trading_co_proto.Contract contract = 1;
     */
    contract?: Contract;
    /**
     * @generated from protobuf field: bool in_purchase_queue = 2;
     */
    inPurchaseQueue: boolean; // if true, contract is always null
    /**
     * @generated from protobuf field: repeated eve_trading_co_proto.ContractItem contract_items = 3;
     */
    contractItems: ContractItem[]; // null if not requested
    /**
     * @generated from protobuf field: eve_trading_co_proto.LocationInfo location_info = 4;
     */
    locationInfo?: LocationInfo; // null unless requested
    /**
     * @generated from protobuf field: eve_trading_co_proto.TypeNamingLists type_naming_lists = 5;
     */
    typeNamingLists?: TypeNamingLists; // null if not requested
    /**
     * @generated from protobuf field: eve_trading_co_proto.LocationNamingMaps location_naming_maps = 6;
     */
    locationNamingMaps?: LocationNamingMaps; // null if not requested
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthResponse auth = 7;
     */
    auth?: AuthResponse;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 8;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message eve_trading_co_proto.ShopInventoryRequest
 */
export interface ShopInventoryRequest {
    /**
     * @generated from protobuf field: int64 location_id = 1;
     */
    locationId: number; // LocationId
    /**
     * @generated from protobuf field: eve_trading_co_proto.IncludeTypeNaming include_type_naming = 2;
     */
    includeTypeNaming?: IncludeTypeNaming;
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthRequest auth = 3;
     */
    auth?: AuthRequest;
}
/**
 * @generated from protobuf message eve_trading_co_proto.ShopInventoryResponse
 */
export interface ShopInventoryResponse {
    /**
     * @generated from protobuf field: repeated eve_trading_co_proto.ShopItem items = 1;
     */
    items: ShopItem[];
    /**
     * @generated from protobuf field: eve_trading_co_proto.TypeNamingLists type_naming_lists = 2;
     */
    typeNamingLists?: TypeNamingLists;
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthResponse auth = 3;
     */
    auth?: AuthResponse;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 4;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message eve_trading_co_proto.ShopMakePurchaseRequest
 */
export interface ShopMakePurchaseRequest {
    /**
     * @generated from protobuf field: int64 location_id = 1;
     */
    locationId: number; // LocationId
    /**
     * @generated from protobuf field: repeated eve_trading_co_proto.BasicItem items = 2;
     */
    items: BasicItem[];
    /**
     * @generated from protobuf field: eve_trading_co_proto.IncludeTypeNaming include_type_naming = 3;
     */
    includeTypeNaming?: IncludeTypeNaming;
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthRequest auth = 4;
     */
    auth?: AuthRequest;
}
/**
 * @generated from protobuf message eve_trading_co_proto.ShopMakePurchaseResponse
 */
export interface ShopMakePurchaseResponse {
    /**
     * @generated from protobuf field: eve_trading_co_proto.MakePurchaseStatus status = 1;
     */
    status: MakePurchaseStatus;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ShopAppraisal appraisal = 2;
     */
    appraisal?: ShopAppraisal;
    /**
     * @generated from protobuf field: eve_trading_co_proto.TypeNamingLists type_naming_lists = 3;
     */
    typeNamingLists?: TypeNamingLists;
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthResponse auth = 4;
     */
    auth?: AuthResponse;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 5;
     */
    error?: ErrorResponse; // purchase failed
}
/**
 * @generated from protobuf message eve_trading_co_proto.UserDataRequest
 */
export interface UserDataRequest {
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthRequest auth = 1;
     */
    auth?: AuthRequest;
}
/**
 * @generated from protobuf message eve_trading_co_proto.UserDataResponse
 */
export interface UserDataResponse {
    /**
     * @generated from protobuf field: repeated eve_trading_co_proto.BuybackAppraisalStatus buyback_appraisals = 1;
     */
    buybackAppraisals: BuybackAppraisalStatus[]; // AppraisalCode
    /**
     * @generated from protobuf field: repeated eve_trading_co_proto.ShopAppraisalStatus shop_appraisals = 2;
     */
    shopAppraisals: ShopAppraisalStatus[]; // AppraisalCode
    /**
     * @generated from protobuf field: int64 cancelled_purchase = 3;
     */
    cancelledPurchase: number; // timestamp of last cancelled purchase
    /**
     * @generated from protobuf field: int64 made_purchase = 4;
     */
    madePurchase: number; // timestamp of last made purchase
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthResponse auth = 5;
     */
    auth?: AuthResponse;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 6;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message eve_trading_co_proto.ShopContractQueueRequest
 */
export interface ShopContractQueueRequest {
    /**
     * @generated from protobuf field: bool include_items = 1;
     */
    includeItems: boolean;
    /**
     * @generated from protobuf field: bool include_code_appraisal = 2;
     */
    includeCodeAppraisal: boolean;
    /**
     * @generated from protobuf field: bool include_new_appraisal = 3;
     */
    includeNewAppraisal: boolean; // requires 2 to be true
    /**
     * @generated from protobuf field: bool include_location_info = 4;
     */
    includeLocationInfo: boolean;
    /**
     * @generated from protobuf field: eve_trading_co_proto.IncludeTypeNaming include_type_naming = 5;
     */
    includeTypeNaming?: IncludeTypeNaming;
    /**
     * @generated from protobuf field: eve_trading_co_proto.IncludeLocationNaming include_location_naming = 6;
     */
    includeLocationNaming?: IncludeLocationNaming; // ignored if 4 is false
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthRequest auth = 7;
     */
    auth?: AuthRequest;
}
/**
 * @generated from protobuf message eve_trading_co_proto.ShopContractQueueResponse
 */
export interface ShopContractQueueResponse {
    /**
     * @generated from protobuf field: repeated eve_trading_co_proto.ShopContractQueueEntry queue = 1;
     */
    queue: ShopContractQueueEntry[];
    /**
     * @generated from protobuf field: eve_trading_co_proto.TypeNamingLists type_naming_lists = 2;
     */
    typeNamingLists?: TypeNamingLists; // null if not requested, empty if no entries
    /**
     * @generated from protobuf field: eve_trading_co_proto.LocationNamingMaps location_naming_maps = 3;
     */
    locationNamingMaps?: LocationNamingMaps; // null if not requested, empty if no entries
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthResponse auth = 4;
     */
    auth?: AuthResponse;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 5;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message eve_trading_co_proto.BuybackContractQueueRequest
 */
export interface BuybackContractQueueRequest {
    /**
     * @generated from protobuf field: bool include_items = 1;
     */
    includeItems: boolean;
    /**
     * @generated from protobuf field: bool include_code_appraisal = 2;
     */
    includeCodeAppraisal: boolean;
    /**
     * @generated from protobuf field: bool include_new_appraisal = 3;
     */
    includeNewAppraisal: boolean; // requires 2 to be true
    /**
     * @generated from protobuf field: bool include_location_info = 4;
     */
    includeLocationInfo: boolean;
    /**
     * @generated from protobuf field: eve_trading_co_proto.IncludeTypeNaming include_type_naming = 5;
     */
    includeTypeNaming?: IncludeTypeNaming;
    /**
     * @generated from protobuf field: eve_trading_co_proto.IncludeLocationNaming include_location_naming = 6;
     */
    includeLocationNaming?: IncludeLocationNaming; // ignored if 4 is false
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthRequest auth = 7;
     */
    auth?: AuthRequest;
}
/**
 * @generated from protobuf message eve_trading_co_proto.BuybackContractQueueResponse
 */
export interface BuybackContractQueueResponse {
    /**
     * @generated from protobuf field: repeated eve_trading_co_proto.BuybackContractQueueEntry queue = 1;
     */
    queue: BuybackContractQueueEntry[];
    /**
     * @generated from protobuf field: eve_trading_co_proto.TypeNamingLists type_naming_lists = 2;
     */
    typeNamingLists?: TypeNamingLists; // null if not requested, empty if no entries
    /**
     * @generated from protobuf field: eve_trading_co_proto.LocationNamingMaps location_naming_maps = 3;
     */
    locationNamingMaps?: LocationNamingMaps; // null if not requested, empty if no entries
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthResponse auth = 4;
     */
    auth?: AuthResponse;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 5;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message eve_trading_co_proto.ShopCancelPurchaseRequest
 */
export interface ShopCancelPurchaseRequest {
    /**
     * @generated from protobuf field: string code = 1;
     */
    code: string; // AppraisalCode
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthRequest auth = 2;
     */
    auth?: AuthRequest;
}
/**
 * @generated from protobuf message eve_trading_co_proto.ShopCancelPurchaseResponse
 */
export interface ShopCancelPurchaseResponse {
    /**
     * @generated from protobuf field: eve_trading_co_proto.CancelPurchaseStatus status = 1;
     */
    status: CancelPurchaseStatus;
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthResponse auth = 2;
     */
    auth?: AuthResponse;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message eve_trading_co_proto.ShopDeletePurchasesRequest
 */
export interface ShopDeletePurchasesRequest {
    /**
     * @generated from protobuf field: repeated string codes = 1;
     */
    codes: string[]; // AppraisalCode
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthRequest auth = 2;
     */
    auth?: AuthRequest;
}
/**
 * @generated from protobuf message eve_trading_co_proto.ShopDeletePurchasesResponse
 */
export interface ShopDeletePurchasesResponse {
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthResponse auth = 1;
     */
    auth?: AuthResponse;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 2;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message eve_trading_co_proto.ParseRequest
 */
export interface ParseRequest {
    /**
     * @generated from protobuf field: string text = 1;
     */
    text: string; // AuthRequest auth = 2;
}
/**
 * @generated from protobuf message eve_trading_co_proto.ParseResponse
 */
export interface ParseResponse {
    /**
     * @generated from protobuf field: repeated eve_trading_co_proto.NamedBasicItem known_items = 1;
     */
    knownItems: NamedBasicItem[];
    /**
     * @generated from protobuf field: repeated eve_trading_co_proto.NamedBasicItem unknown_items = 2;
     */
    unknownItems: NamedBasicItem[];
    /**
     * AuthResponse auth = 3;
     *
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message eve_trading_co_proto.SDETypeDataRequest
 */
export interface SDETypeDataRequest {
}
/**
 * @generated from protobuf message eve_trading_co_proto.SDETypeDataResponse
 */
export interface SDETypeDataResponse {
    /**
     * @generated from protobuf field: repeated int32 types = 1;
     */
    types: number[];
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 2;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message eve_trading_co_proto.NamedSDETypeDataRequest
 */
export interface NamedSDETypeDataRequest {
}
/**
 * @generated from protobuf message eve_trading_co_proto.NamedSDETypeDataResponse
 */
export interface NamedSDETypeDataResponse {
    /**
     * @generated from protobuf field: repeated eve_trading_co_proto.NamedType types = 1;
     */
    types: NamedType[];
    /**
     * @generated from protobuf field: eve_trading_co_proto.TypeNamingLists type_naming_lists = 2;
     */
    typeNamingLists?: TypeNamingLists;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message eve_trading_co_proto.ShopLocation
 */
export interface ShopLocation {
    /**
     * @generated from protobuf field: int64 location_id = 1;
     */
    locationId: number; // LocationId
    /**
     * @generated from protobuf field: eve_trading_co_proto.LocationInfo location_info = 2;
     */
    locationInfo?: LocationInfo; // null unless requested
}
/**
 * @generated from protobuf message eve_trading_co_proto.ShopLocationsRequest
 */
export interface ShopLocationsRequest {
    /**
     * @generated from protobuf field: bool include_location_info = 1;
     */
    includeLocationInfo: boolean;
    /**
     * @generated from protobuf field: eve_trading_co_proto.IncludeLocationNaming include_location_naming = 2;
     */
    includeLocationNaming?: IncludeLocationNaming; // ignored if 1 is false
}
/**
 * @generated from protobuf message eve_trading_co_proto.ShopLocationsResponse
 */
export interface ShopLocationsResponse {
    /**
     * @generated from protobuf field: repeated eve_trading_co_proto.ShopLocation locations = 1;
     */
    locations: ShopLocation[];
    /**
     * @generated from protobuf field: eve_trading_co_proto.LocationNamingMaps location_naming_maps = 2;
     */
    locationNamingMaps?: LocationNamingMaps; // null if not requested
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message eve_trading_co_proto.System
 */
export interface System {
    /**
     * @generated from protobuf field: int32 system_id = 1;
     */
    systemId: number; // SystemId
    /**
     * @generated from protobuf field: int32 region_id = 2;
     */
    regionId: number;
}
/**
 * @generated from protobuf message eve_trading_co_proto.BuybackSystemsRequest
 */
export interface BuybackSystemsRequest {
    /**
     * @generated from protobuf field: eve_trading_co_proto.IncludeLocationNaming include_location_naming = 1;
     */
    includeLocationNaming?: IncludeLocationNaming; // system and region names only
}
/**
 * @generated from protobuf message eve_trading_co_proto.BuybackSystemsResponse
 */
export interface BuybackSystemsResponse {
    /**
     * @generated from protobuf field: repeated eve_trading_co_proto.System systems = 1;
     */
    systems: System[];
    /**
     * @generated from protobuf field: eve_trading_co_proto.LocationNamingMaps location_naming_maps = 2;
     */
    locationNamingMaps?: LocationNamingMaps; // null if not requested
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message eve_trading_co_proto.ShopPurchaseQueueRequest
 */
export interface ShopPurchaseQueueRequest {
    /**
     * @generated from protobuf field: bool include_code_appraisal = 1;
     */
    includeCodeAppraisal: boolean;
    /**
     * @generated from protobuf field: bool include_new_appraisal = 2;
     */
    includeNewAppraisal: boolean; // requires 1 to be true
    /**
     * @generated from protobuf field: eve_trading_co_proto.IncludeTypeNaming include_type_naming = 3;
     */
    includeTypeNaming?: IncludeTypeNaming;
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthRequest auth = 4;
     */
    auth?: AuthRequest;
}
/**
 * @generated from protobuf message eve_trading_co_proto.ShopPurchaseQueueResponse
 */
export interface ShopPurchaseQueueResponse {
    /**
     * @generated from protobuf field: repeated eve_trading_co_proto.PurchaseQueueEntry queue = 1;
     */
    queue: PurchaseQueueEntry[];
    /**
     * @generated from protobuf field: eve_trading_co_proto.TypeNamingLists type_naming_lists = 2;
     */
    typeNamingLists?: TypeNamingLists; // null if not requested, empty if no entries
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthResponse auth = 3;
     */
    auth?: AuthResponse;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 4;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message eve_trading_co_proto.EsiAppLoginRequest
 */
export interface EsiAppLoginRequest {
    /**
     * @generated from protobuf field: string code = 1;
     */
    code: string; // esi sso code
    /**
     * @generated from protobuf field: eve_trading_co_proto.EsiApp app = 2;
     */
    app: EsiApp;
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthRequest auth = 3;
     */
    auth?: AuthRequest;
}
/**
 * @generated from protobuf message eve_trading_co_proto.EsiAppLoginResponse
 */
export interface EsiAppLoginResponse {
    /**
     * @generated from protobuf field: string token = 1;
     */
    token: string; // esi web token
    /**
     * @generated from protobuf field: string jwt = 2;
     */
    jwt: string;
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthResponse auth = 3;
     */
    auth?: AuthResponse;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 4;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message eve_trading_co_proto.SDESystem
 */
export interface SDESystem {
    /**
     * @generated from protobuf field: int32 system_id = 1;
     */
    systemId: number; // SystemId
    /**
     * @generated from protobuf field: int32 region_id = 2;
     */
    regionId: number; // RegionId
}
/**
 * @generated from protobuf message eve_trading_co_proto.SDESystemsRequest
 */
export interface SDESystemsRequest {
    /**
     * @generated from protobuf field: eve_trading_co_proto.IncludeLocationNaming include_location_naming = 1;
     */
    includeLocationNaming?: IncludeLocationNaming; // system and region names only
}
/**
 * @generated from protobuf message eve_trading_co_proto.SDESystemsResponse
 */
export interface SDESystemsResponse {
    /**
     * @generated from protobuf field: repeated eve_trading_co_proto.System systems = 1;
     */
    systems: System[];
    /**
     * @generated from protobuf field: eve_trading_co_proto.LocationNamingMaps location_naming_maps = 2;
     */
    locationNamingMaps?: LocationNamingMaps; // null if not requested
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message eve_trading_co_proto.CfgGetBuybackBundleKeysRequest
 */
export interface CfgGetBuybackBundleKeysRequest {
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthRequest auth = 1;
     */
    auth?: AuthRequest;
}
/**
 * @generated from protobuf message eve_trading_co_proto.CfgGetBuybackBundleKeysResponse
 */
export interface CfgGetBuybackBundleKeysResponse {
    /**
     * @generated from protobuf field: repeated string bundle_keys = 1;
     */
    bundleKeys: string[]; // BuybackSystemBundleKey
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthResponse auth = 2;
     */
    auth?: AuthResponse;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message eve_trading_co_proto.CfgGetShopBundleKeysRequest
 */
export interface CfgGetShopBundleKeysRequest {
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthRequest auth = 1;
     */
    auth?: AuthRequest;
}
/**
 * @generated from protobuf message eve_trading_co_proto.CfgGetShopBundleKeysResponse
 */
export interface CfgGetShopBundleKeysResponse {
    /**
     * @generated from protobuf field: repeated string bundle_keys = 1;
     */
    bundleKeys: string[]; // ShopLocationBundleKey
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthResponse auth = 2;
     */
    auth?: AuthResponse;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message eve_trading_co_proto.CfgGetMarketNamesRequest
 */
export interface CfgGetMarketNamesRequest {
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthRequest auth = 1;
     */
    auth?: AuthRequest;
}
/**
 * @generated from protobuf message eve_trading_co_proto.CfgGetMarketNamesResponse
 */
export interface CfgGetMarketNamesResponse {
    /**
     * @generated from protobuf field: repeated string market_names = 1;
     */
    marketNames: string[];
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthResponse auth = 2;
     */
    auth?: AuthResponse;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message eve_trading_co_proto.IsAdminRequest
 */
export interface IsAdminRequest {
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthRequest auth = 1;
     */
    auth?: AuthRequest;
}
/**
 * @generated from protobuf message eve_trading_co_proto.IsAdminResponse
 */
export interface IsAdminResponse {
    /**
     * @generated from protobuf field: bool is_admin = 1;
     */
    isAdmin: boolean;
    /**
     * @generated from protobuf field: eve_trading_co_proto.AuthResponse auth = 2;
     */
    auth?: AuthResponse;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message eve_trading_co_proto.CharacterInfoRequest
 */
export interface CharacterInfoRequest {
    /**
     * @generated from protobuf field: int32 character_id = 1;
     */
    characterId: number;
}
/**
 * @generated from protobuf message eve_trading_co_proto.CharacterInfoResponse
 */
export interface CharacterInfoResponse {
    /**
     * @generated from protobuf field: int32 character_id = 1;
     */
    characterId: number;
    /**
     * @generated from protobuf field: int32 corporation_id = 2;
     */
    corporationId: number;
    /**
     * @generated from protobuf field: eve_trading_co_proto.OptionalInt32 alliance_id = 3;
     */
    allianceId?: OptionalInt32;
    /**
     * @generated from protobuf field: string name = 4;
     */
    name: string;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 5;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message eve_trading_co_proto.CorporationInfoRequest
 */
export interface CorporationInfoRequest {
    /**
     * @generated from protobuf field: int32 corporation_id = 1;
     */
    corporationId: number;
}
/**
 * @generated from protobuf message eve_trading_co_proto.CorporationInfoResponse
 */
export interface CorporationInfoResponse {
    /**
     * @generated from protobuf field: int32 corporation_id = 1;
     */
    corporationId: number;
    /**
     * @generated from protobuf field: eve_trading_co_proto.OptionalInt32 alliance_id = 2;
     */
    allianceId?: OptionalInt32;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string ticker = 4;
     */
    ticker: string;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 5;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message eve_trading_co_proto.AllianceInfoRequest
 */
export interface AllianceInfoRequest {
    /**
     * @generated from protobuf field: int32 alliance_id = 1;
     */
    allianceId: number;
}
/**
 * @generated from protobuf message eve_trading_co_proto.AllianceInfoResponse
 */
export interface AllianceInfoResponse {
    /**
     * @generated from protobuf field: int32 alliance_id = 1;
     */
    allianceId: number;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: string ticker = 3;
     */
    ticker: string;
    /**
     * @generated from protobuf field: eve_trading_co_proto.ErrorResponse error = 4;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf enum eve_trading_co_proto.ErrorCode
 */
export enum ErrorCode {
    /**
     * @generated from protobuf enum value: OK = 0;
     */
    OK = 0,
    /**
     * @generated from protobuf enum value: SERVER_ERROR = 1;
     */
    SERVER_ERROR = 1,
    /**
     * @generated from protobuf enum value: INVALID_REQUEST = 2;
     */
    INVALID_REQUEST = 2,
    /**
     * @generated from protobuf enum value: INVALID_MERGE = 3;
     */
    INVALID_MERGE = 3
}
/**
 * @generated from protobuf enum eve_trading_co_proto.ContractStatus
 */
export enum ContractStatus {
    /**
     * @generated from protobuf enum value: unknown_status = 0;
     */
    unknown_status = 0,
    /**
     * @generated from protobuf enum value: outstanding = 1;
     */
    outstanding = 1,
    /**
     * @generated from protobuf enum value: in_progress = 2;
     */
    in_progress = 2,
    /**
     * @generated from protobuf enum value: finished_issuer = 3;
     */
    finished_issuer = 3,
    /**
     * @generated from protobuf enum value: finished_contractor = 4;
     */
    finished_contractor = 4,
    /**
     * @generated from protobuf enum value: finished = 5;
     */
    finished = 5,
    /**
     * @generated from protobuf enum value: cancelled = 6;
     */
    cancelled = 6,
    /**
     * @generated from protobuf enum value: rejected = 7;
     */
    rejected = 7,
    /**
     * @generated from protobuf enum value: failed = 8;
     */
    failed = 8,
    /**
     * @generated from protobuf enum value: deleted = 9;
     */
    deleted = 9,
    /**
     * @generated from protobuf enum value: reversed = 10;
     */
    reversed = 10
}
/**
 * @generated from protobuf enum eve_trading_co_proto.ContractAssigneeType
 */
export enum ContractAssigneeType {
    /**
     * @generated from protobuf enum value: unknown_assignee_type = 0;
     */
    unknown_assignee_type = 0,
    /**
     * @generated from protobuf enum value: corporation = 1;
     */
    corporation = 1,
    /**
     * @generated from protobuf enum value: character = 2;
     */
    character = 2,
    /**
     * @generated from protobuf enum value: alliance = 3;
     */
    alliance = 3
}
/**
 * @generated from protobuf enum eve_trading_co_proto.MakePurchaseStatus
 */
export enum MakePurchaseStatus {
    /**
     * @generated from protobuf enum value: MPS_SUCCESS = 0;
     */
    MPS_SUCCESS = 0,
    /**
     * @generated from protobuf enum value: MPS_COOLDOWN_LIMIT = 1;
     */
    MPS_COOLDOWN_LIMIT = 1,
    /**
     * @generated from protobuf enum value: MPS_MAX_ACTIVE_LIMIT = 2;
     */
    MPS_MAX_ACTIVE_LIMIT = 2,
    /**
     * @generated from protobuf enum value: MPS_ITEMS_REJECTED = 3;
     */
    MPS_ITEMS_REJECTED = 3,
    /**
     * @generated from protobuf enum value: MPS_ITEMS_UNAVAILABLE = 4;
     */
    MPS_ITEMS_UNAVAILABLE = 4,
    /**
     * @generated from protobuf enum value: MPS_ITEMS_REJECTED_AND_UNAVAILABLE = 5;
     */
    MPS_ITEMS_REJECTED_AND_UNAVAILABLE = 5
}
/**
 * @generated from protobuf enum eve_trading_co_proto.CancelPurchaseStatus
 */
export enum CancelPurchaseStatus {
    /**
     * @generated from protobuf enum value: CPS_SUCCESS = 0;
     */
    CPS_SUCCESS = 0,
    /**
     * @generated from protobuf enum value: CPS_COOLDOWN_LIMIT = 1;
     */
    CPS_COOLDOWN_LIMIT = 1,
    /**
     * @generated from protobuf enum value: CPS_NOT_FOUND = 2;
     */
    CPS_NOT_FOUND = 2,
    /**
     * @generated from protobuf enum value: CPS_COOLDOWN_LIMIT_AND_NOT_FOUND = 3;
     */
    CPS_COOLDOWN_LIMIT_AND_NOT_FOUND = 3,
    /**
     * @generated from protobuf enum value: CPS_NOT_ACTIVE = 4;
     */
    CPS_NOT_ACTIVE = 4
}
/**
 * @generated from protobuf enum eve_trading_co_proto.EsiApp
 */
export enum EsiApp {
    /**
     * @generated from protobuf enum value: EA_AUTH = 0;
     */
    EA_AUTH = 0,
    /**
     * @generated from protobuf enum value: EA_MARKETS = 1;
     */
    EA_MARKETS = 1,
    /**
     * @generated from protobuf enum value: EA_CORPORATION = 2;
     */
    EA_CORPORATION = 2,
    /**
     * @generated from protobuf enum value: EA_STRUCTURE_INFO = 3;
     */
    EA_STRUCTURE_INFO = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class OptionalInt32$Type extends MessageType<OptionalInt32> {
    constructor() {
        super("eve_trading_co_proto.OptionalInt32", [
            { no: 1, name: "inner", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<OptionalInt32>): OptionalInt32 {
        const message = { inner: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OptionalInt32>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OptionalInt32): OptionalInt32 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 inner */ 1:
                    message.inner = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OptionalInt32, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 inner = 1; */
        if (message.inner !== 0)
            writer.tag(1, WireType.Varint).int32(message.inner);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.OptionalInt32
 */
export const OptionalInt32 = new OptionalInt32$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthRequest$Type extends MessageType<AuthRequest> {
    constructor() {
        super("eve_trading_co_proto.AuthRequest", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AuthRequest>): AuthRequest {
        const message = { token: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AuthRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthRequest): AuthRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.AuthRequest
 */
export const AuthRequest = new AuthRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthResponse$Type extends MessageType<AuthResponse> {
    constructor() {
        super("eve_trading_co_proto.AuthResponse", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "authorized", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AuthResponse>): AuthResponse {
        const message = { token: "", authorized: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AuthResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthResponse): AuthResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                case /* bool authorized */ 2:
                    message.authorized = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        /* bool authorized = 2; */
        if (message.authorized !== false)
            writer.tag(2, WireType.Varint).bool(message.authorized);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.AuthResponse
 */
export const AuthResponse = new AuthResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ErrorResponse$Type extends MessageType<ErrorResponse> {
    constructor() {
        super("eve_trading_co_proto.ErrorResponse", [
            { no: 1, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "enum", T: () => ["eve_trading_co_proto.ErrorCode", ErrorCode] }
        ]);
    }
    create(value?: PartialMessage<ErrorResponse>): ErrorResponse {
        const message = { error: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ErrorResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ErrorResponse): ErrorResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string error */ 1:
                    message.error = reader.string();
                    break;
                case /* eve_trading_co_proto.ErrorCode code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ErrorResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string error = 1; */
        if (message.error !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.error);
        /* eve_trading_co_proto.ErrorCode code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.ErrorResponse
 */
export const ErrorResponse = new ErrorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgTypePricing$Type extends MessageType<CfgTypePricing> {
    constructor() {
        super("eve_trading_co_proto.CfgTypePricing", [
            { no: 1, name: "is_buy", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "percentile", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "modifier", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "market", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CfgTypePricing>): CfgTypePricing {
        const message = { isBuy: false, percentile: 0, modifier: 0, market: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgTypePricing>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgTypePricing): CfgTypePricing {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_buy */ 1:
                    message.isBuy = reader.bool();
                    break;
                case /* uint32 percentile */ 2:
                    message.percentile = reader.uint32();
                    break;
                case /* uint32 modifier */ 3:
                    message.modifier = reader.uint32();
                    break;
                case /* string market */ 4:
                    message.market = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgTypePricing, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_buy = 1; */
        if (message.isBuy !== false)
            writer.tag(1, WireType.Varint).bool(message.isBuy);
        /* uint32 percentile = 2; */
        if (message.percentile !== 0)
            writer.tag(2, WireType.Varint).uint32(message.percentile);
        /* uint32 modifier = 3; */
        if (message.modifier !== 0)
            writer.tag(3, WireType.Varint).uint32(message.modifier);
        /* string market = 4; */
        if (message.market !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.market);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgTypePricing
 */
export const CfgTypePricing = new CfgTypePricing$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgBuybackTypePricing$Type extends MessageType<CfgBuybackTypePricing> {
    constructor() {
        super("eve_trading_co_proto.CfgBuybackTypePricing", [
            { no: 1, name: "pricing", kind: "message", T: () => CfgTypePricing },
            { no: 2, name: "reprocessing_efficiency", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CfgBuybackTypePricing>): CfgBuybackTypePricing {
        const message = { reprocessingEfficiency: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgBuybackTypePricing>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgBuybackTypePricing): CfgBuybackTypePricing {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eve_trading_co_proto.CfgTypePricing pricing */ 1:
                    message.pricing = CfgTypePricing.internalBinaryRead(reader, reader.uint32(), options, message.pricing);
                    break;
                case /* uint32 reprocessing_efficiency */ 2:
                    message.reprocessingEfficiency = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgBuybackTypePricing, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eve_trading_co_proto.CfgTypePricing pricing = 1; */
        if (message.pricing)
            CfgTypePricing.internalBinaryWrite(message.pricing, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 reprocessing_efficiency = 2; */
        if (message.reprocessingEfficiency !== 0)
            writer.tag(2, WireType.Varint).uint32(message.reprocessingEfficiency);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgBuybackTypePricing
 */
export const CfgBuybackTypePricing = new CfgBuybackTypePricing$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgShopTypePricing$Type extends MessageType<CfgShopTypePricing> {
    constructor() {
        super("eve_trading_co_proto.CfgShopTypePricing", [
            { no: 1, name: "inner", kind: "message", T: () => CfgTypePricing }
        ]);
    }
    create(value?: PartialMessage<CfgShopTypePricing>): CfgShopTypePricing {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgShopTypePricing>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgShopTypePricing): CfgShopTypePricing {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eve_trading_co_proto.CfgTypePricing inner */ 1:
                    message.inner = CfgTypePricing.internalBinaryRead(reader, reader.uint32(), options, message.inner);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgShopTypePricing, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eve_trading_co_proto.CfgTypePricing inner = 1; */
        if (message.inner)
            CfgTypePricing.internalBinaryWrite(message.inner, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgShopTypePricing
 */
export const CfgShopTypePricing = new CfgShopTypePricing$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgBuybackSystemTypeBundle$Type extends MessageType<CfgBuybackSystemTypeBundle> {
    constructor() {
        super("eve_trading_co_proto.CfgBuybackSystemTypeBundle", [
            { no: 1, name: "inner", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => CfgBuybackTypePricing } }
        ]);
    }
    create(value?: PartialMessage<CfgBuybackSystemTypeBundle>): CfgBuybackSystemTypeBundle {
        const message = { inner: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgBuybackSystemTypeBundle>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgBuybackSystemTypeBundle): CfgBuybackSystemTypeBundle {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, eve_trading_co_proto.CfgBuybackTypePricing> inner */ 1:
                    this.binaryReadMap1(message.inner, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CfgBuybackSystemTypeBundle["inner"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CfgBuybackSystemTypeBundle["inner"] | undefined, val: CfgBuybackSystemTypeBundle["inner"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = CfgBuybackTypePricing.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field eve_trading_co_proto.CfgBuybackSystemTypeBundle.inner");
            }
        }
        map[key ?? ""] = val ?? CfgBuybackTypePricing.create();
    }
    internalBinaryWrite(message: CfgBuybackSystemTypeBundle, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, eve_trading_co_proto.CfgBuybackTypePricing> inner = 1; */
        for (let k of Object.keys(message.inner)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            CfgBuybackTypePricing.internalBinaryWrite(message.inner[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgBuybackSystemTypeBundle
 */
export const CfgBuybackSystemTypeBundle = new CfgBuybackSystemTypeBundle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgShopLocationTypeBundle$Type extends MessageType<CfgShopLocationTypeBundle> {
    constructor() {
        super("eve_trading_co_proto.CfgShopLocationTypeBundle", [
            { no: 1, name: "inner", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => CfgShopTypePricing } }
        ]);
    }
    create(value?: PartialMessage<CfgShopLocationTypeBundle>): CfgShopLocationTypeBundle {
        const message = { inner: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgShopLocationTypeBundle>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgShopLocationTypeBundle): CfgShopLocationTypeBundle {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, eve_trading_co_proto.CfgShopTypePricing> inner */ 1:
                    this.binaryReadMap1(message.inner, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CfgShopLocationTypeBundle["inner"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CfgShopLocationTypeBundle["inner"] | undefined, val: CfgShopLocationTypeBundle["inner"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = CfgShopTypePricing.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field eve_trading_co_proto.CfgShopLocationTypeBundle.inner");
            }
        }
        map[key ?? ""] = val ?? CfgShopTypePricing.create();
    }
    internalBinaryWrite(message: CfgShopLocationTypeBundle, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, eve_trading_co_proto.CfgShopTypePricing> inner = 1; */
        for (let k of Object.keys(message.inner)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            CfgShopTypePricing.internalBinaryWrite(message.inner[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgShopLocationTypeBundle
 */
export const CfgShopLocationTypeBundle = new CfgShopLocationTypeBundle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgBuybackSystem$Type extends MessageType<CfgBuybackSystem> {
    constructor() {
        super("eve_trading_co_proto.CfgBuybackSystem", [
            { no: 1, name: "bundle_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "m3_fee", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<CfgBuybackSystem>): CfgBuybackSystem {
        const message = { bundleKey: "", m3Fee: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgBuybackSystem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgBuybackSystem): CfgBuybackSystem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string bundle_key */ 1:
                    message.bundleKey = reader.string();
                    break;
                case /* double m3_fee */ 2:
                    message.m3Fee = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgBuybackSystem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string bundle_key = 1; */
        if (message.bundleKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.bundleKey);
        /* double m3_fee = 2; */
        if (message.m3Fee !== 0)
            writer.tag(2, WireType.Bit64).double(message.m3Fee);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgBuybackSystem
 */
export const CfgBuybackSystem = new CfgBuybackSystem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgShopLocation$Type extends MessageType<CfgShopLocation> {
    constructor() {
        super("eve_trading_co_proto.CfgShopLocation", [
            { no: 1, name: "bundle_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "banned_flags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CfgShopLocation>): CfgShopLocation {
        const message = { bundleKey: "", bannedFlags: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgShopLocation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgShopLocation): CfgShopLocation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string bundle_key */ 1:
                    message.bundleKey = reader.string();
                    break;
                case /* repeated string banned_flags */ 2:
                    message.bannedFlags.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgShopLocation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string bundle_key = 1; */
        if (message.bundleKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.bundleKey);
        /* repeated string banned_flags = 2; */
        for (let i = 0; i < message.bannedFlags.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.bannedFlags[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgShopLocation
 */
export const CfgShopLocation = new CfgShopLocation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgMarket$Type extends MessageType<CfgMarket> {
    constructor() {
        super("eve_trading_co_proto.CfgMarket", [
            { no: 1, name: "refresh_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "location_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "is_structure", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CfgMarket>): CfgMarket {
        const message = { refreshToken: "", locationId: 0, isStructure: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgMarket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgMarket): CfgMarket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string refresh_token */ 1:
                    message.refreshToken = reader.string();
                    break;
                case /* int64 location_id */ 2:
                    message.locationId = reader.int64().toNumber();
                    break;
                case /* bool is_structure */ 3:
                    message.isStructure = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgMarket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string refresh_token = 1; */
        if (message.refreshToken !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.refreshToken);
        /* int64 location_id = 2; */
        if (message.locationId !== 0)
            writer.tag(2, WireType.Varint).int64(message.locationId);
        /* bool is_structure = 3; */
        if (message.isStructure !== false)
            writer.tag(3, WireType.Varint).bool(message.isStructure);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgMarket
 */
export const CfgMarket = new CfgMarket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthList$Type extends MessageType<AuthList> {
    constructor() {
        super("eve_trading_co_proto.AuthList", [
            { no: 1, name: "banned_character_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "permit_character_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "banned_corporation_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "permit_corporation_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "permit_alliance_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AuthList>): AuthList {
        const message = { bannedCharacterIds: [], permitCharacterIds: [], bannedCorporationIds: [], permitCorporationIds: [], permitAllianceIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AuthList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthList): AuthList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 banned_character_ids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.bannedCharacterIds.push(reader.int32());
                    else
                        message.bannedCharacterIds.push(reader.int32());
                    break;
                case /* repeated int32 permit_character_ids */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.permitCharacterIds.push(reader.int32());
                    else
                        message.permitCharacterIds.push(reader.int32());
                    break;
                case /* repeated int32 banned_corporation_ids */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.bannedCorporationIds.push(reader.int32());
                    else
                        message.bannedCorporationIds.push(reader.int32());
                    break;
                case /* repeated int32 permit_corporation_ids */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.permitCorporationIds.push(reader.int32());
                    else
                        message.permitCorporationIds.push(reader.int32());
                    break;
                case /* repeated int32 permit_alliance_ids */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.permitAllianceIds.push(reader.int32());
                    else
                        message.permitAllianceIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 banned_character_ids = 1; */
        if (message.bannedCharacterIds.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.bannedCharacterIds.length; i++)
                writer.int32(message.bannedCharacterIds[i]);
            writer.join();
        }
        /* repeated int32 permit_character_ids = 2; */
        if (message.permitCharacterIds.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.permitCharacterIds.length; i++)
                writer.int32(message.permitCharacterIds[i]);
            writer.join();
        }
        /* repeated int32 banned_corporation_ids = 3; */
        if (message.bannedCorporationIds.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.bannedCorporationIds.length; i++)
                writer.int32(message.bannedCorporationIds[i]);
            writer.join();
        }
        /* repeated int32 permit_corporation_ids = 4; */
        if (message.permitCorporationIds.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.permitCorporationIds.length; i++)
                writer.int32(message.permitCorporationIds[i]);
            writer.join();
        }
        /* repeated int32 permit_alliance_ids = 5; */
        if (message.permitAllianceIds.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.permitAllianceIds.length; i++)
                writer.int32(message.permitAllianceIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.AuthList
 */
export const AuthList = new AuthList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IncludeTypeNaming$Type extends MessageType<IncludeTypeNaming> {
    constructor() {
        super("eve_trading_co_proto.IncludeTypeNaming", [
            { no: 1, name: "include_name", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "include_market_groups", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "include_group", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "include_category", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<IncludeTypeNaming>): IncludeTypeNaming {
        const message = { includeName: false, includeMarketGroups: false, includeGroup: false, includeCategory: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IncludeTypeNaming>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IncludeTypeNaming): IncludeTypeNaming {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool include_name */ 1:
                    message.includeName = reader.bool();
                    break;
                case /* bool include_market_groups */ 2:
                    message.includeMarketGroups = reader.bool();
                    break;
                case /* bool include_group */ 3:
                    message.includeGroup = reader.bool();
                    break;
                case /* bool include_category */ 4:
                    message.includeCategory = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IncludeTypeNaming, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool include_name = 1; */
        if (message.includeName !== false)
            writer.tag(1, WireType.Varint).bool(message.includeName);
        /* bool include_market_groups = 2; */
        if (message.includeMarketGroups !== false)
            writer.tag(2, WireType.Varint).bool(message.includeMarketGroups);
        /* bool include_group = 3; */
        if (message.includeGroup !== false)
            writer.tag(3, WireType.Varint).bool(message.includeGroup);
        /* bool include_category = 4; */
        if (message.includeCategory !== false)
            writer.tag(4, WireType.Varint).bool(message.includeCategory);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.IncludeTypeNaming
 */
export const IncludeTypeNaming = new IncludeTypeNaming$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeNamingIndexes$Type extends MessageType<TypeNamingIndexes> {
    constructor() {
        super("eve_trading_co_proto.TypeNamingIndexes", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "group_index", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 3, name: "category_index", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 4, name: "market_group_indexes", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TypeNamingIndexes>): TypeNamingIndexes {
        const message = { name: "", groupIndex: 0, categoryIndex: 0, marketGroupIndexes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TypeNamingIndexes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TypeNamingIndexes): TypeNamingIndexes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* sint32 group_index */ 2:
                    message.groupIndex = reader.sint32();
                    break;
                case /* sint32 category_index */ 3:
                    message.categoryIndex = reader.sint32();
                    break;
                case /* repeated int32 market_group_indexes */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.marketGroupIndexes.push(reader.int32());
                    else
                        message.marketGroupIndexes.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TypeNamingIndexes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* sint32 group_index = 2; */
        if (message.groupIndex !== 0)
            writer.tag(2, WireType.Varint).sint32(message.groupIndex);
        /* sint32 category_index = 3; */
        if (message.categoryIndex !== 0)
            writer.tag(3, WireType.Varint).sint32(message.categoryIndex);
        /* repeated int32 market_group_indexes = 4; */
        if (message.marketGroupIndexes.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.marketGroupIndexes.length; i++)
                writer.int32(message.marketGroupIndexes[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.TypeNamingIndexes
 */
export const TypeNamingIndexes = new TypeNamingIndexes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeNamingLists$Type extends MessageType<TypeNamingLists> {
    constructor() {
        super("eve_trading_co_proto.TypeNamingLists", [
            { no: 1, name: "groups", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "categories", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "market_groups", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TypeNamingLists>): TypeNamingLists {
        const message = { groups: [], categories: [], marketGroups: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TypeNamingLists>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TypeNamingLists): TypeNamingLists {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string groups */ 1:
                    message.groups.push(reader.string());
                    break;
                case /* repeated string categories */ 2:
                    message.categories.push(reader.string());
                    break;
                case /* repeated string market_groups */ 3:
                    message.marketGroups.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TypeNamingLists, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string groups = 1; */
        for (let i = 0; i < message.groups.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.groups[i]);
        /* repeated string categories = 2; */
        for (let i = 0; i < message.categories.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.categories[i]);
        /* repeated string market_groups = 3; */
        for (let i = 0; i < message.marketGroups.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.marketGroups[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.TypeNamingLists
 */
export const TypeNamingLists = new TypeNamingLists$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocationInfo$Type extends MessageType<LocationInfo> {
    constructor() {
        super("eve_trading_co_proto.LocationInfo", [
            { no: 1, name: "is_structure", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "forbidden_structure", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "system_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "region_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<LocationInfo>): LocationInfo {
        const message = { isStructure: false, forbiddenStructure: false, systemId: 0, regionId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LocationInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LocationInfo): LocationInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_structure */ 1:
                    message.isStructure = reader.bool();
                    break;
                case /* bool forbidden_structure */ 2:
                    message.forbiddenStructure = reader.bool();
                    break;
                case /* int32 system_id */ 3:
                    message.systemId = reader.int32();
                    break;
                case /* int32 region_id */ 4:
                    message.regionId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LocationInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_structure = 1; */
        if (message.isStructure !== false)
            writer.tag(1, WireType.Varint).bool(message.isStructure);
        /* bool forbidden_structure = 2; */
        if (message.forbiddenStructure !== false)
            writer.tag(2, WireType.Varint).bool(message.forbiddenStructure);
        /* int32 system_id = 3; */
        if (message.systemId !== 0)
            writer.tag(3, WireType.Varint).int32(message.systemId);
        /* int32 region_id = 4; */
        if (message.regionId !== 0)
            writer.tag(4, WireType.Varint).int32(message.regionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.LocationInfo
 */
export const LocationInfo = new LocationInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IncludeLocationNaming$Type extends MessageType<IncludeLocationNaming> {
    constructor() {
        super("eve_trading_co_proto.IncludeLocationNaming", [
            { no: 1, name: "include_location_name", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "include_system_name", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "include_region_name", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<IncludeLocationNaming>): IncludeLocationNaming {
        const message = { includeLocationName: false, includeSystemName: false, includeRegionName: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IncludeLocationNaming>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IncludeLocationNaming): IncludeLocationNaming {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool include_location_name */ 1:
                    message.includeLocationName = reader.bool();
                    break;
                case /* bool include_system_name */ 2:
                    message.includeSystemName = reader.bool();
                    break;
                case /* bool include_region_name */ 3:
                    message.includeRegionName = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IncludeLocationNaming, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool include_location_name = 1; */
        if (message.includeLocationName !== false)
            writer.tag(1, WireType.Varint).bool(message.includeLocationName);
        /* bool include_system_name = 2; */
        if (message.includeSystemName !== false)
            writer.tag(2, WireType.Varint).bool(message.includeSystemName);
        /* bool include_region_name = 3; */
        if (message.includeRegionName !== false)
            writer.tag(3, WireType.Varint).bool(message.includeRegionName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.IncludeLocationNaming
 */
export const IncludeLocationNaming = new IncludeLocationNaming$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocationNamingMaps$Type extends MessageType<LocationNamingMaps> {
    constructor() {
        super("eve_trading_co_proto.LocationNamingMaps", [
            { no: 1, name: "location_names", kind: "map", K: 3 /*ScalarType.INT64*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 2, name: "system_names", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 3, name: "region_names", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<LocationNamingMaps>): LocationNamingMaps {
        const message = { locationNames: {}, systemNames: {}, regionNames: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LocationNamingMaps>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LocationNamingMaps): LocationNamingMaps {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int64, string> location_names */ 1:
                    this.binaryReadMap1(message.locationNames, reader, options);
                    break;
                case /* map<int32, string> system_names */ 2:
                    this.binaryReadMap2(message.systemNames, reader, options);
                    break;
                case /* map<int32, string> region_names */ 3:
                    this.binaryReadMap3(message.regionNames, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: LocationNamingMaps["locationNames"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof LocationNamingMaps["locationNames"] | undefined, val: LocationNamingMaps["locationNames"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int64().toString();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field eve_trading_co_proto.LocationNamingMaps.location_names");
            }
        }
        map[key ?? "0"] = val ?? "";
    }
    private binaryReadMap2(map: LocationNamingMaps["systemNames"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof LocationNamingMaps["systemNames"] | undefined, val: LocationNamingMaps["systemNames"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field eve_trading_co_proto.LocationNamingMaps.system_names");
            }
        }
        map[key ?? 0] = val ?? "";
    }
    private binaryReadMap3(map: LocationNamingMaps["regionNames"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof LocationNamingMaps["regionNames"] | undefined, val: LocationNamingMaps["regionNames"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field eve_trading_co_proto.LocationNamingMaps.region_names");
            }
        }
        map[key ?? 0] = val ?? "";
    }
    internalBinaryWrite(message: LocationNamingMaps, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int64, string> location_names = 1; */
        for (let k of Object.keys(message.locationNames))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int64(k).tag(2, WireType.LengthDelimited).string(message.locationNames[k]).join();
        /* map<int32, string> system_names = 2; */
        for (let k of Object.keys(message.systemNames))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.LengthDelimited).string(message.systemNames[k as any]).join();
        /* map<int32, string> region_names = 3; */
        for (let k of Object.keys(message.regionNames))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.LengthDelimited).string(message.regionNames[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.LocationNamingMaps
 */
export const LocationNamingMaps = new LocationNamingMaps$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NamedType$Type extends MessageType<NamedType> {
    constructor() {
        super("eve_trading_co_proto.NamedType", [
            { no: 1, name: "type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type_naming_indexes", kind: "message", T: () => TypeNamingIndexes }
        ]);
    }
    create(value?: PartialMessage<NamedType>): NamedType {
        const message = { typeId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NamedType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NamedType): NamedType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 type_id */ 1:
                    message.typeId = reader.int32();
                    break;
                case /* eve_trading_co_proto.TypeNamingIndexes type_naming_indexes */ 2:
                    message.typeNamingIndexes = TypeNamingIndexes.internalBinaryRead(reader, reader.uint32(), options, message.typeNamingIndexes);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NamedType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 type_id = 1; */
        if (message.typeId !== 0)
            writer.tag(1, WireType.Varint).int32(message.typeId);
        /* eve_trading_co_proto.TypeNamingIndexes type_naming_indexes = 2; */
        if (message.typeNamingIndexes)
            TypeNamingIndexes.internalBinaryWrite(message.typeNamingIndexes, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.NamedType
 */
export const NamedType = new NamedType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BasicItem$Type extends MessageType<BasicItem> {
    constructor() {
        super("eve_trading_co_proto.BasicItem", [
            { no: 1, name: "type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<BasicItem>): BasicItem {
        const message = { typeId: 0, quantity: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BasicItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BasicItem): BasicItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 type_id */ 1:
                    message.typeId = reader.int32();
                    break;
                case /* int64 quantity */ 2:
                    message.quantity = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BasicItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 type_id = 1; */
        if (message.typeId !== 0)
            writer.tag(1, WireType.Varint).int32(message.typeId);
        /* int64 quantity = 2; */
        if (message.quantity !== 0)
            writer.tag(2, WireType.Varint).int64(message.quantity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.BasicItem
 */
export const BasicItem = new BasicItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NamedBasicItem$Type extends MessageType<NamedBasicItem> {
    constructor() {
        super("eve_trading_co_proto.NamedBasicItem", [
            { no: 1, name: "type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<NamedBasicItem>): NamedBasicItem {
        const message = { typeId: 0, quantity: 0, name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NamedBasicItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NamedBasicItem): NamedBasicItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 type_id */ 1:
                    message.typeId = reader.int32();
                    break;
                case /* int64 quantity */ 2:
                    message.quantity = reader.int64().toNumber();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NamedBasicItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 type_id = 1; */
        if (message.typeId !== 0)
            writer.tag(1, WireType.Varint).int32(message.typeId);
        /* int64 quantity = 2; */
        if (message.quantity !== 0)
            writer.tag(2, WireType.Varint).int64(message.quantity);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.NamedBasicItem
 */
export const NamedBasicItem = new NamedBasicItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuybackAppraisal$Type extends MessageType<BuybackAppraisal> {
    constructor() {
        super("eve_trading_co_proto.BuybackAppraisal", [
            { no: 1, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BuybackParentItem },
            { no: 2, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "price", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "time", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 5, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "system_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<BuybackAppraisal>): BuybackAppraisal {
        const message = { items: [], code: "", price: 0, time: 0, version: "", systemId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BuybackAppraisal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuybackAppraisal): BuybackAppraisal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_trading_co_proto.BuybackParentItem items */ 1:
                    message.items.push(BuybackParentItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string code */ 2:
                    message.code = reader.string();
                    break;
                case /* double price */ 3:
                    message.price = reader.double();
                    break;
                case /* int64 time */ 4:
                    message.time = reader.int64().toNumber();
                    break;
                case /* string version */ 5:
                    message.version = reader.string();
                    break;
                case /* int32 system_id */ 6:
                    message.systemId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BuybackAppraisal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated eve_trading_co_proto.BuybackParentItem items = 1; */
        for (let i = 0; i < message.items.length; i++)
            BuybackParentItem.internalBinaryWrite(message.items[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string code = 2; */
        if (message.code !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.code);
        /* double price = 3; */
        if (message.price !== 0)
            writer.tag(3, WireType.Bit64).double(message.price);
        /* int64 time = 4; */
        if (message.time !== 0)
            writer.tag(4, WireType.Varint).int64(message.time);
        /* string version = 5; */
        if (message.version !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.version);
        /* int32 system_id = 6; */
        if (message.systemId !== 0)
            writer.tag(6, WireType.Varint).int32(message.systemId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.BuybackAppraisal
 */
export const BuybackAppraisal = new BuybackAppraisal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuybackParentItem$Type extends MessageType<BuybackParentItem> {
    constructor() {
        super("eve_trading_co_proto.BuybackParentItem", [
            { no: 1, name: "type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "price_per_unit", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "children", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BuybackChildItem },
            { no: 6, name: "type_naming_indexes", kind: "message", T: () => TypeNamingIndexes }
        ]);
    }
    create(value?: PartialMessage<BuybackParentItem>): BuybackParentItem {
        const message = { typeId: 0, quantity: 0, pricePerUnit: 0, description: "", children: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BuybackParentItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuybackParentItem): BuybackParentItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 type_id */ 1:
                    message.typeId = reader.int32();
                    break;
                case /* int64 quantity */ 2:
                    message.quantity = reader.int64().toNumber();
                    break;
                case /* double price_per_unit */ 3:
                    message.pricePerUnit = reader.double();
                    break;
                case /* string description */ 4:
                    message.description = reader.string();
                    break;
                case /* repeated eve_trading_co_proto.BuybackChildItem children */ 5:
                    message.children.push(BuybackChildItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* eve_trading_co_proto.TypeNamingIndexes type_naming_indexes */ 6:
                    message.typeNamingIndexes = TypeNamingIndexes.internalBinaryRead(reader, reader.uint32(), options, message.typeNamingIndexes);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BuybackParentItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 type_id = 1; */
        if (message.typeId !== 0)
            writer.tag(1, WireType.Varint).int32(message.typeId);
        /* int64 quantity = 2; */
        if (message.quantity !== 0)
            writer.tag(2, WireType.Varint).int64(message.quantity);
        /* double price_per_unit = 3; */
        if (message.pricePerUnit !== 0)
            writer.tag(3, WireType.Bit64).double(message.pricePerUnit);
        /* string description = 4; */
        if (message.description !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.description);
        /* repeated eve_trading_co_proto.BuybackChildItem children = 5; */
        for (let i = 0; i < message.children.length; i++)
            BuybackChildItem.internalBinaryWrite(message.children[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.TypeNamingIndexes type_naming_indexes = 6; */
        if (message.typeNamingIndexes)
            TypeNamingIndexes.internalBinaryWrite(message.typeNamingIndexes, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.BuybackParentItem
 */
export const BuybackParentItem = new BuybackParentItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuybackChildItem$Type extends MessageType<BuybackChildItem> {
    constructor() {
        super("eve_trading_co_proto.BuybackChildItem", [
            { no: 1, name: "type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "quantity_per_parent", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "price_per_unit", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "type_naming_indexes", kind: "message", T: () => TypeNamingIndexes }
        ]);
    }
    create(value?: PartialMessage<BuybackChildItem>): BuybackChildItem {
        const message = { typeId: 0, quantityPerParent: 0, pricePerUnit: 0, description: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BuybackChildItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuybackChildItem): BuybackChildItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 type_id */ 1:
                    message.typeId = reader.int32();
                    break;
                case /* double quantity_per_parent */ 2:
                    message.quantityPerParent = reader.double();
                    break;
                case /* double price_per_unit */ 3:
                    message.pricePerUnit = reader.double();
                    break;
                case /* string description */ 4:
                    message.description = reader.string();
                    break;
                case /* eve_trading_co_proto.TypeNamingIndexes type_naming_indexes */ 5:
                    message.typeNamingIndexes = TypeNamingIndexes.internalBinaryRead(reader, reader.uint32(), options, message.typeNamingIndexes);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BuybackChildItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 type_id = 1; */
        if (message.typeId !== 0)
            writer.tag(1, WireType.Varint).int32(message.typeId);
        /* double quantity_per_parent = 2; */
        if (message.quantityPerParent !== 0)
            writer.tag(2, WireType.Bit64).double(message.quantityPerParent);
        /* double price_per_unit = 3; */
        if (message.pricePerUnit !== 0)
            writer.tag(3, WireType.Bit64).double(message.pricePerUnit);
        /* string description = 4; */
        if (message.description !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.description);
        /* eve_trading_co_proto.TypeNamingIndexes type_naming_indexes = 5; */
        if (message.typeNamingIndexes)
            TypeNamingIndexes.internalBinaryWrite(message.typeNamingIndexes, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.BuybackChildItem
 */
export const BuybackChildItem = new BuybackChildItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopAppraisal$Type extends MessageType<ShopAppraisal> {
    constructor() {
        super("eve_trading_co_proto.ShopAppraisal", [
            { no: 1, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ShopItem },
            { no: 2, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "price", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "time", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 5, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "location_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<ShopAppraisal>): ShopAppraisal {
        const message = { items: [], code: "", price: 0, time: 0, version: "", locationId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopAppraisal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopAppraisal): ShopAppraisal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_trading_co_proto.ShopItem items */ 1:
                    message.items.push(ShopItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string code */ 2:
                    message.code = reader.string();
                    break;
                case /* double price */ 3:
                    message.price = reader.double();
                    break;
                case /* int64 time */ 4:
                    message.time = reader.int64().toNumber();
                    break;
                case /* string version */ 5:
                    message.version = reader.string();
                    break;
                case /* int64 location_id */ 6:
                    message.locationId = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopAppraisal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated eve_trading_co_proto.ShopItem items = 1; */
        for (let i = 0; i < message.items.length; i++)
            ShopItem.internalBinaryWrite(message.items[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string code = 2; */
        if (message.code !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.code);
        /* double price = 3; */
        if (message.price !== 0)
            writer.tag(3, WireType.Bit64).double(message.price);
        /* int64 time = 4; */
        if (message.time !== 0)
            writer.tag(4, WireType.Varint).int64(message.time);
        /* string version = 5; */
        if (message.version !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.version);
        /* int64 location_id = 6; */
        if (message.locationId !== 0)
            writer.tag(6, WireType.Varint).int64(message.locationId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.ShopAppraisal
 */
export const ShopAppraisal = new ShopAppraisal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopItem$Type extends MessageType<ShopItem> {
    constructor() {
        super("eve_trading_co_proto.ShopItem", [
            { no: 1, name: "type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "price_per_unit", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "type_naming_indexes", kind: "message", T: () => TypeNamingIndexes }
        ]);
    }
    create(value?: PartialMessage<ShopItem>): ShopItem {
        const message = { typeId: 0, quantity: 0, pricePerUnit: 0, description: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopItem): ShopItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 type_id */ 1:
                    message.typeId = reader.int32();
                    break;
                case /* int64 quantity */ 2:
                    message.quantity = reader.int64().toNumber();
                    break;
                case /* double price_per_unit */ 3:
                    message.pricePerUnit = reader.double();
                    break;
                case /* string description */ 4:
                    message.description = reader.string();
                    break;
                case /* eve_trading_co_proto.TypeNamingIndexes type_naming_indexes */ 5:
                    message.typeNamingIndexes = TypeNamingIndexes.internalBinaryRead(reader, reader.uint32(), options, message.typeNamingIndexes);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 type_id = 1; */
        if (message.typeId !== 0)
            writer.tag(1, WireType.Varint).int32(message.typeId);
        /* int64 quantity = 2; */
        if (message.quantity !== 0)
            writer.tag(2, WireType.Varint).int64(message.quantity);
        /* double price_per_unit = 3; */
        if (message.pricePerUnit !== 0)
            writer.tag(3, WireType.Bit64).double(message.pricePerUnit);
        /* string description = 4; */
        if (message.description !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.description);
        /* eve_trading_co_proto.TypeNamingIndexes type_naming_indexes = 5; */
        if (message.typeNamingIndexes)
            TypeNamingIndexes.internalBinaryWrite(message.typeNamingIndexes, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.ShopItem
 */
export const ShopItem = new ShopItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ContractItem$Type extends MessageType<ContractItem> {
    constructor() {
        super("eve_trading_co_proto.ContractItem", [
            { no: 1, name: "type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "type_naming_indexes", kind: "message", T: () => TypeNamingIndexes }
        ]);
    }
    create(value?: PartialMessage<ContractItem>): ContractItem {
        const message = { typeId: 0, quantity: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ContractItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ContractItem): ContractItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 type_id */ 1:
                    message.typeId = reader.int32();
                    break;
                case /* int64 quantity */ 2:
                    message.quantity = reader.int64().toNumber();
                    break;
                case /* eve_trading_co_proto.TypeNamingIndexes type_naming_indexes */ 3:
                    message.typeNamingIndexes = TypeNamingIndexes.internalBinaryRead(reader, reader.uint32(), options, message.typeNamingIndexes);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ContractItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 type_id = 1; */
        if (message.typeId !== 0)
            writer.tag(1, WireType.Varint).int32(message.typeId);
        /* int64 quantity = 2; */
        if (message.quantity !== 0)
            writer.tag(2, WireType.Varint).int64(message.quantity);
        /* eve_trading_co_proto.TypeNamingIndexes type_naming_indexes = 3; */
        if (message.typeNamingIndexes)
            TypeNamingIndexes.internalBinaryWrite(message.typeNamingIndexes, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.ContractItem
 */
export const ContractItem = new ContractItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Contract$Type extends MessageType<Contract> {
    constructor() {
        super("eve_trading_co_proto.Contract", [
            { no: 1, name: "contract_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "status", kind: "enum", T: () => ["eve_trading_co_proto.ContractStatus", ContractStatus] },
            { no: 3, name: "issued", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "expires", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 5, name: "location_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 6, name: "price", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "has_reward", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "issuer_corp_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "issuer_char_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "assignee_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "assignee_type", kind: "enum", T: () => ["eve_trading_co_proto.ContractAssigneeType", ContractAssigneeType] }
        ]);
    }
    create(value?: PartialMessage<Contract>): Contract {
        const message = { contractId: 0, status: 0, issued: 0, expires: 0, locationId: 0, price: 0, hasReward: false, issuerCorpId: 0, issuerCharId: 0, assigneeId: 0, assigneeType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Contract>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Contract): Contract {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 contract_id */ 1:
                    message.contractId = reader.int32();
                    break;
                case /* eve_trading_co_proto.ContractStatus status */ 2:
                    message.status = reader.int32();
                    break;
                case /* int64 issued */ 3:
                    message.issued = reader.int64().toNumber();
                    break;
                case /* int64 expires */ 4:
                    message.expires = reader.int64().toNumber();
                    break;
                case /* int64 location_id */ 5:
                    message.locationId = reader.int64().toNumber();
                    break;
                case /* double price */ 6:
                    message.price = reader.double();
                    break;
                case /* bool has_reward */ 7:
                    message.hasReward = reader.bool();
                    break;
                case /* int32 issuer_corp_id */ 8:
                    message.issuerCorpId = reader.int32();
                    break;
                case /* int32 issuer_char_id */ 9:
                    message.issuerCharId = reader.int32();
                    break;
                case /* int32 assignee_id */ 10:
                    message.assigneeId = reader.int32();
                    break;
                case /* eve_trading_co_proto.ContractAssigneeType assignee_type */ 11:
                    message.assigneeType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Contract, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 contract_id = 1; */
        if (message.contractId !== 0)
            writer.tag(1, WireType.Varint).int32(message.contractId);
        /* eve_trading_co_proto.ContractStatus status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).int32(message.status);
        /* int64 issued = 3; */
        if (message.issued !== 0)
            writer.tag(3, WireType.Varint).int64(message.issued);
        /* int64 expires = 4; */
        if (message.expires !== 0)
            writer.tag(4, WireType.Varint).int64(message.expires);
        /* int64 location_id = 5; */
        if (message.locationId !== 0)
            writer.tag(5, WireType.Varint).int64(message.locationId);
        /* double price = 6; */
        if (message.price !== 0)
            writer.tag(6, WireType.Bit64).double(message.price);
        /* bool has_reward = 7; */
        if (message.hasReward !== false)
            writer.tag(7, WireType.Varint).bool(message.hasReward);
        /* int32 issuer_corp_id = 8; */
        if (message.issuerCorpId !== 0)
            writer.tag(8, WireType.Varint).int32(message.issuerCorpId);
        /* int32 issuer_char_id = 9; */
        if (message.issuerCharId !== 0)
            writer.tag(9, WireType.Varint).int32(message.issuerCharId);
        /* int32 assignee_id = 10; */
        if (message.assigneeId !== 0)
            writer.tag(10, WireType.Varint).int32(message.assigneeId);
        /* eve_trading_co_proto.ContractAssigneeType assignee_type = 11; */
        if (message.assigneeType !== 0)
            writer.tag(11, WireType.Varint).int32(message.assigneeType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.Contract
 */
export const Contract = new Contract$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuybackContractQueueEntry$Type extends MessageType<BuybackContractQueueEntry> {
    constructor() {
        super("eve_trading_co_proto.BuybackContractQueueEntry", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "contract", kind: "message", T: () => Contract },
            { no: 3, name: "contract_items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ContractItem },
            { no: 4, name: "contract_location_info", kind: "message", T: () => LocationInfo },
            { no: 5, name: "code_appraisal", kind: "message", T: () => BuybackAppraisal },
            { no: 6, name: "appraisal_character_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "new_appraisal", kind: "message", T: () => BuybackAppraisal }
        ]);
    }
    create(value?: PartialMessage<BuybackContractQueueEntry>): BuybackContractQueueEntry {
        const message = { code: "", contractItems: [], appraisalCharacterId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BuybackContractQueueEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuybackContractQueueEntry): BuybackContractQueueEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* eve_trading_co_proto.Contract contract */ 2:
                    message.contract = Contract.internalBinaryRead(reader, reader.uint32(), options, message.contract);
                    break;
                case /* repeated eve_trading_co_proto.ContractItem contract_items */ 3:
                    message.contractItems.push(ContractItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* eve_trading_co_proto.LocationInfo contract_location_info */ 4:
                    message.contractLocationInfo = LocationInfo.internalBinaryRead(reader, reader.uint32(), options, message.contractLocationInfo);
                    break;
                case /* eve_trading_co_proto.BuybackAppraisal code_appraisal */ 5:
                    message.codeAppraisal = BuybackAppraisal.internalBinaryRead(reader, reader.uint32(), options, message.codeAppraisal);
                    break;
                case /* int32 appraisal_character_id */ 6:
                    message.appraisalCharacterId = reader.int32();
                    break;
                case /* eve_trading_co_proto.BuybackAppraisal new_appraisal */ 7:
                    message.newAppraisal = BuybackAppraisal.internalBinaryRead(reader, reader.uint32(), options, message.newAppraisal);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BuybackContractQueueEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* eve_trading_co_proto.Contract contract = 2; */
        if (message.contract)
            Contract.internalBinaryWrite(message.contract, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated eve_trading_co_proto.ContractItem contract_items = 3; */
        for (let i = 0; i < message.contractItems.length; i++)
            ContractItem.internalBinaryWrite(message.contractItems[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.LocationInfo contract_location_info = 4; */
        if (message.contractLocationInfo)
            LocationInfo.internalBinaryWrite(message.contractLocationInfo, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.BuybackAppraisal code_appraisal = 5; */
        if (message.codeAppraisal)
            BuybackAppraisal.internalBinaryWrite(message.codeAppraisal, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* int32 appraisal_character_id = 6; */
        if (message.appraisalCharacterId !== 0)
            writer.tag(6, WireType.Varint).int32(message.appraisalCharacterId);
        /* eve_trading_co_proto.BuybackAppraisal new_appraisal = 7; */
        if (message.newAppraisal)
            BuybackAppraisal.internalBinaryWrite(message.newAppraisal, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.BuybackContractQueueEntry
 */
export const BuybackContractQueueEntry = new BuybackContractQueueEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopContractQueueEntry$Type extends MessageType<ShopContractQueueEntry> {
    constructor() {
        super("eve_trading_co_proto.ShopContractQueueEntry", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "contract", kind: "message", T: () => Contract },
            { no: 3, name: "contract_items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ContractItem },
            { no: 4, name: "contract_location_info", kind: "message", T: () => LocationInfo },
            { no: 5, name: "code_appraisal", kind: "message", T: () => ShopAppraisal },
            { no: 6, name: "appraisal_character_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "new_appraisal", kind: "message", T: () => ShopAppraisal }
        ]);
    }
    create(value?: PartialMessage<ShopContractQueueEntry>): ShopContractQueueEntry {
        const message = { code: "", contractItems: [], appraisalCharacterId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopContractQueueEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopContractQueueEntry): ShopContractQueueEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* eve_trading_co_proto.Contract contract */ 2:
                    message.contract = Contract.internalBinaryRead(reader, reader.uint32(), options, message.contract);
                    break;
                case /* repeated eve_trading_co_proto.ContractItem contract_items */ 3:
                    message.contractItems.push(ContractItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* eve_trading_co_proto.LocationInfo contract_location_info */ 4:
                    message.contractLocationInfo = LocationInfo.internalBinaryRead(reader, reader.uint32(), options, message.contractLocationInfo);
                    break;
                case /* eve_trading_co_proto.ShopAppraisal code_appraisal */ 5:
                    message.codeAppraisal = ShopAppraisal.internalBinaryRead(reader, reader.uint32(), options, message.codeAppraisal);
                    break;
                case /* int32 appraisal_character_id */ 6:
                    message.appraisalCharacterId = reader.int32();
                    break;
                case /* eve_trading_co_proto.ShopAppraisal new_appraisal */ 7:
                    message.newAppraisal = ShopAppraisal.internalBinaryRead(reader, reader.uint32(), options, message.newAppraisal);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopContractQueueEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* eve_trading_co_proto.Contract contract = 2; */
        if (message.contract)
            Contract.internalBinaryWrite(message.contract, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated eve_trading_co_proto.ContractItem contract_items = 3; */
        for (let i = 0; i < message.contractItems.length; i++)
            ContractItem.internalBinaryWrite(message.contractItems[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.LocationInfo contract_location_info = 4; */
        if (message.contractLocationInfo)
            LocationInfo.internalBinaryWrite(message.contractLocationInfo, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ShopAppraisal code_appraisal = 5; */
        if (message.codeAppraisal)
            ShopAppraisal.internalBinaryWrite(message.codeAppraisal, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* int32 appraisal_character_id = 6; */
        if (message.appraisalCharacterId !== 0)
            writer.tag(6, WireType.Varint).int32(message.appraisalCharacterId);
        /* eve_trading_co_proto.ShopAppraisal new_appraisal = 7; */
        if (message.newAppraisal)
            ShopAppraisal.internalBinaryWrite(message.newAppraisal, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.ShopContractQueueEntry
 */
export const ShopContractQueueEntry = new ShopContractQueueEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PurchaseQueueEntry$Type extends MessageType<PurchaseQueueEntry> {
    constructor() {
        super("eve_trading_co_proto.PurchaseQueueEntry", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code_appraisal", kind: "message", T: () => ShopAppraisal },
            { no: 3, name: "appraisal_character_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "new_appraisal", kind: "message", T: () => ShopAppraisal }
        ]);
    }
    create(value?: PartialMessage<PurchaseQueueEntry>): PurchaseQueueEntry {
        const message = { code: "", appraisalCharacterId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PurchaseQueueEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PurchaseQueueEntry): PurchaseQueueEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* eve_trading_co_proto.ShopAppraisal code_appraisal */ 2:
                    message.codeAppraisal = ShopAppraisal.internalBinaryRead(reader, reader.uint32(), options, message.codeAppraisal);
                    break;
                case /* int32 appraisal_character_id */ 3:
                    message.appraisalCharacterId = reader.int32();
                    break;
                case /* eve_trading_co_proto.ShopAppraisal new_appraisal */ 4:
                    message.newAppraisal = ShopAppraisal.internalBinaryRead(reader, reader.uint32(), options, message.newAppraisal);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PurchaseQueueEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* eve_trading_co_proto.ShopAppraisal code_appraisal = 2; */
        if (message.codeAppraisal)
            ShopAppraisal.internalBinaryWrite(message.codeAppraisal, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int32 appraisal_character_id = 3; */
        if (message.appraisalCharacterId !== 0)
            writer.tag(3, WireType.Varint).int32(message.appraisalCharacterId);
        /* eve_trading_co_proto.ShopAppraisal new_appraisal = 4; */
        if (message.newAppraisal)
            ShopAppraisal.internalBinaryWrite(message.newAppraisal, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.PurchaseQueueEntry
 */
export const PurchaseQueueEntry = new PurchaseQueueEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuybackAppraisalStatus$Type extends MessageType<BuybackAppraisalStatus> {
    constructor() {
        super("eve_trading_co_proto.BuybackAppraisalStatus", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "contract", kind: "message", T: () => Contract }
        ]);
    }
    create(value?: PartialMessage<BuybackAppraisalStatus>): BuybackAppraisalStatus {
        const message = { code: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BuybackAppraisalStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuybackAppraisalStatus): BuybackAppraisalStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* eve_trading_co_proto.Contract contract */ 2:
                    message.contract = Contract.internalBinaryRead(reader, reader.uint32(), options, message.contract);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BuybackAppraisalStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* eve_trading_co_proto.Contract contract = 2; */
        if (message.contract)
            Contract.internalBinaryWrite(message.contract, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.BuybackAppraisalStatus
 */
export const BuybackAppraisalStatus = new BuybackAppraisalStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopAppraisalStatus$Type extends MessageType<ShopAppraisalStatus> {
    constructor() {
        super("eve_trading_co_proto.ShopAppraisalStatus", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "contract", kind: "message", T: () => Contract },
            { no: 3, name: "in_purchase_queue", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ShopAppraisalStatus>): ShopAppraisalStatus {
        const message = { code: "", inPurchaseQueue: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopAppraisalStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopAppraisalStatus): ShopAppraisalStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* eve_trading_co_proto.Contract contract */ 2:
                    message.contract = Contract.internalBinaryRead(reader, reader.uint32(), options, message.contract);
                    break;
                case /* bool in_purchase_queue */ 3:
                    message.inPurchaseQueue = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopAppraisalStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* eve_trading_co_proto.Contract contract = 2; */
        if (message.contract)
            Contract.internalBinaryWrite(message.contract, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool in_purchase_queue = 3; */
        if (message.inPurchaseQueue !== false)
            writer.tag(3, WireType.Varint).bool(message.inPurchaseQueue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.ShopAppraisalStatus
 */
export const ShopAppraisalStatus = new ShopAppraisalStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgGetAuthListRequest$Type extends MessageType<CfgGetAuthListRequest> {
    constructor() {
        super("eve_trading_co_proto.CfgGetAuthListRequest", [
            { no: 1, name: "domain_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "auth", kind: "message", T: () => AuthRequest }
        ]);
    }
    create(value?: PartialMessage<CfgGetAuthListRequest>): CfgGetAuthListRequest {
        const message = { domainKey: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgGetAuthListRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgGetAuthListRequest): CfgGetAuthListRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain_key */ 1:
                    message.domainKey = reader.string();
                    break;
                case /* eve_trading_co_proto.AuthRequest auth */ 2:
                    message.auth = AuthRequest.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgGetAuthListRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain_key = 1; */
        if (message.domainKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domainKey);
        /* eve_trading_co_proto.AuthRequest auth = 2; */
        if (message.auth)
            AuthRequest.internalBinaryWrite(message.auth, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgGetAuthListRequest
 */
export const CfgGetAuthListRequest = new CfgGetAuthListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgGetAuthListResponse$Type extends MessageType<CfgGetAuthListResponse> {
    constructor() {
        super("eve_trading_co_proto.CfgGetAuthListResponse", [
            { no: 1, name: "auth_list", kind: "message", T: () => AuthList },
            { no: 2, name: "auth", kind: "message", T: () => AuthResponse },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<CfgGetAuthListResponse>): CfgGetAuthListResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgGetAuthListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgGetAuthListResponse): CfgGetAuthListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eve_trading_co_proto.AuthList auth_list */ 1:
                    message.authList = AuthList.internalBinaryRead(reader, reader.uint32(), options, message.authList);
                    break;
                case /* eve_trading_co_proto.AuthResponse auth */ 2:
                    message.auth = AuthResponse.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgGetAuthListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eve_trading_co_proto.AuthList auth_list = 1; */
        if (message.authList)
            AuthList.internalBinaryWrite(message.authList, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.AuthResponse auth = 2; */
        if (message.auth)
            AuthResponse.internalBinaryWrite(message.auth, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgGetAuthListResponse
 */
export const CfgGetAuthListResponse = new CfgGetAuthListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgSetAuthListRequest$Type extends MessageType<CfgSetAuthListRequest> {
    constructor() {
        super("eve_trading_co_proto.CfgSetAuthListRequest", [
            { no: 1, name: "domain_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "auth_list", kind: "message", T: () => AuthList },
            { no: 3, name: "auth", kind: "message", T: () => AuthRequest }
        ]);
    }
    create(value?: PartialMessage<CfgSetAuthListRequest>): CfgSetAuthListRequest {
        const message = { domainKey: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgSetAuthListRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgSetAuthListRequest): CfgSetAuthListRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain_key */ 1:
                    message.domainKey = reader.string();
                    break;
                case /* eve_trading_co_proto.AuthList auth_list */ 2:
                    message.authList = AuthList.internalBinaryRead(reader, reader.uint32(), options, message.authList);
                    break;
                case /* eve_trading_co_proto.AuthRequest auth */ 3:
                    message.auth = AuthRequest.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgSetAuthListRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain_key = 1; */
        if (message.domainKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domainKey);
        /* eve_trading_co_proto.AuthList auth_list = 2; */
        if (message.authList)
            AuthList.internalBinaryWrite(message.authList, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.AuthRequest auth = 3; */
        if (message.auth)
            AuthRequest.internalBinaryWrite(message.auth, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgSetAuthListRequest
 */
export const CfgSetAuthListRequest = new CfgSetAuthListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgSetAuthListResponse$Type extends MessageType<CfgSetAuthListResponse> {
    constructor() {
        super("eve_trading_co_proto.CfgSetAuthListResponse", [
            { no: 1, name: "auth", kind: "message", T: () => AuthResponse },
            { no: 2, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<CfgSetAuthListResponse>): CfgSetAuthListResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgSetAuthListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgSetAuthListResponse): CfgSetAuthListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eve_trading_co_proto.AuthResponse auth */ 1:
                    message.auth = AuthResponse.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 2:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgSetAuthListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eve_trading_co_proto.AuthResponse auth = 1; */
        if (message.auth)
            AuthResponse.internalBinaryWrite(message.auth, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 2; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgSetAuthListResponse
 */
export const CfgSetAuthListResponse = new CfgSetAuthListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgGetBuybackSystemTypeMapsBuilderRequest$Type extends MessageType<CfgGetBuybackSystemTypeMapsBuilderRequest> {
    constructor() {
        super("eve_trading_co_proto.CfgGetBuybackSystemTypeMapsBuilderRequest", [
            { no: 1, name: "auth", kind: "message", T: () => AuthRequest }
        ]);
    }
    create(value?: PartialMessage<CfgGetBuybackSystemTypeMapsBuilderRequest>): CfgGetBuybackSystemTypeMapsBuilderRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgGetBuybackSystemTypeMapsBuilderRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgGetBuybackSystemTypeMapsBuilderRequest): CfgGetBuybackSystemTypeMapsBuilderRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eve_trading_co_proto.AuthRequest auth */ 1:
                    message.auth = AuthRequest.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgGetBuybackSystemTypeMapsBuilderRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eve_trading_co_proto.AuthRequest auth = 1; */
        if (message.auth)
            AuthRequest.internalBinaryWrite(message.auth, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgGetBuybackSystemTypeMapsBuilderRequest
 */
export const CfgGetBuybackSystemTypeMapsBuilderRequest = new CfgGetBuybackSystemTypeMapsBuilderRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgGetBuybackSystemTypeMapsBuilderResponse$Type extends MessageType<CfgGetBuybackSystemTypeMapsBuilderResponse> {
    constructor() {
        super("eve_trading_co_proto.CfgGetBuybackSystemTypeMapsBuilderResponse", [
            { no: 1, name: "builder", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "message", T: () => CfgBuybackSystemTypeBundle } },
            { no: 2, name: "auth", kind: "message", T: () => AuthResponse },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<CfgGetBuybackSystemTypeMapsBuilderResponse>): CfgGetBuybackSystemTypeMapsBuilderResponse {
        const message = { builder: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgGetBuybackSystemTypeMapsBuilderResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgGetBuybackSystemTypeMapsBuilderResponse): CfgGetBuybackSystemTypeMapsBuilderResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, eve_trading_co_proto.CfgBuybackSystemTypeBundle> builder */ 1:
                    this.binaryReadMap1(message.builder, reader, options);
                    break;
                case /* eve_trading_co_proto.AuthResponse auth */ 2:
                    message.auth = AuthResponse.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CfgGetBuybackSystemTypeMapsBuilderResponse["builder"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CfgGetBuybackSystemTypeMapsBuilderResponse["builder"] | undefined, val: CfgGetBuybackSystemTypeMapsBuilderResponse["builder"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = CfgBuybackSystemTypeBundle.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field eve_trading_co_proto.CfgGetBuybackSystemTypeMapsBuilderResponse.builder");
            }
        }
        map[key ?? 0] = val ?? CfgBuybackSystemTypeBundle.create();
    }
    internalBinaryWrite(message: CfgGetBuybackSystemTypeMapsBuilderResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, eve_trading_co_proto.CfgBuybackSystemTypeBundle> builder = 1; */
        for (let k of Object.keys(message.builder)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            CfgBuybackSystemTypeBundle.internalBinaryWrite(message.builder[k as any], writer, options);
            writer.join().join();
        }
        /* eve_trading_co_proto.AuthResponse auth = 2; */
        if (message.auth)
            AuthResponse.internalBinaryWrite(message.auth, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgGetBuybackSystemTypeMapsBuilderResponse
 */
export const CfgGetBuybackSystemTypeMapsBuilderResponse = new CfgGetBuybackSystemTypeMapsBuilderResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgMergeBuybackSystemTypeMapsBuilderRequest$Type extends MessageType<CfgMergeBuybackSystemTypeMapsBuilderRequest> {
    constructor() {
        super("eve_trading_co_proto.CfgMergeBuybackSystemTypeMapsBuilderRequest", [
            { no: 1, name: "builder", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "message", T: () => CfgBuybackSystemTypeBundle } },
            { no: 2, name: "auth", kind: "message", T: () => AuthRequest }
        ]);
    }
    create(value?: PartialMessage<CfgMergeBuybackSystemTypeMapsBuilderRequest>): CfgMergeBuybackSystemTypeMapsBuilderRequest {
        const message = { builder: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgMergeBuybackSystemTypeMapsBuilderRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgMergeBuybackSystemTypeMapsBuilderRequest): CfgMergeBuybackSystemTypeMapsBuilderRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, eve_trading_co_proto.CfgBuybackSystemTypeBundle> builder */ 1:
                    this.binaryReadMap1(message.builder, reader, options);
                    break;
                case /* eve_trading_co_proto.AuthRequest auth */ 2:
                    message.auth = AuthRequest.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CfgMergeBuybackSystemTypeMapsBuilderRequest["builder"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CfgMergeBuybackSystemTypeMapsBuilderRequest["builder"] | undefined, val: CfgMergeBuybackSystemTypeMapsBuilderRequest["builder"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = CfgBuybackSystemTypeBundle.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field eve_trading_co_proto.CfgMergeBuybackSystemTypeMapsBuilderRequest.builder");
            }
        }
        map[key ?? 0] = val ?? CfgBuybackSystemTypeBundle.create();
    }
    internalBinaryWrite(message: CfgMergeBuybackSystemTypeMapsBuilderRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, eve_trading_co_proto.CfgBuybackSystemTypeBundle> builder = 1; */
        for (let k of Object.keys(message.builder)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            CfgBuybackSystemTypeBundle.internalBinaryWrite(message.builder[k as any], writer, options);
            writer.join().join();
        }
        /* eve_trading_co_proto.AuthRequest auth = 2; */
        if (message.auth)
            AuthRequest.internalBinaryWrite(message.auth, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgMergeBuybackSystemTypeMapsBuilderRequest
 */
export const CfgMergeBuybackSystemTypeMapsBuilderRequest = new CfgMergeBuybackSystemTypeMapsBuilderRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgMergeBuybackSystemTypeMapsBuilderResponse$Type extends MessageType<CfgMergeBuybackSystemTypeMapsBuilderResponse> {
    constructor() {
        super("eve_trading_co_proto.CfgMergeBuybackSystemTypeMapsBuilderResponse", [
            { no: 1, name: "Modified", kind: "scalar", jsonName: "Modified", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "auth", kind: "message", T: () => AuthResponse },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<CfgMergeBuybackSystemTypeMapsBuilderResponse>): CfgMergeBuybackSystemTypeMapsBuilderResponse {
        const message = { modified: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgMergeBuybackSystemTypeMapsBuilderResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgMergeBuybackSystemTypeMapsBuilderResponse): CfgMergeBuybackSystemTypeMapsBuilderResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool Modified = 1 [json_name = "Modified"];*/ 1:
                    message.modified = reader.bool();
                    break;
                case /* eve_trading_co_proto.AuthResponse auth */ 2:
                    message.auth = AuthResponse.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgMergeBuybackSystemTypeMapsBuilderResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool Modified = 1 [json_name = "Modified"]; */
        if (message.modified !== false)
            writer.tag(1, WireType.Varint).bool(message.modified);
        /* eve_trading_co_proto.AuthResponse auth = 2; */
        if (message.auth)
            AuthResponse.internalBinaryWrite(message.auth, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgMergeBuybackSystemTypeMapsBuilderResponse
 */
export const CfgMergeBuybackSystemTypeMapsBuilderResponse = new CfgMergeBuybackSystemTypeMapsBuilderResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgGetShopLocationTypeMapsBuilderRequest$Type extends MessageType<CfgGetShopLocationTypeMapsBuilderRequest> {
    constructor() {
        super("eve_trading_co_proto.CfgGetShopLocationTypeMapsBuilderRequest", [
            { no: 1, name: "auth", kind: "message", T: () => AuthRequest }
        ]);
    }
    create(value?: PartialMessage<CfgGetShopLocationTypeMapsBuilderRequest>): CfgGetShopLocationTypeMapsBuilderRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgGetShopLocationTypeMapsBuilderRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgGetShopLocationTypeMapsBuilderRequest): CfgGetShopLocationTypeMapsBuilderRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eve_trading_co_proto.AuthRequest auth */ 1:
                    message.auth = AuthRequest.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgGetShopLocationTypeMapsBuilderRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eve_trading_co_proto.AuthRequest auth = 1; */
        if (message.auth)
            AuthRequest.internalBinaryWrite(message.auth, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgGetShopLocationTypeMapsBuilderRequest
 */
export const CfgGetShopLocationTypeMapsBuilderRequest = new CfgGetShopLocationTypeMapsBuilderRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgGetShopLocationTypeMapsBuilderResponse$Type extends MessageType<CfgGetShopLocationTypeMapsBuilderResponse> {
    constructor() {
        super("eve_trading_co_proto.CfgGetShopLocationTypeMapsBuilderResponse", [
            { no: 1, name: "builder", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "message", T: () => CfgShopLocationTypeBundle } },
            { no: 2, name: "auth", kind: "message", T: () => AuthResponse },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<CfgGetShopLocationTypeMapsBuilderResponse>): CfgGetShopLocationTypeMapsBuilderResponse {
        const message = { builder: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgGetShopLocationTypeMapsBuilderResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgGetShopLocationTypeMapsBuilderResponse): CfgGetShopLocationTypeMapsBuilderResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, eve_trading_co_proto.CfgShopLocationTypeBundle> builder */ 1:
                    this.binaryReadMap1(message.builder, reader, options);
                    break;
                case /* eve_trading_co_proto.AuthResponse auth */ 2:
                    message.auth = AuthResponse.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CfgGetShopLocationTypeMapsBuilderResponse["builder"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CfgGetShopLocationTypeMapsBuilderResponse["builder"] | undefined, val: CfgGetShopLocationTypeMapsBuilderResponse["builder"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = CfgShopLocationTypeBundle.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field eve_trading_co_proto.CfgGetShopLocationTypeMapsBuilderResponse.builder");
            }
        }
        map[key ?? 0] = val ?? CfgShopLocationTypeBundle.create();
    }
    internalBinaryWrite(message: CfgGetShopLocationTypeMapsBuilderResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, eve_trading_co_proto.CfgShopLocationTypeBundle> builder = 1; */
        for (let k of Object.keys(message.builder)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            CfgShopLocationTypeBundle.internalBinaryWrite(message.builder[k as any], writer, options);
            writer.join().join();
        }
        /* eve_trading_co_proto.AuthResponse auth = 2; */
        if (message.auth)
            AuthResponse.internalBinaryWrite(message.auth, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgGetShopLocationTypeMapsBuilderResponse
 */
export const CfgGetShopLocationTypeMapsBuilderResponse = new CfgGetShopLocationTypeMapsBuilderResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgMergeShopLocationTypeMapsBuilderRequest$Type extends MessageType<CfgMergeShopLocationTypeMapsBuilderRequest> {
    constructor() {
        super("eve_trading_co_proto.CfgMergeShopLocationTypeMapsBuilderRequest", [
            { no: 1, name: "builder", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "message", T: () => CfgShopLocationTypeBundle } },
            { no: 2, name: "auth", kind: "message", T: () => AuthRequest }
        ]);
    }
    create(value?: PartialMessage<CfgMergeShopLocationTypeMapsBuilderRequest>): CfgMergeShopLocationTypeMapsBuilderRequest {
        const message = { builder: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgMergeShopLocationTypeMapsBuilderRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgMergeShopLocationTypeMapsBuilderRequest): CfgMergeShopLocationTypeMapsBuilderRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, eve_trading_co_proto.CfgShopLocationTypeBundle> builder */ 1:
                    this.binaryReadMap1(message.builder, reader, options);
                    break;
                case /* eve_trading_co_proto.AuthRequest auth */ 2:
                    message.auth = AuthRequest.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CfgMergeShopLocationTypeMapsBuilderRequest["builder"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CfgMergeShopLocationTypeMapsBuilderRequest["builder"] | undefined, val: CfgMergeShopLocationTypeMapsBuilderRequest["builder"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = CfgShopLocationTypeBundle.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field eve_trading_co_proto.CfgMergeShopLocationTypeMapsBuilderRequest.builder");
            }
        }
        map[key ?? 0] = val ?? CfgShopLocationTypeBundle.create();
    }
    internalBinaryWrite(message: CfgMergeShopLocationTypeMapsBuilderRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, eve_trading_co_proto.CfgShopLocationTypeBundle> builder = 1; */
        for (let k of Object.keys(message.builder)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            CfgShopLocationTypeBundle.internalBinaryWrite(message.builder[k as any], writer, options);
            writer.join().join();
        }
        /* eve_trading_co_proto.AuthRequest auth = 2; */
        if (message.auth)
            AuthRequest.internalBinaryWrite(message.auth, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgMergeShopLocationTypeMapsBuilderRequest
 */
export const CfgMergeShopLocationTypeMapsBuilderRequest = new CfgMergeShopLocationTypeMapsBuilderRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgMergeShopLocationTypeMapsBuilderResponse$Type extends MessageType<CfgMergeShopLocationTypeMapsBuilderResponse> {
    constructor() {
        super("eve_trading_co_proto.CfgMergeShopLocationTypeMapsBuilderResponse", [
            { no: 1, name: "Modified", kind: "scalar", jsonName: "Modified", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "auth", kind: "message", T: () => AuthResponse },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<CfgMergeShopLocationTypeMapsBuilderResponse>): CfgMergeShopLocationTypeMapsBuilderResponse {
        const message = { modified: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgMergeShopLocationTypeMapsBuilderResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgMergeShopLocationTypeMapsBuilderResponse): CfgMergeShopLocationTypeMapsBuilderResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool Modified = 1 [json_name = "Modified"];*/ 1:
                    message.modified = reader.bool();
                    break;
                case /* eve_trading_co_proto.AuthResponse auth */ 2:
                    message.auth = AuthResponse.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgMergeShopLocationTypeMapsBuilderResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool Modified = 1 [json_name = "Modified"]; */
        if (message.modified !== false)
            writer.tag(1, WireType.Varint).bool(message.modified);
        /* eve_trading_co_proto.AuthResponse auth = 2; */
        if (message.auth)
            AuthResponse.internalBinaryWrite(message.auth, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgMergeShopLocationTypeMapsBuilderResponse
 */
export const CfgMergeShopLocationTypeMapsBuilderResponse = new CfgMergeShopLocationTypeMapsBuilderResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgGetBuybackSystemsRequest$Type extends MessageType<CfgGetBuybackSystemsRequest> {
    constructor() {
        super("eve_trading_co_proto.CfgGetBuybackSystemsRequest", [
            { no: 1, name: "include_location_info", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "include_location_naming", kind: "message", T: () => IncludeLocationNaming },
            { no: 3, name: "auth", kind: "message", T: () => AuthRequest }
        ]);
    }
    create(value?: PartialMessage<CfgGetBuybackSystemsRequest>): CfgGetBuybackSystemsRequest {
        const message = { includeLocationInfo: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgGetBuybackSystemsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgGetBuybackSystemsRequest): CfgGetBuybackSystemsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool include_location_info */ 1:
                    message.includeLocationInfo = reader.bool();
                    break;
                case /* eve_trading_co_proto.IncludeLocationNaming include_location_naming */ 2:
                    message.includeLocationNaming = IncludeLocationNaming.internalBinaryRead(reader, reader.uint32(), options, message.includeLocationNaming);
                    break;
                case /* eve_trading_co_proto.AuthRequest auth */ 3:
                    message.auth = AuthRequest.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgGetBuybackSystemsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool include_location_info = 1; */
        if (message.includeLocationInfo !== false)
            writer.tag(1, WireType.Varint).bool(message.includeLocationInfo);
        /* eve_trading_co_proto.IncludeLocationNaming include_location_naming = 2; */
        if (message.includeLocationNaming)
            IncludeLocationNaming.internalBinaryWrite(message.includeLocationNaming, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.AuthRequest auth = 3; */
        if (message.auth)
            AuthRequest.internalBinaryWrite(message.auth, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgGetBuybackSystemsRequest
 */
export const CfgGetBuybackSystemsRequest = new CfgGetBuybackSystemsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgGetBuybackSystemsResponse$Type extends MessageType<CfgGetBuybackSystemsResponse> {
    constructor() {
        super("eve_trading_co_proto.CfgGetBuybackSystemsResponse", [
            { no: 1, name: "systems", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "message", T: () => CfgBuybackSystem } },
            { no: 2, name: "system_region_map", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } },
            { no: 3, name: "location_naming_maps", kind: "message", T: () => LocationNamingMaps },
            { no: 4, name: "auth", kind: "message", T: () => AuthResponse },
            { no: 5, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<CfgGetBuybackSystemsResponse>): CfgGetBuybackSystemsResponse {
        const message = { systems: {}, systemRegionMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgGetBuybackSystemsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgGetBuybackSystemsResponse): CfgGetBuybackSystemsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, eve_trading_co_proto.CfgBuybackSystem> systems */ 1:
                    this.binaryReadMap1(message.systems, reader, options);
                    break;
                case /* map<int32, int32> system_region_map */ 2:
                    this.binaryReadMap2(message.systemRegionMap, reader, options);
                    break;
                case /* eve_trading_co_proto.LocationNamingMaps location_naming_maps */ 3:
                    message.locationNamingMaps = LocationNamingMaps.internalBinaryRead(reader, reader.uint32(), options, message.locationNamingMaps);
                    break;
                case /* eve_trading_co_proto.AuthResponse auth */ 4:
                    message.auth = AuthResponse.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 5:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CfgGetBuybackSystemsResponse["systems"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CfgGetBuybackSystemsResponse["systems"] | undefined, val: CfgGetBuybackSystemsResponse["systems"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = CfgBuybackSystem.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field eve_trading_co_proto.CfgGetBuybackSystemsResponse.systems");
            }
        }
        map[key ?? 0] = val ?? CfgBuybackSystem.create();
    }
    private binaryReadMap2(map: CfgGetBuybackSystemsResponse["systemRegionMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CfgGetBuybackSystemsResponse["systemRegionMap"] | undefined, val: CfgGetBuybackSystemsResponse["systemRegionMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field eve_trading_co_proto.CfgGetBuybackSystemsResponse.system_region_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: CfgGetBuybackSystemsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, eve_trading_co_proto.CfgBuybackSystem> systems = 1; */
        for (let k of Object.keys(message.systems)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            CfgBuybackSystem.internalBinaryWrite(message.systems[k as any], writer, options);
            writer.join().join();
        }
        /* map<int32, int32> system_region_map = 2; */
        for (let k of Object.keys(message.systemRegionMap))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).int32(message.systemRegionMap[k as any]).join();
        /* eve_trading_co_proto.LocationNamingMaps location_naming_maps = 3; */
        if (message.locationNamingMaps)
            LocationNamingMaps.internalBinaryWrite(message.locationNamingMaps, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.AuthResponse auth = 4; */
        if (message.auth)
            AuthResponse.internalBinaryWrite(message.auth, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 5; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgGetBuybackSystemsResponse
 */
export const CfgGetBuybackSystemsResponse = new CfgGetBuybackSystemsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgMergeBuybackSystemsRequest$Type extends MessageType<CfgMergeBuybackSystemsRequest> {
    constructor() {
        super("eve_trading_co_proto.CfgMergeBuybackSystemsRequest", [
            { no: 1, name: "systems", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "message", T: () => CfgBuybackSystem } },
            { no: 2, name: "auth", kind: "message", T: () => AuthRequest }
        ]);
    }
    create(value?: PartialMessage<CfgMergeBuybackSystemsRequest>): CfgMergeBuybackSystemsRequest {
        const message = { systems: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgMergeBuybackSystemsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgMergeBuybackSystemsRequest): CfgMergeBuybackSystemsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, eve_trading_co_proto.CfgBuybackSystem> systems */ 1:
                    this.binaryReadMap1(message.systems, reader, options);
                    break;
                case /* eve_trading_co_proto.AuthRequest auth */ 2:
                    message.auth = AuthRequest.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CfgMergeBuybackSystemsRequest["systems"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CfgMergeBuybackSystemsRequest["systems"] | undefined, val: CfgMergeBuybackSystemsRequest["systems"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = CfgBuybackSystem.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field eve_trading_co_proto.CfgMergeBuybackSystemsRequest.systems");
            }
        }
        map[key ?? 0] = val ?? CfgBuybackSystem.create();
    }
    internalBinaryWrite(message: CfgMergeBuybackSystemsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, eve_trading_co_proto.CfgBuybackSystem> systems = 1; */
        for (let k of Object.keys(message.systems)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            CfgBuybackSystem.internalBinaryWrite(message.systems[k as any], writer, options);
            writer.join().join();
        }
        /* eve_trading_co_proto.AuthRequest auth = 2; */
        if (message.auth)
            AuthRequest.internalBinaryWrite(message.auth, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgMergeBuybackSystemsRequest
 */
export const CfgMergeBuybackSystemsRequest = new CfgMergeBuybackSystemsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgMergeBuybackSystemsResponse$Type extends MessageType<CfgMergeBuybackSystemsResponse> {
    constructor() {
        super("eve_trading_co_proto.CfgMergeBuybackSystemsResponse", [
            { no: 1, name: "Modified", kind: "scalar", jsonName: "Modified", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "auth", kind: "message", T: () => AuthResponse },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<CfgMergeBuybackSystemsResponse>): CfgMergeBuybackSystemsResponse {
        const message = { modified: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgMergeBuybackSystemsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgMergeBuybackSystemsResponse): CfgMergeBuybackSystemsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool Modified = 1 [json_name = "Modified"];*/ 1:
                    message.modified = reader.bool();
                    break;
                case /* eve_trading_co_proto.AuthResponse auth */ 2:
                    message.auth = AuthResponse.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgMergeBuybackSystemsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool Modified = 1 [json_name = "Modified"]; */
        if (message.modified !== false)
            writer.tag(1, WireType.Varint).bool(message.modified);
        /* eve_trading_co_proto.AuthResponse auth = 2; */
        if (message.auth)
            AuthResponse.internalBinaryWrite(message.auth, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgMergeBuybackSystemsResponse
 */
export const CfgMergeBuybackSystemsResponse = new CfgMergeBuybackSystemsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgGetShopLocationsRequest$Type extends MessageType<CfgGetShopLocationsRequest> {
    constructor() {
        super("eve_trading_co_proto.CfgGetShopLocationsRequest", [
            { no: 1, name: "include_location_info", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "include_location_naming", kind: "message", T: () => IncludeLocationNaming },
            { no: 3, name: "auth", kind: "message", T: () => AuthRequest }
        ]);
    }
    create(value?: PartialMessage<CfgGetShopLocationsRequest>): CfgGetShopLocationsRequest {
        const message = { includeLocationInfo: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgGetShopLocationsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgGetShopLocationsRequest): CfgGetShopLocationsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool include_location_info */ 1:
                    message.includeLocationInfo = reader.bool();
                    break;
                case /* eve_trading_co_proto.IncludeLocationNaming include_location_naming */ 2:
                    message.includeLocationNaming = IncludeLocationNaming.internalBinaryRead(reader, reader.uint32(), options, message.includeLocationNaming);
                    break;
                case /* eve_trading_co_proto.AuthRequest auth */ 3:
                    message.auth = AuthRequest.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgGetShopLocationsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool include_location_info = 1; */
        if (message.includeLocationInfo !== false)
            writer.tag(1, WireType.Varint).bool(message.includeLocationInfo);
        /* eve_trading_co_proto.IncludeLocationNaming include_location_naming = 2; */
        if (message.includeLocationNaming)
            IncludeLocationNaming.internalBinaryWrite(message.includeLocationNaming, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.AuthRequest auth = 3; */
        if (message.auth)
            AuthRequest.internalBinaryWrite(message.auth, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgGetShopLocationsRequest
 */
export const CfgGetShopLocationsRequest = new CfgGetShopLocationsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgGetShopLocationsResponse$Type extends MessageType<CfgGetShopLocationsResponse> {
    constructor() {
        super("eve_trading_co_proto.CfgGetShopLocationsResponse", [
            { no: 1, name: "locations", kind: "map", K: 3 /*ScalarType.INT64*/, V: { kind: "message", T: () => CfgShopLocation } },
            { no: 2, name: "location_info_map", kind: "map", K: 3 /*ScalarType.INT64*/, V: { kind: "message", T: () => LocationInfo } },
            { no: 3, name: "location_naming_maps", kind: "message", T: () => LocationNamingMaps },
            { no: 4, name: "auth", kind: "message", T: () => AuthResponse },
            { no: 5, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<CfgGetShopLocationsResponse>): CfgGetShopLocationsResponse {
        const message = { locations: {}, locationInfoMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgGetShopLocationsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgGetShopLocationsResponse): CfgGetShopLocationsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int64, eve_trading_co_proto.CfgShopLocation> locations */ 1:
                    this.binaryReadMap1(message.locations, reader, options);
                    break;
                case /* map<int64, eve_trading_co_proto.LocationInfo> location_info_map */ 2:
                    this.binaryReadMap2(message.locationInfoMap, reader, options);
                    break;
                case /* eve_trading_co_proto.LocationNamingMaps location_naming_maps */ 3:
                    message.locationNamingMaps = LocationNamingMaps.internalBinaryRead(reader, reader.uint32(), options, message.locationNamingMaps);
                    break;
                case /* eve_trading_co_proto.AuthResponse auth */ 4:
                    message.auth = AuthResponse.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 5:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CfgGetShopLocationsResponse["locations"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CfgGetShopLocationsResponse["locations"] | undefined, val: CfgGetShopLocationsResponse["locations"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int64().toString();
                    break;
                case 2:
                    val = CfgShopLocation.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field eve_trading_co_proto.CfgGetShopLocationsResponse.locations");
            }
        }
        map[key ?? "0"] = val ?? CfgShopLocation.create();
    }
    private binaryReadMap2(map: CfgGetShopLocationsResponse["locationInfoMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CfgGetShopLocationsResponse["locationInfoMap"] | undefined, val: CfgGetShopLocationsResponse["locationInfoMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int64().toString();
                    break;
                case 2:
                    val = LocationInfo.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field eve_trading_co_proto.CfgGetShopLocationsResponse.location_info_map");
            }
        }
        map[key ?? "0"] = val ?? LocationInfo.create();
    }
    internalBinaryWrite(message: CfgGetShopLocationsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int64, eve_trading_co_proto.CfgShopLocation> locations = 1; */
        for (let k of Object.keys(message.locations)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int64(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            CfgShopLocation.internalBinaryWrite(message.locations[k], writer, options);
            writer.join().join();
        }
        /* map<int64, eve_trading_co_proto.LocationInfo> location_info_map = 2; */
        for (let k of Object.keys(message.locationInfoMap)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int64(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            LocationInfo.internalBinaryWrite(message.locationInfoMap[k], writer, options);
            writer.join().join();
        }
        /* eve_trading_co_proto.LocationNamingMaps location_naming_maps = 3; */
        if (message.locationNamingMaps)
            LocationNamingMaps.internalBinaryWrite(message.locationNamingMaps, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.AuthResponse auth = 4; */
        if (message.auth)
            AuthResponse.internalBinaryWrite(message.auth, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 5; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgGetShopLocationsResponse
 */
export const CfgGetShopLocationsResponse = new CfgGetShopLocationsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgMergeShopLocationsRequest$Type extends MessageType<CfgMergeShopLocationsRequest> {
    constructor() {
        super("eve_trading_co_proto.CfgMergeShopLocationsRequest", [
            { no: 1, name: "locations", kind: "map", K: 3 /*ScalarType.INT64*/, V: { kind: "message", T: () => CfgShopLocation } },
            { no: 2, name: "auth", kind: "message", T: () => AuthRequest }
        ]);
    }
    create(value?: PartialMessage<CfgMergeShopLocationsRequest>): CfgMergeShopLocationsRequest {
        const message = { locations: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgMergeShopLocationsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgMergeShopLocationsRequest): CfgMergeShopLocationsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int64, eve_trading_co_proto.CfgShopLocation> locations */ 1:
                    this.binaryReadMap1(message.locations, reader, options);
                    break;
                case /* eve_trading_co_proto.AuthRequest auth */ 2:
                    message.auth = AuthRequest.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CfgMergeShopLocationsRequest["locations"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CfgMergeShopLocationsRequest["locations"] | undefined, val: CfgMergeShopLocationsRequest["locations"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int64().toString();
                    break;
                case 2:
                    val = CfgShopLocation.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field eve_trading_co_proto.CfgMergeShopLocationsRequest.locations");
            }
        }
        map[key ?? "0"] = val ?? CfgShopLocation.create();
    }
    internalBinaryWrite(message: CfgMergeShopLocationsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int64, eve_trading_co_proto.CfgShopLocation> locations = 1; */
        for (let k of Object.keys(message.locations)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int64(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            CfgShopLocation.internalBinaryWrite(message.locations[k], writer, options);
            writer.join().join();
        }
        /* eve_trading_co_proto.AuthRequest auth = 2; */
        if (message.auth)
            AuthRequest.internalBinaryWrite(message.auth, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgMergeShopLocationsRequest
 */
export const CfgMergeShopLocationsRequest = new CfgMergeShopLocationsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgMergeShopLocationsResponse$Type extends MessageType<CfgMergeShopLocationsResponse> {
    constructor() {
        super("eve_trading_co_proto.CfgMergeShopLocationsResponse", [
            { no: 1, name: "Modified", kind: "scalar", jsonName: "Modified", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "auth", kind: "message", T: () => AuthResponse },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<CfgMergeShopLocationsResponse>): CfgMergeShopLocationsResponse {
        const message = { modified: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgMergeShopLocationsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgMergeShopLocationsResponse): CfgMergeShopLocationsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool Modified = 1 [json_name = "Modified"];*/ 1:
                    message.modified = reader.bool();
                    break;
                case /* eve_trading_co_proto.AuthResponse auth */ 2:
                    message.auth = AuthResponse.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgMergeShopLocationsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool Modified = 1 [json_name = "Modified"]; */
        if (message.modified !== false)
            writer.tag(1, WireType.Varint).bool(message.modified);
        /* eve_trading_co_proto.AuthResponse auth = 2; */
        if (message.auth)
            AuthResponse.internalBinaryWrite(message.auth, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgMergeShopLocationsResponse
 */
export const CfgMergeShopLocationsResponse = new CfgMergeShopLocationsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgGetMarketsRequest$Type extends MessageType<CfgGetMarketsRequest> {
    constructor() {
        super("eve_trading_co_proto.CfgGetMarketsRequest", [
            { no: 1, name: "include_location_info", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "include_location_naming", kind: "message", T: () => IncludeLocationNaming },
            { no: 3, name: "auth", kind: "message", T: () => AuthRequest }
        ]);
    }
    create(value?: PartialMessage<CfgGetMarketsRequest>): CfgGetMarketsRequest {
        const message = { includeLocationInfo: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgGetMarketsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgGetMarketsRequest): CfgGetMarketsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool include_location_info */ 1:
                    message.includeLocationInfo = reader.bool();
                    break;
                case /* eve_trading_co_proto.IncludeLocationNaming include_location_naming */ 2:
                    message.includeLocationNaming = IncludeLocationNaming.internalBinaryRead(reader, reader.uint32(), options, message.includeLocationNaming);
                    break;
                case /* eve_trading_co_proto.AuthRequest auth */ 3:
                    message.auth = AuthRequest.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgGetMarketsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool include_location_info = 1; */
        if (message.includeLocationInfo !== false)
            writer.tag(1, WireType.Varint).bool(message.includeLocationInfo);
        /* eve_trading_co_proto.IncludeLocationNaming include_location_naming = 2; */
        if (message.includeLocationNaming)
            IncludeLocationNaming.internalBinaryWrite(message.includeLocationNaming, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.AuthRequest auth = 3; */
        if (message.auth)
            AuthRequest.internalBinaryWrite(message.auth, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgGetMarketsRequest
 */
export const CfgGetMarketsRequest = new CfgGetMarketsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgGetMarketsResponse$Type extends MessageType<CfgGetMarketsResponse> {
    constructor() {
        super("eve_trading_co_proto.CfgGetMarketsResponse", [
            { no: 1, name: "markets", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => CfgMarket } },
            { no: 2, name: "location_info_map", kind: "map", K: 3 /*ScalarType.INT64*/, V: { kind: "message", T: () => LocationInfo } },
            { no: 3, name: "location_naming_maps", kind: "message", T: () => LocationNamingMaps },
            { no: 4, name: "auth", kind: "message", T: () => AuthResponse },
            { no: 5, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<CfgGetMarketsResponse>): CfgGetMarketsResponse {
        const message = { markets: {}, locationInfoMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgGetMarketsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgGetMarketsResponse): CfgGetMarketsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, eve_trading_co_proto.CfgMarket> markets */ 1:
                    this.binaryReadMap1(message.markets, reader, options);
                    break;
                case /* map<int64, eve_trading_co_proto.LocationInfo> location_info_map */ 2:
                    this.binaryReadMap2(message.locationInfoMap, reader, options);
                    break;
                case /* eve_trading_co_proto.LocationNamingMaps location_naming_maps */ 3:
                    message.locationNamingMaps = LocationNamingMaps.internalBinaryRead(reader, reader.uint32(), options, message.locationNamingMaps);
                    break;
                case /* eve_trading_co_proto.AuthResponse auth */ 4:
                    message.auth = AuthResponse.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 5:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CfgGetMarketsResponse["markets"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CfgGetMarketsResponse["markets"] | undefined, val: CfgGetMarketsResponse["markets"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = CfgMarket.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field eve_trading_co_proto.CfgGetMarketsResponse.markets");
            }
        }
        map[key ?? ""] = val ?? CfgMarket.create();
    }
    private binaryReadMap2(map: CfgGetMarketsResponse["locationInfoMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CfgGetMarketsResponse["locationInfoMap"] | undefined, val: CfgGetMarketsResponse["locationInfoMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int64().toString();
                    break;
                case 2:
                    val = LocationInfo.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field eve_trading_co_proto.CfgGetMarketsResponse.location_info_map");
            }
        }
        map[key ?? "0"] = val ?? LocationInfo.create();
    }
    internalBinaryWrite(message: CfgGetMarketsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, eve_trading_co_proto.CfgMarket> markets = 1; */
        for (let k of Object.keys(message.markets)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            CfgMarket.internalBinaryWrite(message.markets[k], writer, options);
            writer.join().join();
        }
        /* map<int64, eve_trading_co_proto.LocationInfo> location_info_map = 2; */
        for (let k of Object.keys(message.locationInfoMap)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int64(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            LocationInfo.internalBinaryWrite(message.locationInfoMap[k], writer, options);
            writer.join().join();
        }
        /* eve_trading_co_proto.LocationNamingMaps location_naming_maps = 3; */
        if (message.locationNamingMaps)
            LocationNamingMaps.internalBinaryWrite(message.locationNamingMaps, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.AuthResponse auth = 4; */
        if (message.auth)
            AuthResponse.internalBinaryWrite(message.auth, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 5; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgGetMarketsResponse
 */
export const CfgGetMarketsResponse = new CfgGetMarketsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgMergeMarketsRequest$Type extends MessageType<CfgMergeMarketsRequest> {
    constructor() {
        super("eve_trading_co_proto.CfgMergeMarketsRequest", [
            { no: 1, name: "markets", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => CfgMarket } },
            { no: 2, name: "auth", kind: "message", T: () => AuthRequest }
        ]);
    }
    create(value?: PartialMessage<CfgMergeMarketsRequest>): CfgMergeMarketsRequest {
        const message = { markets: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgMergeMarketsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgMergeMarketsRequest): CfgMergeMarketsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, eve_trading_co_proto.CfgMarket> markets */ 1:
                    this.binaryReadMap1(message.markets, reader, options);
                    break;
                case /* eve_trading_co_proto.AuthRequest auth */ 2:
                    message.auth = AuthRequest.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CfgMergeMarketsRequest["markets"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CfgMergeMarketsRequest["markets"] | undefined, val: CfgMergeMarketsRequest["markets"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = CfgMarket.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field eve_trading_co_proto.CfgMergeMarketsRequest.markets");
            }
        }
        map[key ?? ""] = val ?? CfgMarket.create();
    }
    internalBinaryWrite(message: CfgMergeMarketsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, eve_trading_co_proto.CfgMarket> markets = 1; */
        for (let k of Object.keys(message.markets)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            CfgMarket.internalBinaryWrite(message.markets[k], writer, options);
            writer.join().join();
        }
        /* eve_trading_co_proto.AuthRequest auth = 2; */
        if (message.auth)
            AuthRequest.internalBinaryWrite(message.auth, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgMergeMarketsRequest
 */
export const CfgMergeMarketsRequest = new CfgMergeMarketsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgMergeMarketsResponse$Type extends MessageType<CfgMergeMarketsResponse> {
    constructor() {
        super("eve_trading_co_proto.CfgMergeMarketsResponse", [
            { no: 1, name: "Modified", kind: "scalar", jsonName: "Modified", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "auth", kind: "message", T: () => AuthResponse },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<CfgMergeMarketsResponse>): CfgMergeMarketsResponse {
        const message = { modified: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgMergeMarketsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgMergeMarketsResponse): CfgMergeMarketsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool Modified = 1 [json_name = "Modified"];*/ 1:
                    message.modified = reader.bool();
                    break;
                case /* eve_trading_co_proto.AuthResponse auth */ 2:
                    message.auth = AuthResponse.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgMergeMarketsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool Modified = 1 [json_name = "Modified"]; */
        if (message.modified !== false)
            writer.tag(1, WireType.Varint).bool(message.modified);
        /* eve_trading_co_proto.AuthResponse auth = 2; */
        if (message.auth)
            AuthResponse.internalBinaryWrite(message.auth, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgMergeMarketsResponse
 */
export const CfgMergeMarketsResponse = new CfgMergeMarketsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NewBuybackAppraisalRequest$Type extends MessageType<NewBuybackAppraisalRequest> {
    constructor() {
        super("eve_trading_co_proto.NewBuybackAppraisalRequest", [
            { no: 1, name: "system_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BasicItem },
            { no: 3, name: "save", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "include_type_naming", kind: "message", T: () => IncludeTypeNaming },
            { no: 5, name: "auth", kind: "message", T: () => AuthRequest }
        ]);
    }
    create(value?: PartialMessage<NewBuybackAppraisalRequest>): NewBuybackAppraisalRequest {
        const message = { systemId: 0, items: [], save: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NewBuybackAppraisalRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NewBuybackAppraisalRequest): NewBuybackAppraisalRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 system_id */ 1:
                    message.systemId = reader.int32();
                    break;
                case /* repeated eve_trading_co_proto.BasicItem items */ 2:
                    message.items.push(BasicItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool save */ 3:
                    message.save = reader.bool();
                    break;
                case /* eve_trading_co_proto.IncludeTypeNaming include_type_naming */ 4:
                    message.includeTypeNaming = IncludeTypeNaming.internalBinaryRead(reader, reader.uint32(), options, message.includeTypeNaming);
                    break;
                case /* eve_trading_co_proto.AuthRequest auth */ 5:
                    message.auth = AuthRequest.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NewBuybackAppraisalRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 system_id = 1; */
        if (message.systemId !== 0)
            writer.tag(1, WireType.Varint).int32(message.systemId);
        /* repeated eve_trading_co_proto.BasicItem items = 2; */
        for (let i = 0; i < message.items.length; i++)
            BasicItem.internalBinaryWrite(message.items[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool save = 3; */
        if (message.save !== false)
            writer.tag(3, WireType.Varint).bool(message.save);
        /* eve_trading_co_proto.IncludeTypeNaming include_type_naming = 4; */
        if (message.includeTypeNaming)
            IncludeTypeNaming.internalBinaryWrite(message.includeTypeNaming, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.AuthRequest auth = 5; */
        if (message.auth)
            AuthRequest.internalBinaryWrite(message.auth, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.NewBuybackAppraisalRequest
 */
export const NewBuybackAppraisalRequest = new NewBuybackAppraisalRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NewBuybackAppraisalResponse$Type extends MessageType<NewBuybackAppraisalResponse> {
    constructor() {
        super("eve_trading_co_proto.NewBuybackAppraisalResponse", [
            { no: 1, name: "appraisal", kind: "message", T: () => BuybackAppraisal },
            { no: 2, name: "type_naming_lists", kind: "message", T: () => TypeNamingLists },
            { no: 3, name: "auth", kind: "message", T: () => AuthResponse },
            { no: 4, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<NewBuybackAppraisalResponse>): NewBuybackAppraisalResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NewBuybackAppraisalResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NewBuybackAppraisalResponse): NewBuybackAppraisalResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eve_trading_co_proto.BuybackAppraisal appraisal */ 1:
                    message.appraisal = BuybackAppraisal.internalBinaryRead(reader, reader.uint32(), options, message.appraisal);
                    break;
                case /* eve_trading_co_proto.TypeNamingLists type_naming_lists */ 2:
                    message.typeNamingLists = TypeNamingLists.internalBinaryRead(reader, reader.uint32(), options, message.typeNamingLists);
                    break;
                case /* eve_trading_co_proto.AuthResponse auth */ 3:
                    message.auth = AuthResponse.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 4:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NewBuybackAppraisalResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eve_trading_co_proto.BuybackAppraisal appraisal = 1; */
        if (message.appraisal)
            BuybackAppraisal.internalBinaryWrite(message.appraisal, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.TypeNamingLists type_naming_lists = 2; */
        if (message.typeNamingLists)
            TypeNamingLists.internalBinaryWrite(message.typeNamingLists, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.AuthResponse auth = 3; */
        if (message.auth)
            AuthResponse.internalBinaryWrite(message.auth, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 4; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.NewBuybackAppraisalResponse
 */
export const NewBuybackAppraisalResponse = new NewBuybackAppraisalResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NewShopAppraisalRequest$Type extends MessageType<NewShopAppraisalRequest> {
    constructor() {
        super("eve_trading_co_proto.NewShopAppraisalRequest", [
            { no: 1, name: "location_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BasicItem },
            { no: 3, name: "include_type_naming", kind: "message", T: () => IncludeTypeNaming }
        ]);
    }
    create(value?: PartialMessage<NewShopAppraisalRequest>): NewShopAppraisalRequest {
        const message = { locationId: 0, items: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NewShopAppraisalRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NewShopAppraisalRequest): NewShopAppraisalRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 location_id */ 1:
                    message.locationId = reader.int64().toNumber();
                    break;
                case /* repeated eve_trading_co_proto.BasicItem items */ 2:
                    message.items.push(BasicItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* eve_trading_co_proto.IncludeTypeNaming include_type_naming */ 3:
                    message.includeTypeNaming = IncludeTypeNaming.internalBinaryRead(reader, reader.uint32(), options, message.includeTypeNaming);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NewShopAppraisalRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 location_id = 1; */
        if (message.locationId !== 0)
            writer.tag(1, WireType.Varint).int64(message.locationId);
        /* repeated eve_trading_co_proto.BasicItem items = 2; */
        for (let i = 0; i < message.items.length; i++)
            BasicItem.internalBinaryWrite(message.items[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.IncludeTypeNaming include_type_naming = 3; */
        if (message.includeTypeNaming)
            IncludeTypeNaming.internalBinaryWrite(message.includeTypeNaming, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.NewShopAppraisalRequest
 */
export const NewShopAppraisalRequest = new NewShopAppraisalRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NewShopAppraisalResponse$Type extends MessageType<NewShopAppraisalResponse> {
    constructor() {
        super("eve_trading_co_proto.NewShopAppraisalResponse", [
            { no: 1, name: "appraisal", kind: "message", T: () => ShopAppraisal },
            { no: 2, name: "type_naming_lists", kind: "message", T: () => TypeNamingLists },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<NewShopAppraisalResponse>): NewShopAppraisalResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NewShopAppraisalResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NewShopAppraisalResponse): NewShopAppraisalResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eve_trading_co_proto.ShopAppraisal appraisal */ 1:
                    message.appraisal = ShopAppraisal.internalBinaryRead(reader, reader.uint32(), options, message.appraisal);
                    break;
                case /* eve_trading_co_proto.TypeNamingLists type_naming_lists */ 2:
                    message.typeNamingLists = TypeNamingLists.internalBinaryRead(reader, reader.uint32(), options, message.typeNamingLists);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NewShopAppraisalResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eve_trading_co_proto.ShopAppraisal appraisal = 1; */
        if (message.appraisal)
            ShopAppraisal.internalBinaryWrite(message.appraisal, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.TypeNamingLists type_naming_lists = 2; */
        if (message.typeNamingLists)
            TypeNamingLists.internalBinaryWrite(message.typeNamingLists, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.NewShopAppraisalResponse
 */
export const NewShopAppraisalResponse = new NewShopAppraisalResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBuybackAppraisalRequest$Type extends MessageType<GetBuybackAppraisalRequest> {
    constructor() {
        super("eve_trading_co_proto.GetBuybackAppraisalRequest", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "include_type_naming", kind: "message", T: () => IncludeTypeNaming },
            { no: 3, name: "admin", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "auth", kind: "message", T: () => AuthRequest }
        ]);
    }
    create(value?: PartialMessage<GetBuybackAppraisalRequest>): GetBuybackAppraisalRequest {
        const message = { code: "", admin: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetBuybackAppraisalRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBuybackAppraisalRequest): GetBuybackAppraisalRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* eve_trading_co_proto.IncludeTypeNaming include_type_naming */ 2:
                    message.includeTypeNaming = IncludeTypeNaming.internalBinaryRead(reader, reader.uint32(), options, message.includeTypeNaming);
                    break;
                case /* bool admin */ 3:
                    message.admin = reader.bool();
                    break;
                case /* eve_trading_co_proto.AuthRequest auth */ 4:
                    message.auth = AuthRequest.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBuybackAppraisalRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* eve_trading_co_proto.IncludeTypeNaming include_type_naming = 2; */
        if (message.includeTypeNaming)
            IncludeTypeNaming.internalBinaryWrite(message.includeTypeNaming, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool admin = 3; */
        if (message.admin !== false)
            writer.tag(3, WireType.Varint).bool(message.admin);
        /* eve_trading_co_proto.AuthRequest auth = 4; */
        if (message.auth)
            AuthRequest.internalBinaryWrite(message.auth, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.GetBuybackAppraisalRequest
 */
export const GetBuybackAppraisalRequest = new GetBuybackAppraisalRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBuybackAppraisalResponse$Type extends MessageType<GetBuybackAppraisalResponse> {
    constructor() {
        super("eve_trading_co_proto.GetBuybackAppraisalResponse", [
            { no: 1, name: "appraisal", kind: "message", T: () => BuybackAppraisal },
            { no: 2, name: "hash_character_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "character_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "type_naming_lists", kind: "message", T: () => TypeNamingLists },
            { no: 5, name: "auth", kind: "message", T: () => AuthResponse },
            { no: 6, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<GetBuybackAppraisalResponse>): GetBuybackAppraisalResponse {
        const message = { hashCharacterId: "", characterId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetBuybackAppraisalResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBuybackAppraisalResponse): GetBuybackAppraisalResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eve_trading_co_proto.BuybackAppraisal appraisal */ 1:
                    message.appraisal = BuybackAppraisal.internalBinaryRead(reader, reader.uint32(), options, message.appraisal);
                    break;
                case /* string hash_character_id */ 2:
                    message.hashCharacterId = reader.string();
                    break;
                case /* int32 character_id */ 3:
                    message.characterId = reader.int32();
                    break;
                case /* eve_trading_co_proto.TypeNamingLists type_naming_lists */ 4:
                    message.typeNamingLists = TypeNamingLists.internalBinaryRead(reader, reader.uint32(), options, message.typeNamingLists);
                    break;
                case /* eve_trading_co_proto.AuthResponse auth */ 5:
                    message.auth = AuthResponse.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 6:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBuybackAppraisalResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eve_trading_co_proto.BuybackAppraisal appraisal = 1; */
        if (message.appraisal)
            BuybackAppraisal.internalBinaryWrite(message.appraisal, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string hash_character_id = 2; */
        if (message.hashCharacterId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.hashCharacterId);
        /* int32 character_id = 3; */
        if (message.characterId !== 0)
            writer.tag(3, WireType.Varint).int32(message.characterId);
        /* eve_trading_co_proto.TypeNamingLists type_naming_lists = 4; */
        if (message.typeNamingLists)
            TypeNamingLists.internalBinaryWrite(message.typeNamingLists, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.AuthResponse auth = 5; */
        if (message.auth)
            AuthResponse.internalBinaryWrite(message.auth, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 6; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.GetBuybackAppraisalResponse
 */
export const GetBuybackAppraisalResponse = new GetBuybackAppraisalResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetShopAppraisalRequest$Type extends MessageType<GetShopAppraisalRequest> {
    constructor() {
        super("eve_trading_co_proto.GetShopAppraisalRequest", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "include_type_naming", kind: "message", T: () => IncludeTypeNaming },
            { no: 3, name: "admin", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "auth", kind: "message", T: () => AuthRequest }
        ]);
    }
    create(value?: PartialMessage<GetShopAppraisalRequest>): GetShopAppraisalRequest {
        const message = { code: "", admin: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetShopAppraisalRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetShopAppraisalRequest): GetShopAppraisalRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* eve_trading_co_proto.IncludeTypeNaming include_type_naming */ 2:
                    message.includeTypeNaming = IncludeTypeNaming.internalBinaryRead(reader, reader.uint32(), options, message.includeTypeNaming);
                    break;
                case /* bool admin */ 3:
                    message.admin = reader.bool();
                    break;
                case /* eve_trading_co_proto.AuthRequest auth */ 4:
                    message.auth = AuthRequest.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetShopAppraisalRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* eve_trading_co_proto.IncludeTypeNaming include_type_naming = 2; */
        if (message.includeTypeNaming)
            IncludeTypeNaming.internalBinaryWrite(message.includeTypeNaming, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool admin = 3; */
        if (message.admin !== false)
            writer.tag(3, WireType.Varint).bool(message.admin);
        /* eve_trading_co_proto.AuthRequest auth = 4; */
        if (message.auth)
            AuthRequest.internalBinaryWrite(message.auth, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.GetShopAppraisalRequest
 */
export const GetShopAppraisalRequest = new GetShopAppraisalRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetShopAppraisalResponse$Type extends MessageType<GetShopAppraisalResponse> {
    constructor() {
        super("eve_trading_co_proto.GetShopAppraisalResponse", [
            { no: 1, name: "appraisal", kind: "message", T: () => ShopAppraisal },
            { no: 2, name: "hash_character_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "character_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "type_naming_lists", kind: "message", T: () => TypeNamingLists },
            { no: 5, name: "auth", kind: "message", T: () => AuthResponse },
            { no: 6, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<GetShopAppraisalResponse>): GetShopAppraisalResponse {
        const message = { hashCharacterId: "", characterId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetShopAppraisalResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetShopAppraisalResponse): GetShopAppraisalResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eve_trading_co_proto.ShopAppraisal appraisal */ 1:
                    message.appraisal = ShopAppraisal.internalBinaryRead(reader, reader.uint32(), options, message.appraisal);
                    break;
                case /* string hash_character_id */ 2:
                    message.hashCharacterId = reader.string();
                    break;
                case /* int32 character_id */ 3:
                    message.characterId = reader.int32();
                    break;
                case /* eve_trading_co_proto.TypeNamingLists type_naming_lists */ 4:
                    message.typeNamingLists = TypeNamingLists.internalBinaryRead(reader, reader.uint32(), options, message.typeNamingLists);
                    break;
                case /* eve_trading_co_proto.AuthResponse auth */ 5:
                    message.auth = AuthResponse.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 6:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetShopAppraisalResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eve_trading_co_proto.ShopAppraisal appraisal = 1; */
        if (message.appraisal)
            ShopAppraisal.internalBinaryWrite(message.appraisal, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string hash_character_id = 2; */
        if (message.hashCharacterId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.hashCharacterId);
        /* int32 character_id = 3; */
        if (message.characterId !== 0)
            writer.tag(3, WireType.Varint).int32(message.characterId);
        /* eve_trading_co_proto.TypeNamingLists type_naming_lists = 4; */
        if (message.typeNamingLists)
            TypeNamingLists.internalBinaryWrite(message.typeNamingLists, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.AuthResponse auth = 5; */
        if (message.auth)
            AuthResponse.internalBinaryWrite(message.auth, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 6; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.GetShopAppraisalResponse
 */
export const GetShopAppraisalResponse = new GetShopAppraisalResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatusBuybackAppraisalRequest$Type extends MessageType<StatusBuybackAppraisalRequest> {
    constructor() {
        super("eve_trading_co_proto.StatusBuybackAppraisalRequest", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "include_items", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "include_location_info", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "include_type_naming", kind: "message", T: () => IncludeTypeNaming },
            { no: 5, name: "include_location_naming", kind: "message", T: () => IncludeLocationNaming },
            { no: 6, name: "admin", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "auth", kind: "message", T: () => AuthRequest }
        ]);
    }
    create(value?: PartialMessage<StatusBuybackAppraisalRequest>): StatusBuybackAppraisalRequest {
        const message = { code: "", includeItems: false, includeLocationInfo: false, admin: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StatusBuybackAppraisalRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatusBuybackAppraisalRequest): StatusBuybackAppraisalRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* bool include_items */ 2:
                    message.includeItems = reader.bool();
                    break;
                case /* bool include_location_info */ 3:
                    message.includeLocationInfo = reader.bool();
                    break;
                case /* eve_trading_co_proto.IncludeTypeNaming include_type_naming */ 4:
                    message.includeTypeNaming = IncludeTypeNaming.internalBinaryRead(reader, reader.uint32(), options, message.includeTypeNaming);
                    break;
                case /* eve_trading_co_proto.IncludeLocationNaming include_location_naming */ 5:
                    message.includeLocationNaming = IncludeLocationNaming.internalBinaryRead(reader, reader.uint32(), options, message.includeLocationNaming);
                    break;
                case /* bool admin */ 6:
                    message.admin = reader.bool();
                    break;
                case /* eve_trading_co_proto.AuthRequest auth */ 7:
                    message.auth = AuthRequest.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatusBuybackAppraisalRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* bool include_items = 2; */
        if (message.includeItems !== false)
            writer.tag(2, WireType.Varint).bool(message.includeItems);
        /* bool include_location_info = 3; */
        if (message.includeLocationInfo !== false)
            writer.tag(3, WireType.Varint).bool(message.includeLocationInfo);
        /* eve_trading_co_proto.IncludeTypeNaming include_type_naming = 4; */
        if (message.includeTypeNaming)
            IncludeTypeNaming.internalBinaryWrite(message.includeTypeNaming, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.IncludeLocationNaming include_location_naming = 5; */
        if (message.includeLocationNaming)
            IncludeLocationNaming.internalBinaryWrite(message.includeLocationNaming, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bool admin = 6; */
        if (message.admin !== false)
            writer.tag(6, WireType.Varint).bool(message.admin);
        /* eve_trading_co_proto.AuthRequest auth = 7; */
        if (message.auth)
            AuthRequest.internalBinaryWrite(message.auth, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.StatusBuybackAppraisalRequest
 */
export const StatusBuybackAppraisalRequest = new StatusBuybackAppraisalRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatusBuybackAppraisalResponse$Type extends MessageType<StatusBuybackAppraisalResponse> {
    constructor() {
        super("eve_trading_co_proto.StatusBuybackAppraisalResponse", [
            { no: 1, name: "contract", kind: "message", T: () => Contract },
            { no: 2, name: "contract_items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ContractItem },
            { no: 3, name: "location_info", kind: "message", T: () => LocationInfo },
            { no: 4, name: "type_naming_lists", kind: "message", T: () => TypeNamingLists },
            { no: 5, name: "location_naming_maps", kind: "message", T: () => LocationNamingMaps },
            { no: 6, name: "auth", kind: "message", T: () => AuthResponse },
            { no: 7, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<StatusBuybackAppraisalResponse>): StatusBuybackAppraisalResponse {
        const message = { contractItems: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StatusBuybackAppraisalResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatusBuybackAppraisalResponse): StatusBuybackAppraisalResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eve_trading_co_proto.Contract contract */ 1:
                    message.contract = Contract.internalBinaryRead(reader, reader.uint32(), options, message.contract);
                    break;
                case /* repeated eve_trading_co_proto.ContractItem contract_items */ 2:
                    message.contractItems.push(ContractItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* eve_trading_co_proto.LocationInfo location_info */ 3:
                    message.locationInfo = LocationInfo.internalBinaryRead(reader, reader.uint32(), options, message.locationInfo);
                    break;
                case /* eve_trading_co_proto.TypeNamingLists type_naming_lists */ 4:
                    message.typeNamingLists = TypeNamingLists.internalBinaryRead(reader, reader.uint32(), options, message.typeNamingLists);
                    break;
                case /* eve_trading_co_proto.LocationNamingMaps location_naming_maps */ 5:
                    message.locationNamingMaps = LocationNamingMaps.internalBinaryRead(reader, reader.uint32(), options, message.locationNamingMaps);
                    break;
                case /* eve_trading_co_proto.AuthResponse auth */ 6:
                    message.auth = AuthResponse.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 7:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatusBuybackAppraisalResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eve_trading_co_proto.Contract contract = 1; */
        if (message.contract)
            Contract.internalBinaryWrite(message.contract, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated eve_trading_co_proto.ContractItem contract_items = 2; */
        for (let i = 0; i < message.contractItems.length; i++)
            ContractItem.internalBinaryWrite(message.contractItems[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.LocationInfo location_info = 3; */
        if (message.locationInfo)
            LocationInfo.internalBinaryWrite(message.locationInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.TypeNamingLists type_naming_lists = 4; */
        if (message.typeNamingLists)
            TypeNamingLists.internalBinaryWrite(message.typeNamingLists, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.LocationNamingMaps location_naming_maps = 5; */
        if (message.locationNamingMaps)
            LocationNamingMaps.internalBinaryWrite(message.locationNamingMaps, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.AuthResponse auth = 6; */
        if (message.auth)
            AuthResponse.internalBinaryWrite(message.auth, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 7; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.StatusBuybackAppraisalResponse
 */
export const StatusBuybackAppraisalResponse = new StatusBuybackAppraisalResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatusShopAppraisalRequest$Type extends MessageType<StatusShopAppraisalRequest> {
    constructor() {
        super("eve_trading_co_proto.StatusShopAppraisalRequest", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "include_items", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "include_location_info", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "include_type_naming", kind: "message", T: () => IncludeTypeNaming },
            { no: 5, name: "include_location_naming", kind: "message", T: () => IncludeLocationNaming },
            { no: 6, name: "admin", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "auth", kind: "message", T: () => AuthRequest }
        ]);
    }
    create(value?: PartialMessage<StatusShopAppraisalRequest>): StatusShopAppraisalRequest {
        const message = { code: "", includeItems: false, includeLocationInfo: false, admin: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StatusShopAppraisalRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatusShopAppraisalRequest): StatusShopAppraisalRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* bool include_items */ 2:
                    message.includeItems = reader.bool();
                    break;
                case /* bool include_location_info */ 3:
                    message.includeLocationInfo = reader.bool();
                    break;
                case /* eve_trading_co_proto.IncludeTypeNaming include_type_naming */ 4:
                    message.includeTypeNaming = IncludeTypeNaming.internalBinaryRead(reader, reader.uint32(), options, message.includeTypeNaming);
                    break;
                case /* eve_trading_co_proto.IncludeLocationNaming include_location_naming */ 5:
                    message.includeLocationNaming = IncludeLocationNaming.internalBinaryRead(reader, reader.uint32(), options, message.includeLocationNaming);
                    break;
                case /* bool admin */ 6:
                    message.admin = reader.bool();
                    break;
                case /* eve_trading_co_proto.AuthRequest auth */ 7:
                    message.auth = AuthRequest.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatusShopAppraisalRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* bool include_items = 2; */
        if (message.includeItems !== false)
            writer.tag(2, WireType.Varint).bool(message.includeItems);
        /* bool include_location_info = 3; */
        if (message.includeLocationInfo !== false)
            writer.tag(3, WireType.Varint).bool(message.includeLocationInfo);
        /* eve_trading_co_proto.IncludeTypeNaming include_type_naming = 4; */
        if (message.includeTypeNaming)
            IncludeTypeNaming.internalBinaryWrite(message.includeTypeNaming, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.IncludeLocationNaming include_location_naming = 5; */
        if (message.includeLocationNaming)
            IncludeLocationNaming.internalBinaryWrite(message.includeLocationNaming, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bool admin = 6; */
        if (message.admin !== false)
            writer.tag(6, WireType.Varint).bool(message.admin);
        /* eve_trading_co_proto.AuthRequest auth = 7; */
        if (message.auth)
            AuthRequest.internalBinaryWrite(message.auth, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.StatusShopAppraisalRequest
 */
export const StatusShopAppraisalRequest = new StatusShopAppraisalRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatusShopAppraisalResponse$Type extends MessageType<StatusShopAppraisalResponse> {
    constructor() {
        super("eve_trading_co_proto.StatusShopAppraisalResponse", [
            { no: 1, name: "contract", kind: "message", T: () => Contract },
            { no: 2, name: "in_purchase_queue", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "contract_items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ContractItem },
            { no: 4, name: "location_info", kind: "message", T: () => LocationInfo },
            { no: 5, name: "type_naming_lists", kind: "message", T: () => TypeNamingLists },
            { no: 6, name: "location_naming_maps", kind: "message", T: () => LocationNamingMaps },
            { no: 7, name: "auth", kind: "message", T: () => AuthResponse },
            { no: 8, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<StatusShopAppraisalResponse>): StatusShopAppraisalResponse {
        const message = { inPurchaseQueue: false, contractItems: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StatusShopAppraisalResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatusShopAppraisalResponse): StatusShopAppraisalResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eve_trading_co_proto.Contract contract */ 1:
                    message.contract = Contract.internalBinaryRead(reader, reader.uint32(), options, message.contract);
                    break;
                case /* bool in_purchase_queue */ 2:
                    message.inPurchaseQueue = reader.bool();
                    break;
                case /* repeated eve_trading_co_proto.ContractItem contract_items */ 3:
                    message.contractItems.push(ContractItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* eve_trading_co_proto.LocationInfo location_info */ 4:
                    message.locationInfo = LocationInfo.internalBinaryRead(reader, reader.uint32(), options, message.locationInfo);
                    break;
                case /* eve_trading_co_proto.TypeNamingLists type_naming_lists */ 5:
                    message.typeNamingLists = TypeNamingLists.internalBinaryRead(reader, reader.uint32(), options, message.typeNamingLists);
                    break;
                case /* eve_trading_co_proto.LocationNamingMaps location_naming_maps */ 6:
                    message.locationNamingMaps = LocationNamingMaps.internalBinaryRead(reader, reader.uint32(), options, message.locationNamingMaps);
                    break;
                case /* eve_trading_co_proto.AuthResponse auth */ 7:
                    message.auth = AuthResponse.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 8:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatusShopAppraisalResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eve_trading_co_proto.Contract contract = 1; */
        if (message.contract)
            Contract.internalBinaryWrite(message.contract, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool in_purchase_queue = 2; */
        if (message.inPurchaseQueue !== false)
            writer.tag(2, WireType.Varint).bool(message.inPurchaseQueue);
        /* repeated eve_trading_co_proto.ContractItem contract_items = 3; */
        for (let i = 0; i < message.contractItems.length; i++)
            ContractItem.internalBinaryWrite(message.contractItems[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.LocationInfo location_info = 4; */
        if (message.locationInfo)
            LocationInfo.internalBinaryWrite(message.locationInfo, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.TypeNamingLists type_naming_lists = 5; */
        if (message.typeNamingLists)
            TypeNamingLists.internalBinaryWrite(message.typeNamingLists, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.LocationNamingMaps location_naming_maps = 6; */
        if (message.locationNamingMaps)
            LocationNamingMaps.internalBinaryWrite(message.locationNamingMaps, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.AuthResponse auth = 7; */
        if (message.auth)
            AuthResponse.internalBinaryWrite(message.auth, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 8; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.StatusShopAppraisalResponse
 */
export const StatusShopAppraisalResponse = new StatusShopAppraisalResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopInventoryRequest$Type extends MessageType<ShopInventoryRequest> {
    constructor() {
        super("eve_trading_co_proto.ShopInventoryRequest", [
            { no: 1, name: "location_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "include_type_naming", kind: "message", T: () => IncludeTypeNaming },
            { no: 3, name: "auth", kind: "message", T: () => AuthRequest }
        ]);
    }
    create(value?: PartialMessage<ShopInventoryRequest>): ShopInventoryRequest {
        const message = { locationId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopInventoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopInventoryRequest): ShopInventoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 location_id */ 1:
                    message.locationId = reader.int64().toNumber();
                    break;
                case /* eve_trading_co_proto.IncludeTypeNaming include_type_naming */ 2:
                    message.includeTypeNaming = IncludeTypeNaming.internalBinaryRead(reader, reader.uint32(), options, message.includeTypeNaming);
                    break;
                case /* eve_trading_co_proto.AuthRequest auth */ 3:
                    message.auth = AuthRequest.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopInventoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 location_id = 1; */
        if (message.locationId !== 0)
            writer.tag(1, WireType.Varint).int64(message.locationId);
        /* eve_trading_co_proto.IncludeTypeNaming include_type_naming = 2; */
        if (message.includeTypeNaming)
            IncludeTypeNaming.internalBinaryWrite(message.includeTypeNaming, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.AuthRequest auth = 3; */
        if (message.auth)
            AuthRequest.internalBinaryWrite(message.auth, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.ShopInventoryRequest
 */
export const ShopInventoryRequest = new ShopInventoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopInventoryResponse$Type extends MessageType<ShopInventoryResponse> {
    constructor() {
        super("eve_trading_co_proto.ShopInventoryResponse", [
            { no: 1, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ShopItem },
            { no: 2, name: "type_naming_lists", kind: "message", T: () => TypeNamingLists },
            { no: 3, name: "auth", kind: "message", T: () => AuthResponse },
            { no: 4, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<ShopInventoryResponse>): ShopInventoryResponse {
        const message = { items: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopInventoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopInventoryResponse): ShopInventoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_trading_co_proto.ShopItem items */ 1:
                    message.items.push(ShopItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* eve_trading_co_proto.TypeNamingLists type_naming_lists */ 2:
                    message.typeNamingLists = TypeNamingLists.internalBinaryRead(reader, reader.uint32(), options, message.typeNamingLists);
                    break;
                case /* eve_trading_co_proto.AuthResponse auth */ 3:
                    message.auth = AuthResponse.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 4:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopInventoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated eve_trading_co_proto.ShopItem items = 1; */
        for (let i = 0; i < message.items.length; i++)
            ShopItem.internalBinaryWrite(message.items[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.TypeNamingLists type_naming_lists = 2; */
        if (message.typeNamingLists)
            TypeNamingLists.internalBinaryWrite(message.typeNamingLists, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.AuthResponse auth = 3; */
        if (message.auth)
            AuthResponse.internalBinaryWrite(message.auth, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 4; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.ShopInventoryResponse
 */
export const ShopInventoryResponse = new ShopInventoryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopMakePurchaseRequest$Type extends MessageType<ShopMakePurchaseRequest> {
    constructor() {
        super("eve_trading_co_proto.ShopMakePurchaseRequest", [
            { no: 1, name: "location_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BasicItem },
            { no: 3, name: "include_type_naming", kind: "message", T: () => IncludeTypeNaming },
            { no: 4, name: "auth", kind: "message", T: () => AuthRequest }
        ]);
    }
    create(value?: PartialMessage<ShopMakePurchaseRequest>): ShopMakePurchaseRequest {
        const message = { locationId: 0, items: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopMakePurchaseRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopMakePurchaseRequest): ShopMakePurchaseRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 location_id */ 1:
                    message.locationId = reader.int64().toNumber();
                    break;
                case /* repeated eve_trading_co_proto.BasicItem items */ 2:
                    message.items.push(BasicItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* eve_trading_co_proto.IncludeTypeNaming include_type_naming */ 3:
                    message.includeTypeNaming = IncludeTypeNaming.internalBinaryRead(reader, reader.uint32(), options, message.includeTypeNaming);
                    break;
                case /* eve_trading_co_proto.AuthRequest auth */ 4:
                    message.auth = AuthRequest.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopMakePurchaseRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 location_id = 1; */
        if (message.locationId !== 0)
            writer.tag(1, WireType.Varint).int64(message.locationId);
        /* repeated eve_trading_co_proto.BasicItem items = 2; */
        for (let i = 0; i < message.items.length; i++)
            BasicItem.internalBinaryWrite(message.items[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.IncludeTypeNaming include_type_naming = 3; */
        if (message.includeTypeNaming)
            IncludeTypeNaming.internalBinaryWrite(message.includeTypeNaming, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.AuthRequest auth = 4; */
        if (message.auth)
            AuthRequest.internalBinaryWrite(message.auth, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.ShopMakePurchaseRequest
 */
export const ShopMakePurchaseRequest = new ShopMakePurchaseRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopMakePurchaseResponse$Type extends MessageType<ShopMakePurchaseResponse> {
    constructor() {
        super("eve_trading_co_proto.ShopMakePurchaseResponse", [
            { no: 1, name: "status", kind: "enum", T: () => ["eve_trading_co_proto.MakePurchaseStatus", MakePurchaseStatus] },
            { no: 2, name: "appraisal", kind: "message", T: () => ShopAppraisal },
            { no: 3, name: "type_naming_lists", kind: "message", T: () => TypeNamingLists },
            { no: 4, name: "auth", kind: "message", T: () => AuthResponse },
            { no: 5, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<ShopMakePurchaseResponse>): ShopMakePurchaseResponse {
        const message = { status: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopMakePurchaseResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopMakePurchaseResponse): ShopMakePurchaseResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eve_trading_co_proto.MakePurchaseStatus status */ 1:
                    message.status = reader.int32();
                    break;
                case /* eve_trading_co_proto.ShopAppraisal appraisal */ 2:
                    message.appraisal = ShopAppraisal.internalBinaryRead(reader, reader.uint32(), options, message.appraisal);
                    break;
                case /* eve_trading_co_proto.TypeNamingLists type_naming_lists */ 3:
                    message.typeNamingLists = TypeNamingLists.internalBinaryRead(reader, reader.uint32(), options, message.typeNamingLists);
                    break;
                case /* eve_trading_co_proto.AuthResponse auth */ 4:
                    message.auth = AuthResponse.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 5:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopMakePurchaseResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eve_trading_co_proto.MakePurchaseStatus status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        /* eve_trading_co_proto.ShopAppraisal appraisal = 2; */
        if (message.appraisal)
            ShopAppraisal.internalBinaryWrite(message.appraisal, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.TypeNamingLists type_naming_lists = 3; */
        if (message.typeNamingLists)
            TypeNamingLists.internalBinaryWrite(message.typeNamingLists, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.AuthResponse auth = 4; */
        if (message.auth)
            AuthResponse.internalBinaryWrite(message.auth, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 5; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.ShopMakePurchaseResponse
 */
export const ShopMakePurchaseResponse = new ShopMakePurchaseResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDataRequest$Type extends MessageType<UserDataRequest> {
    constructor() {
        super("eve_trading_co_proto.UserDataRequest", [
            { no: 1, name: "auth", kind: "message", T: () => AuthRequest }
        ]);
    }
    create(value?: PartialMessage<UserDataRequest>): UserDataRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UserDataRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserDataRequest): UserDataRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eve_trading_co_proto.AuthRequest auth */ 1:
                    message.auth = AuthRequest.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserDataRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eve_trading_co_proto.AuthRequest auth = 1; */
        if (message.auth)
            AuthRequest.internalBinaryWrite(message.auth, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.UserDataRequest
 */
export const UserDataRequest = new UserDataRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDataResponse$Type extends MessageType<UserDataResponse> {
    constructor() {
        super("eve_trading_co_proto.UserDataResponse", [
            { no: 1, name: "buyback_appraisals", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BuybackAppraisalStatus },
            { no: 2, name: "shop_appraisals", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ShopAppraisalStatus },
            { no: 3, name: "cancelled_purchase", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "made_purchase", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 5, name: "auth", kind: "message", T: () => AuthResponse },
            { no: 6, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<UserDataResponse>): UserDataResponse {
        const message = { buybackAppraisals: [], shopAppraisals: [], cancelledPurchase: 0, madePurchase: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UserDataResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserDataResponse): UserDataResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_trading_co_proto.BuybackAppraisalStatus buyback_appraisals */ 1:
                    message.buybackAppraisals.push(BuybackAppraisalStatus.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated eve_trading_co_proto.ShopAppraisalStatus shop_appraisals */ 2:
                    message.shopAppraisals.push(ShopAppraisalStatus.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int64 cancelled_purchase */ 3:
                    message.cancelledPurchase = reader.int64().toNumber();
                    break;
                case /* int64 made_purchase */ 4:
                    message.madePurchase = reader.int64().toNumber();
                    break;
                case /* eve_trading_co_proto.AuthResponse auth */ 5:
                    message.auth = AuthResponse.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 6:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserDataResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated eve_trading_co_proto.BuybackAppraisalStatus buyback_appraisals = 1; */
        for (let i = 0; i < message.buybackAppraisals.length; i++)
            BuybackAppraisalStatus.internalBinaryWrite(message.buybackAppraisals[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated eve_trading_co_proto.ShopAppraisalStatus shop_appraisals = 2; */
        for (let i = 0; i < message.shopAppraisals.length; i++)
            ShopAppraisalStatus.internalBinaryWrite(message.shopAppraisals[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int64 cancelled_purchase = 3; */
        if (message.cancelledPurchase !== 0)
            writer.tag(3, WireType.Varint).int64(message.cancelledPurchase);
        /* int64 made_purchase = 4; */
        if (message.madePurchase !== 0)
            writer.tag(4, WireType.Varint).int64(message.madePurchase);
        /* eve_trading_co_proto.AuthResponse auth = 5; */
        if (message.auth)
            AuthResponse.internalBinaryWrite(message.auth, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 6; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.UserDataResponse
 */
export const UserDataResponse = new UserDataResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopContractQueueRequest$Type extends MessageType<ShopContractQueueRequest> {
    constructor() {
        super("eve_trading_co_proto.ShopContractQueueRequest", [
            { no: 1, name: "include_items", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "include_code_appraisal", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "include_new_appraisal", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "include_location_info", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "include_type_naming", kind: "message", T: () => IncludeTypeNaming },
            { no: 6, name: "include_location_naming", kind: "message", T: () => IncludeLocationNaming },
            { no: 7, name: "auth", kind: "message", T: () => AuthRequest }
        ]);
    }
    create(value?: PartialMessage<ShopContractQueueRequest>): ShopContractQueueRequest {
        const message = { includeItems: false, includeCodeAppraisal: false, includeNewAppraisal: false, includeLocationInfo: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopContractQueueRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopContractQueueRequest): ShopContractQueueRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool include_items */ 1:
                    message.includeItems = reader.bool();
                    break;
                case /* bool include_code_appraisal */ 2:
                    message.includeCodeAppraisal = reader.bool();
                    break;
                case /* bool include_new_appraisal */ 3:
                    message.includeNewAppraisal = reader.bool();
                    break;
                case /* bool include_location_info */ 4:
                    message.includeLocationInfo = reader.bool();
                    break;
                case /* eve_trading_co_proto.IncludeTypeNaming include_type_naming */ 5:
                    message.includeTypeNaming = IncludeTypeNaming.internalBinaryRead(reader, reader.uint32(), options, message.includeTypeNaming);
                    break;
                case /* eve_trading_co_proto.IncludeLocationNaming include_location_naming */ 6:
                    message.includeLocationNaming = IncludeLocationNaming.internalBinaryRead(reader, reader.uint32(), options, message.includeLocationNaming);
                    break;
                case /* eve_trading_co_proto.AuthRequest auth */ 7:
                    message.auth = AuthRequest.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopContractQueueRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool include_items = 1; */
        if (message.includeItems !== false)
            writer.tag(1, WireType.Varint).bool(message.includeItems);
        /* bool include_code_appraisal = 2; */
        if (message.includeCodeAppraisal !== false)
            writer.tag(2, WireType.Varint).bool(message.includeCodeAppraisal);
        /* bool include_new_appraisal = 3; */
        if (message.includeNewAppraisal !== false)
            writer.tag(3, WireType.Varint).bool(message.includeNewAppraisal);
        /* bool include_location_info = 4; */
        if (message.includeLocationInfo !== false)
            writer.tag(4, WireType.Varint).bool(message.includeLocationInfo);
        /* eve_trading_co_proto.IncludeTypeNaming include_type_naming = 5; */
        if (message.includeTypeNaming)
            IncludeTypeNaming.internalBinaryWrite(message.includeTypeNaming, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.IncludeLocationNaming include_location_naming = 6; */
        if (message.includeLocationNaming)
            IncludeLocationNaming.internalBinaryWrite(message.includeLocationNaming, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.AuthRequest auth = 7; */
        if (message.auth)
            AuthRequest.internalBinaryWrite(message.auth, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.ShopContractQueueRequest
 */
export const ShopContractQueueRequest = new ShopContractQueueRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopContractQueueResponse$Type extends MessageType<ShopContractQueueResponse> {
    constructor() {
        super("eve_trading_co_proto.ShopContractQueueResponse", [
            { no: 1, name: "queue", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ShopContractQueueEntry },
            { no: 2, name: "type_naming_lists", kind: "message", T: () => TypeNamingLists },
            { no: 3, name: "location_naming_maps", kind: "message", T: () => LocationNamingMaps },
            { no: 4, name: "auth", kind: "message", T: () => AuthResponse },
            { no: 5, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<ShopContractQueueResponse>): ShopContractQueueResponse {
        const message = { queue: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopContractQueueResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopContractQueueResponse): ShopContractQueueResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_trading_co_proto.ShopContractQueueEntry queue */ 1:
                    message.queue.push(ShopContractQueueEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* eve_trading_co_proto.TypeNamingLists type_naming_lists */ 2:
                    message.typeNamingLists = TypeNamingLists.internalBinaryRead(reader, reader.uint32(), options, message.typeNamingLists);
                    break;
                case /* eve_trading_co_proto.LocationNamingMaps location_naming_maps */ 3:
                    message.locationNamingMaps = LocationNamingMaps.internalBinaryRead(reader, reader.uint32(), options, message.locationNamingMaps);
                    break;
                case /* eve_trading_co_proto.AuthResponse auth */ 4:
                    message.auth = AuthResponse.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 5:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopContractQueueResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated eve_trading_co_proto.ShopContractQueueEntry queue = 1; */
        for (let i = 0; i < message.queue.length; i++)
            ShopContractQueueEntry.internalBinaryWrite(message.queue[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.TypeNamingLists type_naming_lists = 2; */
        if (message.typeNamingLists)
            TypeNamingLists.internalBinaryWrite(message.typeNamingLists, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.LocationNamingMaps location_naming_maps = 3; */
        if (message.locationNamingMaps)
            LocationNamingMaps.internalBinaryWrite(message.locationNamingMaps, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.AuthResponse auth = 4; */
        if (message.auth)
            AuthResponse.internalBinaryWrite(message.auth, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 5; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.ShopContractQueueResponse
 */
export const ShopContractQueueResponse = new ShopContractQueueResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuybackContractQueueRequest$Type extends MessageType<BuybackContractQueueRequest> {
    constructor() {
        super("eve_trading_co_proto.BuybackContractQueueRequest", [
            { no: 1, name: "include_items", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "include_code_appraisal", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "include_new_appraisal", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "include_location_info", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "include_type_naming", kind: "message", T: () => IncludeTypeNaming },
            { no: 6, name: "include_location_naming", kind: "message", T: () => IncludeLocationNaming },
            { no: 7, name: "auth", kind: "message", T: () => AuthRequest }
        ]);
    }
    create(value?: PartialMessage<BuybackContractQueueRequest>): BuybackContractQueueRequest {
        const message = { includeItems: false, includeCodeAppraisal: false, includeNewAppraisal: false, includeLocationInfo: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BuybackContractQueueRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuybackContractQueueRequest): BuybackContractQueueRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool include_items */ 1:
                    message.includeItems = reader.bool();
                    break;
                case /* bool include_code_appraisal */ 2:
                    message.includeCodeAppraisal = reader.bool();
                    break;
                case /* bool include_new_appraisal */ 3:
                    message.includeNewAppraisal = reader.bool();
                    break;
                case /* bool include_location_info */ 4:
                    message.includeLocationInfo = reader.bool();
                    break;
                case /* eve_trading_co_proto.IncludeTypeNaming include_type_naming */ 5:
                    message.includeTypeNaming = IncludeTypeNaming.internalBinaryRead(reader, reader.uint32(), options, message.includeTypeNaming);
                    break;
                case /* eve_trading_co_proto.IncludeLocationNaming include_location_naming */ 6:
                    message.includeLocationNaming = IncludeLocationNaming.internalBinaryRead(reader, reader.uint32(), options, message.includeLocationNaming);
                    break;
                case /* eve_trading_co_proto.AuthRequest auth */ 7:
                    message.auth = AuthRequest.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BuybackContractQueueRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool include_items = 1; */
        if (message.includeItems !== false)
            writer.tag(1, WireType.Varint).bool(message.includeItems);
        /* bool include_code_appraisal = 2; */
        if (message.includeCodeAppraisal !== false)
            writer.tag(2, WireType.Varint).bool(message.includeCodeAppraisal);
        /* bool include_new_appraisal = 3; */
        if (message.includeNewAppraisal !== false)
            writer.tag(3, WireType.Varint).bool(message.includeNewAppraisal);
        /* bool include_location_info = 4; */
        if (message.includeLocationInfo !== false)
            writer.tag(4, WireType.Varint).bool(message.includeLocationInfo);
        /* eve_trading_co_proto.IncludeTypeNaming include_type_naming = 5; */
        if (message.includeTypeNaming)
            IncludeTypeNaming.internalBinaryWrite(message.includeTypeNaming, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.IncludeLocationNaming include_location_naming = 6; */
        if (message.includeLocationNaming)
            IncludeLocationNaming.internalBinaryWrite(message.includeLocationNaming, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.AuthRequest auth = 7; */
        if (message.auth)
            AuthRequest.internalBinaryWrite(message.auth, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.BuybackContractQueueRequest
 */
export const BuybackContractQueueRequest = new BuybackContractQueueRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuybackContractQueueResponse$Type extends MessageType<BuybackContractQueueResponse> {
    constructor() {
        super("eve_trading_co_proto.BuybackContractQueueResponse", [
            { no: 1, name: "queue", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BuybackContractQueueEntry },
            { no: 2, name: "type_naming_lists", kind: "message", T: () => TypeNamingLists },
            { no: 3, name: "location_naming_maps", kind: "message", T: () => LocationNamingMaps },
            { no: 4, name: "auth", kind: "message", T: () => AuthResponse },
            { no: 5, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<BuybackContractQueueResponse>): BuybackContractQueueResponse {
        const message = { queue: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BuybackContractQueueResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuybackContractQueueResponse): BuybackContractQueueResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_trading_co_proto.BuybackContractQueueEntry queue */ 1:
                    message.queue.push(BuybackContractQueueEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* eve_trading_co_proto.TypeNamingLists type_naming_lists */ 2:
                    message.typeNamingLists = TypeNamingLists.internalBinaryRead(reader, reader.uint32(), options, message.typeNamingLists);
                    break;
                case /* eve_trading_co_proto.LocationNamingMaps location_naming_maps */ 3:
                    message.locationNamingMaps = LocationNamingMaps.internalBinaryRead(reader, reader.uint32(), options, message.locationNamingMaps);
                    break;
                case /* eve_trading_co_proto.AuthResponse auth */ 4:
                    message.auth = AuthResponse.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 5:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BuybackContractQueueResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated eve_trading_co_proto.BuybackContractQueueEntry queue = 1; */
        for (let i = 0; i < message.queue.length; i++)
            BuybackContractQueueEntry.internalBinaryWrite(message.queue[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.TypeNamingLists type_naming_lists = 2; */
        if (message.typeNamingLists)
            TypeNamingLists.internalBinaryWrite(message.typeNamingLists, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.LocationNamingMaps location_naming_maps = 3; */
        if (message.locationNamingMaps)
            LocationNamingMaps.internalBinaryWrite(message.locationNamingMaps, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.AuthResponse auth = 4; */
        if (message.auth)
            AuthResponse.internalBinaryWrite(message.auth, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 5; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.BuybackContractQueueResponse
 */
export const BuybackContractQueueResponse = new BuybackContractQueueResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopCancelPurchaseRequest$Type extends MessageType<ShopCancelPurchaseRequest> {
    constructor() {
        super("eve_trading_co_proto.ShopCancelPurchaseRequest", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "auth", kind: "message", T: () => AuthRequest }
        ]);
    }
    create(value?: PartialMessage<ShopCancelPurchaseRequest>): ShopCancelPurchaseRequest {
        const message = { code: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopCancelPurchaseRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopCancelPurchaseRequest): ShopCancelPurchaseRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* eve_trading_co_proto.AuthRequest auth */ 2:
                    message.auth = AuthRequest.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopCancelPurchaseRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* eve_trading_co_proto.AuthRequest auth = 2; */
        if (message.auth)
            AuthRequest.internalBinaryWrite(message.auth, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.ShopCancelPurchaseRequest
 */
export const ShopCancelPurchaseRequest = new ShopCancelPurchaseRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopCancelPurchaseResponse$Type extends MessageType<ShopCancelPurchaseResponse> {
    constructor() {
        super("eve_trading_co_proto.ShopCancelPurchaseResponse", [
            { no: 1, name: "status", kind: "enum", T: () => ["eve_trading_co_proto.CancelPurchaseStatus", CancelPurchaseStatus] },
            { no: 2, name: "auth", kind: "message", T: () => AuthResponse },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<ShopCancelPurchaseResponse>): ShopCancelPurchaseResponse {
        const message = { status: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopCancelPurchaseResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopCancelPurchaseResponse): ShopCancelPurchaseResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eve_trading_co_proto.CancelPurchaseStatus status */ 1:
                    message.status = reader.int32();
                    break;
                case /* eve_trading_co_proto.AuthResponse auth */ 2:
                    message.auth = AuthResponse.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopCancelPurchaseResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eve_trading_co_proto.CancelPurchaseStatus status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        /* eve_trading_co_proto.AuthResponse auth = 2; */
        if (message.auth)
            AuthResponse.internalBinaryWrite(message.auth, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.ShopCancelPurchaseResponse
 */
export const ShopCancelPurchaseResponse = new ShopCancelPurchaseResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopDeletePurchasesRequest$Type extends MessageType<ShopDeletePurchasesRequest> {
    constructor() {
        super("eve_trading_co_proto.ShopDeletePurchasesRequest", [
            { no: 1, name: "codes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "auth", kind: "message", T: () => AuthRequest }
        ]);
    }
    create(value?: PartialMessage<ShopDeletePurchasesRequest>): ShopDeletePurchasesRequest {
        const message = { codes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopDeletePurchasesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopDeletePurchasesRequest): ShopDeletePurchasesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string codes */ 1:
                    message.codes.push(reader.string());
                    break;
                case /* eve_trading_co_proto.AuthRequest auth */ 2:
                    message.auth = AuthRequest.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopDeletePurchasesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string codes = 1; */
        for (let i = 0; i < message.codes.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.codes[i]);
        /* eve_trading_co_proto.AuthRequest auth = 2; */
        if (message.auth)
            AuthRequest.internalBinaryWrite(message.auth, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.ShopDeletePurchasesRequest
 */
export const ShopDeletePurchasesRequest = new ShopDeletePurchasesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopDeletePurchasesResponse$Type extends MessageType<ShopDeletePurchasesResponse> {
    constructor() {
        super("eve_trading_co_proto.ShopDeletePurchasesResponse", [
            { no: 1, name: "auth", kind: "message", T: () => AuthResponse },
            { no: 2, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<ShopDeletePurchasesResponse>): ShopDeletePurchasesResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopDeletePurchasesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopDeletePurchasesResponse): ShopDeletePurchasesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eve_trading_co_proto.AuthResponse auth */ 1:
                    message.auth = AuthResponse.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 2:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopDeletePurchasesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eve_trading_co_proto.AuthResponse auth = 1; */
        if (message.auth)
            AuthResponse.internalBinaryWrite(message.auth, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 2; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.ShopDeletePurchasesResponse
 */
export const ShopDeletePurchasesResponse = new ShopDeletePurchasesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ParseRequest$Type extends MessageType<ParseRequest> {
    constructor() {
        super("eve_trading_co_proto.ParseRequest", [
            { no: 1, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ParseRequest>): ParseRequest {
        const message = { text: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ParseRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ParseRequest): ParseRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string text */ 1:
                    message.text = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ParseRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string text = 1; */
        if (message.text !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.text);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.ParseRequest
 */
export const ParseRequest = new ParseRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ParseResponse$Type extends MessageType<ParseResponse> {
    constructor() {
        super("eve_trading_co_proto.ParseResponse", [
            { no: 1, name: "known_items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedBasicItem },
            { no: 2, name: "unknown_items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedBasicItem },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<ParseResponse>): ParseResponse {
        const message = { knownItems: [], unknownItems: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ParseResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ParseResponse): ParseResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_trading_co_proto.NamedBasicItem known_items */ 1:
                    message.knownItems.push(NamedBasicItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated eve_trading_co_proto.NamedBasicItem unknown_items */ 2:
                    message.unknownItems.push(NamedBasicItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ParseResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated eve_trading_co_proto.NamedBasicItem known_items = 1; */
        for (let i = 0; i < message.knownItems.length; i++)
            NamedBasicItem.internalBinaryWrite(message.knownItems[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated eve_trading_co_proto.NamedBasicItem unknown_items = 2; */
        for (let i = 0; i < message.unknownItems.length; i++)
            NamedBasicItem.internalBinaryWrite(message.unknownItems[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.ParseResponse
 */
export const ParseResponse = new ParseResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SDETypeDataRequest$Type extends MessageType<SDETypeDataRequest> {
    constructor() {
        super("eve_trading_co_proto.SDETypeDataRequest", []);
    }
    create(value?: PartialMessage<SDETypeDataRequest>): SDETypeDataRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SDETypeDataRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SDETypeDataRequest): SDETypeDataRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SDETypeDataRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.SDETypeDataRequest
 */
export const SDETypeDataRequest = new SDETypeDataRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SDETypeDataResponse$Type extends MessageType<SDETypeDataResponse> {
    constructor() {
        super("eve_trading_co_proto.SDETypeDataResponse", [
            { no: 1, name: "types", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<SDETypeDataResponse>): SDETypeDataResponse {
        const message = { types: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SDETypeDataResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SDETypeDataResponse): SDETypeDataResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 types */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.types.push(reader.int32());
                    else
                        message.types.push(reader.int32());
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 2:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SDETypeDataResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 types = 1; */
        if (message.types.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.types.length; i++)
                writer.int32(message.types[i]);
            writer.join();
        }
        /* eve_trading_co_proto.ErrorResponse error = 2; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.SDETypeDataResponse
 */
export const SDETypeDataResponse = new SDETypeDataResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NamedSDETypeDataRequest$Type extends MessageType<NamedSDETypeDataRequest> {
    constructor() {
        super("eve_trading_co_proto.NamedSDETypeDataRequest", []);
    }
    create(value?: PartialMessage<NamedSDETypeDataRequest>): NamedSDETypeDataRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NamedSDETypeDataRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NamedSDETypeDataRequest): NamedSDETypeDataRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: NamedSDETypeDataRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.NamedSDETypeDataRequest
 */
export const NamedSDETypeDataRequest = new NamedSDETypeDataRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NamedSDETypeDataResponse$Type extends MessageType<NamedSDETypeDataResponse> {
    constructor() {
        super("eve_trading_co_proto.NamedSDETypeDataResponse", [
            { no: 1, name: "types", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedType },
            { no: 2, name: "type_naming_lists", kind: "message", T: () => TypeNamingLists },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<NamedSDETypeDataResponse>): NamedSDETypeDataResponse {
        const message = { types: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NamedSDETypeDataResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NamedSDETypeDataResponse): NamedSDETypeDataResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_trading_co_proto.NamedType types */ 1:
                    message.types.push(NamedType.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* eve_trading_co_proto.TypeNamingLists type_naming_lists */ 2:
                    message.typeNamingLists = TypeNamingLists.internalBinaryRead(reader, reader.uint32(), options, message.typeNamingLists);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NamedSDETypeDataResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated eve_trading_co_proto.NamedType types = 1; */
        for (let i = 0; i < message.types.length; i++)
            NamedType.internalBinaryWrite(message.types[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.TypeNamingLists type_naming_lists = 2; */
        if (message.typeNamingLists)
            TypeNamingLists.internalBinaryWrite(message.typeNamingLists, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.NamedSDETypeDataResponse
 */
export const NamedSDETypeDataResponse = new NamedSDETypeDataResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopLocation$Type extends MessageType<ShopLocation> {
    constructor() {
        super("eve_trading_co_proto.ShopLocation", [
            { no: 1, name: "location_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "location_info", kind: "message", T: () => LocationInfo }
        ]);
    }
    create(value?: PartialMessage<ShopLocation>): ShopLocation {
        const message = { locationId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopLocation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopLocation): ShopLocation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 location_id */ 1:
                    message.locationId = reader.int64().toNumber();
                    break;
                case /* eve_trading_co_proto.LocationInfo location_info */ 2:
                    message.locationInfo = LocationInfo.internalBinaryRead(reader, reader.uint32(), options, message.locationInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopLocation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 location_id = 1; */
        if (message.locationId !== 0)
            writer.tag(1, WireType.Varint).int64(message.locationId);
        /* eve_trading_co_proto.LocationInfo location_info = 2; */
        if (message.locationInfo)
            LocationInfo.internalBinaryWrite(message.locationInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.ShopLocation
 */
export const ShopLocation = new ShopLocation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopLocationsRequest$Type extends MessageType<ShopLocationsRequest> {
    constructor() {
        super("eve_trading_co_proto.ShopLocationsRequest", [
            { no: 1, name: "include_location_info", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "include_location_naming", kind: "message", T: () => IncludeLocationNaming }
        ]);
    }
    create(value?: PartialMessage<ShopLocationsRequest>): ShopLocationsRequest {
        const message = { includeLocationInfo: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopLocationsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopLocationsRequest): ShopLocationsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool include_location_info */ 1:
                    message.includeLocationInfo = reader.bool();
                    break;
                case /* eve_trading_co_proto.IncludeLocationNaming include_location_naming */ 2:
                    message.includeLocationNaming = IncludeLocationNaming.internalBinaryRead(reader, reader.uint32(), options, message.includeLocationNaming);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopLocationsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool include_location_info = 1; */
        if (message.includeLocationInfo !== false)
            writer.tag(1, WireType.Varint).bool(message.includeLocationInfo);
        /* eve_trading_co_proto.IncludeLocationNaming include_location_naming = 2; */
        if (message.includeLocationNaming)
            IncludeLocationNaming.internalBinaryWrite(message.includeLocationNaming, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.ShopLocationsRequest
 */
export const ShopLocationsRequest = new ShopLocationsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopLocationsResponse$Type extends MessageType<ShopLocationsResponse> {
    constructor() {
        super("eve_trading_co_proto.ShopLocationsResponse", [
            { no: 1, name: "locations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ShopLocation },
            { no: 2, name: "location_naming_maps", kind: "message", T: () => LocationNamingMaps },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<ShopLocationsResponse>): ShopLocationsResponse {
        const message = { locations: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopLocationsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopLocationsResponse): ShopLocationsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_trading_co_proto.ShopLocation locations */ 1:
                    message.locations.push(ShopLocation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* eve_trading_co_proto.LocationNamingMaps location_naming_maps */ 2:
                    message.locationNamingMaps = LocationNamingMaps.internalBinaryRead(reader, reader.uint32(), options, message.locationNamingMaps);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopLocationsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated eve_trading_co_proto.ShopLocation locations = 1; */
        for (let i = 0; i < message.locations.length; i++)
            ShopLocation.internalBinaryWrite(message.locations[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.LocationNamingMaps location_naming_maps = 2; */
        if (message.locationNamingMaps)
            LocationNamingMaps.internalBinaryWrite(message.locationNamingMaps, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.ShopLocationsResponse
 */
export const ShopLocationsResponse = new ShopLocationsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class System$Type extends MessageType<System> {
    constructor() {
        super("eve_trading_co_proto.System", [
            { no: 1, name: "system_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "region_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<System>): System {
        const message = { systemId: 0, regionId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<System>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: System): System {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 system_id */ 1:
                    message.systemId = reader.int32();
                    break;
                case /* int32 region_id */ 2:
                    message.regionId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: System, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 system_id = 1; */
        if (message.systemId !== 0)
            writer.tag(1, WireType.Varint).int32(message.systemId);
        /* int32 region_id = 2; */
        if (message.regionId !== 0)
            writer.tag(2, WireType.Varint).int32(message.regionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.System
 */
export const System = new System$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuybackSystemsRequest$Type extends MessageType<BuybackSystemsRequest> {
    constructor() {
        super("eve_trading_co_proto.BuybackSystemsRequest", [
            { no: 1, name: "include_location_naming", kind: "message", T: () => IncludeLocationNaming }
        ]);
    }
    create(value?: PartialMessage<BuybackSystemsRequest>): BuybackSystemsRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BuybackSystemsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuybackSystemsRequest): BuybackSystemsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eve_trading_co_proto.IncludeLocationNaming include_location_naming */ 1:
                    message.includeLocationNaming = IncludeLocationNaming.internalBinaryRead(reader, reader.uint32(), options, message.includeLocationNaming);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BuybackSystemsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eve_trading_co_proto.IncludeLocationNaming include_location_naming = 1; */
        if (message.includeLocationNaming)
            IncludeLocationNaming.internalBinaryWrite(message.includeLocationNaming, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.BuybackSystemsRequest
 */
export const BuybackSystemsRequest = new BuybackSystemsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuybackSystemsResponse$Type extends MessageType<BuybackSystemsResponse> {
    constructor() {
        super("eve_trading_co_proto.BuybackSystemsResponse", [
            { no: 1, name: "systems", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => System },
            { no: 2, name: "location_naming_maps", kind: "message", T: () => LocationNamingMaps },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<BuybackSystemsResponse>): BuybackSystemsResponse {
        const message = { systems: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BuybackSystemsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuybackSystemsResponse): BuybackSystemsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_trading_co_proto.System systems */ 1:
                    message.systems.push(System.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* eve_trading_co_proto.LocationNamingMaps location_naming_maps */ 2:
                    message.locationNamingMaps = LocationNamingMaps.internalBinaryRead(reader, reader.uint32(), options, message.locationNamingMaps);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BuybackSystemsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated eve_trading_co_proto.System systems = 1; */
        for (let i = 0; i < message.systems.length; i++)
            System.internalBinaryWrite(message.systems[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.LocationNamingMaps location_naming_maps = 2; */
        if (message.locationNamingMaps)
            LocationNamingMaps.internalBinaryWrite(message.locationNamingMaps, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.BuybackSystemsResponse
 */
export const BuybackSystemsResponse = new BuybackSystemsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopPurchaseQueueRequest$Type extends MessageType<ShopPurchaseQueueRequest> {
    constructor() {
        super("eve_trading_co_proto.ShopPurchaseQueueRequest", [
            { no: 1, name: "include_code_appraisal", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "include_new_appraisal", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "include_type_naming", kind: "message", T: () => IncludeTypeNaming },
            { no: 4, name: "auth", kind: "message", T: () => AuthRequest }
        ]);
    }
    create(value?: PartialMessage<ShopPurchaseQueueRequest>): ShopPurchaseQueueRequest {
        const message = { includeCodeAppraisal: false, includeNewAppraisal: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopPurchaseQueueRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopPurchaseQueueRequest): ShopPurchaseQueueRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool include_code_appraisal */ 1:
                    message.includeCodeAppraisal = reader.bool();
                    break;
                case /* bool include_new_appraisal */ 2:
                    message.includeNewAppraisal = reader.bool();
                    break;
                case /* eve_trading_co_proto.IncludeTypeNaming include_type_naming */ 3:
                    message.includeTypeNaming = IncludeTypeNaming.internalBinaryRead(reader, reader.uint32(), options, message.includeTypeNaming);
                    break;
                case /* eve_trading_co_proto.AuthRequest auth */ 4:
                    message.auth = AuthRequest.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopPurchaseQueueRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool include_code_appraisal = 1; */
        if (message.includeCodeAppraisal !== false)
            writer.tag(1, WireType.Varint).bool(message.includeCodeAppraisal);
        /* bool include_new_appraisal = 2; */
        if (message.includeNewAppraisal !== false)
            writer.tag(2, WireType.Varint).bool(message.includeNewAppraisal);
        /* eve_trading_co_proto.IncludeTypeNaming include_type_naming = 3; */
        if (message.includeTypeNaming)
            IncludeTypeNaming.internalBinaryWrite(message.includeTypeNaming, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.AuthRequest auth = 4; */
        if (message.auth)
            AuthRequest.internalBinaryWrite(message.auth, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.ShopPurchaseQueueRequest
 */
export const ShopPurchaseQueueRequest = new ShopPurchaseQueueRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopPurchaseQueueResponse$Type extends MessageType<ShopPurchaseQueueResponse> {
    constructor() {
        super("eve_trading_co_proto.ShopPurchaseQueueResponse", [
            { no: 1, name: "queue", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PurchaseQueueEntry },
            { no: 2, name: "type_naming_lists", kind: "message", T: () => TypeNamingLists },
            { no: 3, name: "auth", kind: "message", T: () => AuthResponse },
            { no: 4, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<ShopPurchaseQueueResponse>): ShopPurchaseQueueResponse {
        const message = { queue: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopPurchaseQueueResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopPurchaseQueueResponse): ShopPurchaseQueueResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_trading_co_proto.PurchaseQueueEntry queue */ 1:
                    message.queue.push(PurchaseQueueEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* eve_trading_co_proto.TypeNamingLists type_naming_lists */ 2:
                    message.typeNamingLists = TypeNamingLists.internalBinaryRead(reader, reader.uint32(), options, message.typeNamingLists);
                    break;
                case /* eve_trading_co_proto.AuthResponse auth */ 3:
                    message.auth = AuthResponse.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 4:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopPurchaseQueueResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated eve_trading_co_proto.PurchaseQueueEntry queue = 1; */
        for (let i = 0; i < message.queue.length; i++)
            PurchaseQueueEntry.internalBinaryWrite(message.queue[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.TypeNamingLists type_naming_lists = 2; */
        if (message.typeNamingLists)
            TypeNamingLists.internalBinaryWrite(message.typeNamingLists, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.AuthResponse auth = 3; */
        if (message.auth)
            AuthResponse.internalBinaryWrite(message.auth, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 4; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.ShopPurchaseQueueResponse
 */
export const ShopPurchaseQueueResponse = new ShopPurchaseQueueResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EsiAppLoginRequest$Type extends MessageType<EsiAppLoginRequest> {
    constructor() {
        super("eve_trading_co_proto.EsiAppLoginRequest", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "app", kind: "enum", T: () => ["eve_trading_co_proto.EsiApp", EsiApp] },
            { no: 3, name: "auth", kind: "message", T: () => AuthRequest }
        ]);
    }
    create(value?: PartialMessage<EsiAppLoginRequest>): EsiAppLoginRequest {
        const message = { code: "", app: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EsiAppLoginRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EsiAppLoginRequest): EsiAppLoginRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* eve_trading_co_proto.EsiApp app */ 2:
                    message.app = reader.int32();
                    break;
                case /* eve_trading_co_proto.AuthRequest auth */ 3:
                    message.auth = AuthRequest.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EsiAppLoginRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* eve_trading_co_proto.EsiApp app = 2; */
        if (message.app !== 0)
            writer.tag(2, WireType.Varint).int32(message.app);
        /* eve_trading_co_proto.AuthRequest auth = 3; */
        if (message.auth)
            AuthRequest.internalBinaryWrite(message.auth, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.EsiAppLoginRequest
 */
export const EsiAppLoginRequest = new EsiAppLoginRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EsiAppLoginResponse$Type extends MessageType<EsiAppLoginResponse> {
    constructor() {
        super("eve_trading_co_proto.EsiAppLoginResponse", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "jwt", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "auth", kind: "message", T: () => AuthResponse },
            { no: 4, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<EsiAppLoginResponse>): EsiAppLoginResponse {
        const message = { token: "", jwt: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EsiAppLoginResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EsiAppLoginResponse): EsiAppLoginResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                case /* string jwt */ 2:
                    message.jwt = reader.string();
                    break;
                case /* eve_trading_co_proto.AuthResponse auth */ 3:
                    message.auth = AuthResponse.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 4:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EsiAppLoginResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        /* string jwt = 2; */
        if (message.jwt !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.jwt);
        /* eve_trading_co_proto.AuthResponse auth = 3; */
        if (message.auth)
            AuthResponse.internalBinaryWrite(message.auth, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 4; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.EsiAppLoginResponse
 */
export const EsiAppLoginResponse = new EsiAppLoginResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SDESystem$Type extends MessageType<SDESystem> {
    constructor() {
        super("eve_trading_co_proto.SDESystem", [
            { no: 1, name: "system_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "region_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SDESystem>): SDESystem {
        const message = { systemId: 0, regionId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SDESystem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SDESystem): SDESystem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 system_id */ 1:
                    message.systemId = reader.int32();
                    break;
                case /* int32 region_id */ 2:
                    message.regionId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SDESystem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 system_id = 1; */
        if (message.systemId !== 0)
            writer.tag(1, WireType.Varint).int32(message.systemId);
        /* int32 region_id = 2; */
        if (message.regionId !== 0)
            writer.tag(2, WireType.Varint).int32(message.regionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.SDESystem
 */
export const SDESystem = new SDESystem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SDESystemsRequest$Type extends MessageType<SDESystemsRequest> {
    constructor() {
        super("eve_trading_co_proto.SDESystemsRequest", [
            { no: 1, name: "include_location_naming", kind: "message", T: () => IncludeLocationNaming }
        ]);
    }
    create(value?: PartialMessage<SDESystemsRequest>): SDESystemsRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SDESystemsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SDESystemsRequest): SDESystemsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eve_trading_co_proto.IncludeLocationNaming include_location_naming */ 1:
                    message.includeLocationNaming = IncludeLocationNaming.internalBinaryRead(reader, reader.uint32(), options, message.includeLocationNaming);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SDESystemsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eve_trading_co_proto.IncludeLocationNaming include_location_naming = 1; */
        if (message.includeLocationNaming)
            IncludeLocationNaming.internalBinaryWrite(message.includeLocationNaming, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.SDESystemsRequest
 */
export const SDESystemsRequest = new SDESystemsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SDESystemsResponse$Type extends MessageType<SDESystemsResponse> {
    constructor() {
        super("eve_trading_co_proto.SDESystemsResponse", [
            { no: 1, name: "systems", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => System },
            { no: 2, name: "location_naming_maps", kind: "message", T: () => LocationNamingMaps },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<SDESystemsResponse>): SDESystemsResponse {
        const message = { systems: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SDESystemsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SDESystemsResponse): SDESystemsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eve_trading_co_proto.System systems */ 1:
                    message.systems.push(System.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* eve_trading_co_proto.LocationNamingMaps location_naming_maps */ 2:
                    message.locationNamingMaps = LocationNamingMaps.internalBinaryRead(reader, reader.uint32(), options, message.locationNamingMaps);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SDESystemsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated eve_trading_co_proto.System systems = 1; */
        for (let i = 0; i < message.systems.length; i++)
            System.internalBinaryWrite(message.systems[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.LocationNamingMaps location_naming_maps = 2; */
        if (message.locationNamingMaps)
            LocationNamingMaps.internalBinaryWrite(message.locationNamingMaps, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.SDESystemsResponse
 */
export const SDESystemsResponse = new SDESystemsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgGetBuybackBundleKeysRequest$Type extends MessageType<CfgGetBuybackBundleKeysRequest> {
    constructor() {
        super("eve_trading_co_proto.CfgGetBuybackBundleKeysRequest", [
            { no: 1, name: "auth", kind: "message", T: () => AuthRequest }
        ]);
    }
    create(value?: PartialMessage<CfgGetBuybackBundleKeysRequest>): CfgGetBuybackBundleKeysRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgGetBuybackBundleKeysRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgGetBuybackBundleKeysRequest): CfgGetBuybackBundleKeysRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eve_trading_co_proto.AuthRequest auth */ 1:
                    message.auth = AuthRequest.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgGetBuybackBundleKeysRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eve_trading_co_proto.AuthRequest auth = 1; */
        if (message.auth)
            AuthRequest.internalBinaryWrite(message.auth, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgGetBuybackBundleKeysRequest
 */
export const CfgGetBuybackBundleKeysRequest = new CfgGetBuybackBundleKeysRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgGetBuybackBundleKeysResponse$Type extends MessageType<CfgGetBuybackBundleKeysResponse> {
    constructor() {
        super("eve_trading_co_proto.CfgGetBuybackBundleKeysResponse", [
            { no: 1, name: "bundle_keys", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "auth", kind: "message", T: () => AuthResponse },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<CfgGetBuybackBundleKeysResponse>): CfgGetBuybackBundleKeysResponse {
        const message = { bundleKeys: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgGetBuybackBundleKeysResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgGetBuybackBundleKeysResponse): CfgGetBuybackBundleKeysResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string bundle_keys */ 1:
                    message.bundleKeys.push(reader.string());
                    break;
                case /* eve_trading_co_proto.AuthResponse auth */ 2:
                    message.auth = AuthResponse.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgGetBuybackBundleKeysResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string bundle_keys = 1; */
        for (let i = 0; i < message.bundleKeys.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.bundleKeys[i]);
        /* eve_trading_co_proto.AuthResponse auth = 2; */
        if (message.auth)
            AuthResponse.internalBinaryWrite(message.auth, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgGetBuybackBundleKeysResponse
 */
export const CfgGetBuybackBundleKeysResponse = new CfgGetBuybackBundleKeysResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgGetShopBundleKeysRequest$Type extends MessageType<CfgGetShopBundleKeysRequest> {
    constructor() {
        super("eve_trading_co_proto.CfgGetShopBundleKeysRequest", [
            { no: 1, name: "auth", kind: "message", T: () => AuthRequest }
        ]);
    }
    create(value?: PartialMessage<CfgGetShopBundleKeysRequest>): CfgGetShopBundleKeysRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgGetShopBundleKeysRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgGetShopBundleKeysRequest): CfgGetShopBundleKeysRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eve_trading_co_proto.AuthRequest auth */ 1:
                    message.auth = AuthRequest.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgGetShopBundleKeysRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eve_trading_co_proto.AuthRequest auth = 1; */
        if (message.auth)
            AuthRequest.internalBinaryWrite(message.auth, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgGetShopBundleKeysRequest
 */
export const CfgGetShopBundleKeysRequest = new CfgGetShopBundleKeysRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgGetShopBundleKeysResponse$Type extends MessageType<CfgGetShopBundleKeysResponse> {
    constructor() {
        super("eve_trading_co_proto.CfgGetShopBundleKeysResponse", [
            { no: 1, name: "bundle_keys", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "auth", kind: "message", T: () => AuthResponse },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<CfgGetShopBundleKeysResponse>): CfgGetShopBundleKeysResponse {
        const message = { bundleKeys: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgGetShopBundleKeysResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgGetShopBundleKeysResponse): CfgGetShopBundleKeysResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string bundle_keys */ 1:
                    message.bundleKeys.push(reader.string());
                    break;
                case /* eve_trading_co_proto.AuthResponse auth */ 2:
                    message.auth = AuthResponse.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgGetShopBundleKeysResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string bundle_keys = 1; */
        for (let i = 0; i < message.bundleKeys.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.bundleKeys[i]);
        /* eve_trading_co_proto.AuthResponse auth = 2; */
        if (message.auth)
            AuthResponse.internalBinaryWrite(message.auth, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgGetShopBundleKeysResponse
 */
export const CfgGetShopBundleKeysResponse = new CfgGetShopBundleKeysResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgGetMarketNamesRequest$Type extends MessageType<CfgGetMarketNamesRequest> {
    constructor() {
        super("eve_trading_co_proto.CfgGetMarketNamesRequest", [
            { no: 1, name: "auth", kind: "message", T: () => AuthRequest }
        ]);
    }
    create(value?: PartialMessage<CfgGetMarketNamesRequest>): CfgGetMarketNamesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgGetMarketNamesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgGetMarketNamesRequest): CfgGetMarketNamesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eve_trading_co_proto.AuthRequest auth */ 1:
                    message.auth = AuthRequest.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgGetMarketNamesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eve_trading_co_proto.AuthRequest auth = 1; */
        if (message.auth)
            AuthRequest.internalBinaryWrite(message.auth, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgGetMarketNamesRequest
 */
export const CfgGetMarketNamesRequest = new CfgGetMarketNamesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgGetMarketNamesResponse$Type extends MessageType<CfgGetMarketNamesResponse> {
    constructor() {
        super("eve_trading_co_proto.CfgGetMarketNamesResponse", [
            { no: 1, name: "market_names", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "auth", kind: "message", T: () => AuthResponse },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<CfgGetMarketNamesResponse>): CfgGetMarketNamesResponse {
        const message = { marketNames: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgGetMarketNamesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgGetMarketNamesResponse): CfgGetMarketNamesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string market_names */ 1:
                    message.marketNames.push(reader.string());
                    break;
                case /* eve_trading_co_proto.AuthResponse auth */ 2:
                    message.auth = AuthResponse.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgGetMarketNamesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string market_names = 1; */
        for (let i = 0; i < message.marketNames.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.marketNames[i]);
        /* eve_trading_co_proto.AuthResponse auth = 2; */
        if (message.auth)
            AuthResponse.internalBinaryWrite(message.auth, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CfgGetMarketNamesResponse
 */
export const CfgGetMarketNamesResponse = new CfgGetMarketNamesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IsAdminRequest$Type extends MessageType<IsAdminRequest> {
    constructor() {
        super("eve_trading_co_proto.IsAdminRequest", [
            { no: 1, name: "auth", kind: "message", T: () => AuthRequest }
        ]);
    }
    create(value?: PartialMessage<IsAdminRequest>): IsAdminRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IsAdminRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IsAdminRequest): IsAdminRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eve_trading_co_proto.AuthRequest auth */ 1:
                    message.auth = AuthRequest.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IsAdminRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eve_trading_co_proto.AuthRequest auth = 1; */
        if (message.auth)
            AuthRequest.internalBinaryWrite(message.auth, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.IsAdminRequest
 */
export const IsAdminRequest = new IsAdminRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IsAdminResponse$Type extends MessageType<IsAdminResponse> {
    constructor() {
        super("eve_trading_co_proto.IsAdminResponse", [
            { no: 1, name: "is_admin", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "auth", kind: "message", T: () => AuthResponse },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<IsAdminResponse>): IsAdminResponse {
        const message = { isAdmin: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IsAdminResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IsAdminResponse): IsAdminResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_admin */ 1:
                    message.isAdmin = reader.bool();
                    break;
                case /* eve_trading_co_proto.AuthResponse auth */ 2:
                    message.auth = AuthResponse.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IsAdminResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_admin = 1; */
        if (message.isAdmin !== false)
            writer.tag(1, WireType.Varint).bool(message.isAdmin);
        /* eve_trading_co_proto.AuthResponse auth = 2; */
        if (message.auth)
            AuthResponse.internalBinaryWrite(message.auth, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eve_trading_co_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.IsAdminResponse
 */
export const IsAdminResponse = new IsAdminResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CharacterInfoRequest$Type extends MessageType<CharacterInfoRequest> {
    constructor() {
        super("eve_trading_co_proto.CharacterInfoRequest", [
            { no: 1, name: "character_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CharacterInfoRequest>): CharacterInfoRequest {
        const message = { characterId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CharacterInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CharacterInfoRequest): CharacterInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 character_id */ 1:
                    message.characterId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CharacterInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 character_id = 1; */
        if (message.characterId !== 0)
            writer.tag(1, WireType.Varint).int32(message.characterId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CharacterInfoRequest
 */
export const CharacterInfoRequest = new CharacterInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CharacterInfoResponse$Type extends MessageType<CharacterInfoResponse> {
    constructor() {
        super("eve_trading_co_proto.CharacterInfoResponse", [
            { no: 1, name: "character_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "corporation_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "alliance_id", kind: "message", T: () => OptionalInt32 },
            { no: 4, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<CharacterInfoResponse>): CharacterInfoResponse {
        const message = { characterId: 0, corporationId: 0, name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CharacterInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CharacterInfoResponse): CharacterInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 character_id */ 1:
                    message.characterId = reader.int32();
                    break;
                case /* int32 corporation_id */ 2:
                    message.corporationId = reader.int32();
                    break;
                case /* eve_trading_co_proto.OptionalInt32 alliance_id */ 3:
                    message.allianceId = OptionalInt32.internalBinaryRead(reader, reader.uint32(), options, message.allianceId);
                    break;
                case /* string name */ 4:
                    message.name = reader.string();
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 5:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CharacterInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 character_id = 1; */
        if (message.characterId !== 0)
            writer.tag(1, WireType.Varint).int32(message.characterId);
        /* int32 corporation_id = 2; */
        if (message.corporationId !== 0)
            writer.tag(2, WireType.Varint).int32(message.corporationId);
        /* eve_trading_co_proto.OptionalInt32 alliance_id = 3; */
        if (message.allianceId)
            OptionalInt32.internalBinaryWrite(message.allianceId, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string name = 4; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        /* eve_trading_co_proto.ErrorResponse error = 5; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CharacterInfoResponse
 */
export const CharacterInfoResponse = new CharacterInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CorporationInfoRequest$Type extends MessageType<CorporationInfoRequest> {
    constructor() {
        super("eve_trading_co_proto.CorporationInfoRequest", [
            { no: 1, name: "corporation_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CorporationInfoRequest>): CorporationInfoRequest {
        const message = { corporationId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CorporationInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CorporationInfoRequest): CorporationInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 corporation_id */ 1:
                    message.corporationId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CorporationInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 corporation_id = 1; */
        if (message.corporationId !== 0)
            writer.tag(1, WireType.Varint).int32(message.corporationId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CorporationInfoRequest
 */
export const CorporationInfoRequest = new CorporationInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CorporationInfoResponse$Type extends MessageType<CorporationInfoResponse> {
    constructor() {
        super("eve_trading_co_proto.CorporationInfoResponse", [
            { no: 1, name: "corporation_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "alliance_id", kind: "message", T: () => OptionalInt32 },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<CorporationInfoResponse>): CorporationInfoResponse {
        const message = { corporationId: 0, name: "", ticker: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CorporationInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CorporationInfoResponse): CorporationInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 corporation_id */ 1:
                    message.corporationId = reader.int32();
                    break;
                case /* eve_trading_co_proto.OptionalInt32 alliance_id */ 2:
                    message.allianceId = OptionalInt32.internalBinaryRead(reader, reader.uint32(), options, message.allianceId);
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string ticker */ 4:
                    message.ticker = reader.string();
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 5:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CorporationInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 corporation_id = 1; */
        if (message.corporationId !== 0)
            writer.tag(1, WireType.Varint).int32(message.corporationId);
        /* eve_trading_co_proto.OptionalInt32 alliance_id = 2; */
        if (message.allianceId)
            OptionalInt32.internalBinaryWrite(message.allianceId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string ticker = 4; */
        if (message.ticker !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.ticker);
        /* eve_trading_co_proto.ErrorResponse error = 5; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.CorporationInfoResponse
 */
export const CorporationInfoResponse = new CorporationInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AllianceInfoRequest$Type extends MessageType<AllianceInfoRequest> {
    constructor() {
        super("eve_trading_co_proto.AllianceInfoRequest", [
            { no: 1, name: "alliance_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AllianceInfoRequest>): AllianceInfoRequest {
        const message = { allianceId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AllianceInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AllianceInfoRequest): AllianceInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 alliance_id */ 1:
                    message.allianceId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AllianceInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 alliance_id = 1; */
        if (message.allianceId !== 0)
            writer.tag(1, WireType.Varint).int32(message.allianceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.AllianceInfoRequest
 */
export const AllianceInfoRequest = new AllianceInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AllianceInfoResponse$Type extends MessageType<AllianceInfoResponse> {
    constructor() {
        super("eve_trading_co_proto.AllianceInfoResponse", [
            { no: 1, name: "alliance_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<AllianceInfoResponse>): AllianceInfoResponse {
        const message = { allianceId: 0, name: "", ticker: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AllianceInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AllianceInfoResponse): AllianceInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 alliance_id */ 1:
                    message.allianceId = reader.int32();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string ticker */ 3:
                    message.ticker = reader.string();
                    break;
                case /* eve_trading_co_proto.ErrorResponse error */ 4:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AllianceInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 alliance_id = 1; */
        if (message.allianceId !== 0)
            writer.tag(1, WireType.Varint).int32(message.allianceId);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string ticker = 3; */
        if (message.ticker !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.ticker);
        /* eve_trading_co_proto.ErrorResponse error = 4; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eve_trading_co_proto.AllianceInfoResponse
 */
export const AllianceInfoResponse = new AllianceInfoResponse$Type();
/**
 * @generated ServiceType for protobuf service eve_trading_co_proto.EveTradingCo
 */
export const EveTradingCo = new ServiceType("eve_trading_co_proto.EveTradingCo", [
    { name: "SDETypeData", options: {}, I: SDETypeDataRequest, O: SDETypeDataResponse },
    { name: "NamedSDETypeData", options: {}, I: NamedSDETypeDataRequest, O: NamedSDETypeDataResponse },
    { name: "ShopLocations", options: {}, I: ShopLocationsRequest, O: ShopLocationsResponse },
    { name: "BuybackSystems", options: {}, I: BuybackSystemsRequest, O: BuybackSystemsResponse },
    { name: "SDESystems", options: {}, I: SDESystemsRequest, O: SDESystemsResponse },
    { name: "IsAdmin", options: {}, I: IsAdminRequest, O: IsAdminResponse },
    { name: "ShopPurchaseQueue", options: {}, I: ShopPurchaseQueueRequest, O: ShopPurchaseQueueResponse },
    { name: "ShopContractQueue", options: {}, I: ShopContractQueueRequest, O: ShopContractQueueResponse },
    { name: "BuybackContractQueue", options: {}, I: BuybackContractQueueRequest, O: BuybackContractQueueResponse },
    { name: "CfgGetAuthList", options: {}, I: CfgGetAuthListRequest, O: CfgGetAuthListResponse },
    { name: "CfgGetBuybackSystemTypeMapsBuilder", options: {}, I: CfgGetBuybackSystemTypeMapsBuilderRequest, O: CfgGetBuybackSystemTypeMapsBuilderResponse },
    { name: "CfgGetShopLocationTypeMapsBuilder", options: {}, I: CfgGetShopLocationTypeMapsBuilderRequest, O: CfgGetShopLocationTypeMapsBuilderResponse },
    { name: "CfgGetBuybackSystems", options: {}, I: CfgGetBuybackSystemsRequest, O: CfgGetBuybackSystemsResponse },
    { name: "CfgGetShopLocations", options: {}, I: CfgGetShopLocationsRequest, O: CfgGetShopLocationsResponse },
    { name: "CfgGetMarkets", options: {}, I: CfgGetMarketsRequest, O: CfgGetMarketsResponse },
    { name: "CfgGetMarketNames", options: {}, I: CfgGetMarketNamesRequest, O: CfgGetMarketNamesResponse },
    { name: "CfgGetBuybackBundleKeys", options: {}, I: CfgGetBuybackBundleKeysRequest, O: CfgGetBuybackBundleKeysResponse },
    { name: "CfgGetShopBundleKeys", options: {}, I: CfgGetShopBundleKeysRequest, O: CfgGetShopBundleKeysResponse },
    { name: "CfgSetAuthList", options: {}, I: CfgSetAuthListRequest, O: CfgSetAuthListResponse },
    { name: "CfgMergeBuybackSystemTypeMapsBuilder", options: {}, I: CfgMergeBuybackSystemTypeMapsBuilderRequest, O: CfgMergeBuybackSystemTypeMapsBuilderResponse },
    { name: "CfgMergeShopLocationTypeMapsBuilder", options: {}, I: CfgMergeShopLocationTypeMapsBuilderRequest, O: CfgMergeShopLocationTypeMapsBuilderResponse },
    { name: "CfgMergeBuybackSystems", options: {}, I: CfgMergeBuybackSystemsRequest, O: CfgMergeBuybackSystemsResponse },
    { name: "CfgMergeShopLocations", options: {}, I: CfgMergeShopLocationsRequest, O: CfgMergeShopLocationsResponse },
    { name: "CfgMergeMarkets", options: {}, I: CfgMergeMarketsRequest, O: CfgMergeMarketsResponse },
    { name: "ShopDeletePurchases", options: {}, I: ShopDeletePurchasesRequest, O: ShopDeletePurchasesResponse },
    { name: "EsiAppLogin", options: {}, I: EsiAppLoginRequest, O: EsiAppLoginResponse },
    { name: "CharacterInfo", options: {}, I: CharacterInfoRequest, O: CharacterInfoResponse },
    { name: "CorporationInfo", options: {}, I: CorporationInfoRequest, O: CorporationInfoResponse },
    { name: "AllianceInfo", options: {}, I: AllianceInfoRequest, O: AllianceInfoResponse },
    { name: "Parse", options: {}, I: ParseRequest, O: ParseResponse },
    { name: "NewBuybackAppraisal", options: {}, I: NewBuybackAppraisalRequest, O: NewBuybackAppraisalResponse },
    { name: "NewShopAppraisal", options: {}, I: NewShopAppraisalRequest, O: NewShopAppraisalResponse },
    { name: "UserData", options: {}, I: UserDataRequest, O: UserDataResponse },
    { name: "ShopInventory", options: {}, I: ShopInventoryRequest, O: ShopInventoryResponse },
    { name: "ShopMakePurchase", options: {}, I: ShopMakePurchaseRequest, O: ShopMakePurchaseResponse },
    { name: "ShopCancelPurchase", options: {}, I: ShopCancelPurchaseRequest, O: ShopCancelPurchaseResponse },
    { name: "GetBuybackAppraisal", options: {}, I: GetBuybackAppraisalRequest, O: GetBuybackAppraisalResponse },
    { name: "GetShopAppraisal", options: {}, I: GetShopAppraisalRequest, O: GetShopAppraisalResponse },
    { name: "StatusBuybackAppraisal", options: {}, I: StatusBuybackAppraisalRequest, O: StatusBuybackAppraisalResponse },
    { name: "StatusShopAppraisal", options: {}, I: StatusShopAppraisalRequest, O: StatusShopAppraisalResponse }
]);
