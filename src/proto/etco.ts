// @generated by protobuf-ts 2.9.0 with parameter ts_nocheck,server_none,long_type_number
// @generated from protobuf file "etco.proto" (package "etco_proto", syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message etco_proto.EmptyRequest
 */
export interface EmptyRequest {
}
/**
 * @generated from protobuf message etco_proto.BasicRequest
 */
export interface BasicRequest {
    /**
     * @generated from protobuf field: string refresh_token = 1;
     */
    refreshToken: string;
}
/**
 * @generated from protobuf message etco_proto.ErrorResponse
 */
export interface ErrorResponse {
    /**
     * @generated from protobuf field: string error = 1;
     */
    error: string; // error message
    /**
     * @generated from protobuf field: etco_proto.ErrorCode code = 2;
     */
    code: ErrorCode; // error code
}
/**
 * @generated from protobuf message etco_proto.NamedTypeId
 */
export interface NamedTypeId {
    /**
     * @generated from protobuf field: int32 type_id = 1;
     */
    typeId: number;
    /**
     * @generated from protobuf field: int32 type_str_index = 2;
     */
    typeStrIndex: number;
    /**
     * @generated from protobuf field: int32 category_str_index = 3;
     */
    categoryStrIndex: number;
    /**
     * @generated from protobuf field: int32 group_str_index = 4;
     */
    groupStrIndex: number;
    /**
     * @generated from protobuf field: repeated int32 market_group_str_indexes = 5;
     */
    marketGroupStrIndexes: number[];
}
/**
 * @generated from protobuf message etco_proto.BasicItem
 */
export interface BasicItem {
    /**
     * @generated from protobuf field: int32 type_id = 1;
     */
    typeId: number;
    /**
     * @generated from protobuf field: int64 quantity = 2;
     */
    quantity: number;
}
/**
 * @generated from protobuf message etco_proto.NamedBasicItem
 */
export interface NamedBasicItem {
    /**
     * @generated from protobuf field: etco_proto.NamedTypeId type_id = 1;
     */
    typeId?: NamedTypeId;
    /**
     * @generated from protobuf field: int64 quantity = 2;
     */
    quantity: number;
}
/**
 * @generated from protobuf message etco_proto.ShopLocationInfo
 */
export interface ShopLocationInfo {
    /**
     * @generated from protobuf field: etco_proto.LocationInfo location_info = 1;
     */
    locationInfo?: LocationInfo;
    /**
     * @generated from protobuf field: double tax_rate = 2;
     */
    taxRate: number; // tax rate (0-1)
}
/**
 * @generated from protobuf message etco_proto.LocationInfo
 */
export interface LocationInfo {
    /**
     * @generated from protobuf field: int64 location_id = 1;
     */
    locationId: number;
    /**
     * @generated from protobuf field: int32 location_str_index = 2;
     */
    locationStrIndex: number;
    /**
     * @generated from protobuf field: bool is_structure = 3;
     */
    isStructure: boolean;
    /**
     * @generated from protobuf field: bool forbidden_structure = 4;
     */
    forbiddenStructure: boolean;
    /**
     * @generated from protobuf field: etco_proto.SystemInfo system_info = 5;
     */
    systemInfo?: SystemInfo;
}
/**
 * @generated from protobuf message etco_proto.SystemInfo
 */
export interface SystemInfo {
    /**
     * @generated from protobuf field: int32 system_id = 1;
     */
    systemId: number;
    /**
     * @generated from protobuf field: int32 system_str_index = 2;
     */
    systemStrIndex: number;
    /**
     * @generated from protobuf field: int32 region_id = 3;
     */
    regionId: number;
    /**
     * @generated from protobuf field: int32 region_str_index = 4;
     */
    regionStrIndex: number;
}
/**
 * @generated from protobuf message etco_proto.CodeAndLocationId
 */
export interface CodeAndLocationId {
    /**
     * @generated from protobuf field: string code = 1;
     */
    code: string; // AppraisalCode
    /**
     * @generated from protobuf field: int64 location_id = 2;
     */
    locationId: number; // LocationId
}
/**
 * @generated from protobuf message etco_proto.BuybackAppraisal
 */
export interface BuybackAppraisal {
    /**
     * @generated from protobuf field: bool rejected = 1;
     */
    rejected: boolean;
    /**
     * @generated from protobuf field: string code = 2;
     */
    code: string; // AppraisalCode
    /**
     * @generated from protobuf field: int64 time = 3;
     */
    time: number; // time of the appraisal
    /**
     * @generated from protobuf field: repeated etco_proto.BuybackParentItem items = 4;
     */
    items: BuybackParentItem[];
    /**
     * @generated from protobuf field: string version = 5;
     */
    version: string; // version of the pricing scheme
    /**
     * @generated from protobuf field: int32 character_id = 6;
     */
    characterId: number; // 0 if anonymous or unauthorized to see
    /**
     * @generated from protobuf field: etco_proto.SystemInfo system_info = 7;
     */
    systemInfo?: SystemInfo;
    /**
     * @generated from protobuf field: double price = 8;
     */
    price: number; // sum of []parent.price_total
    /**
     * @generated from protobuf field: double tax = 9;
     */
    tax: number;
    /**
     * @generated from protobuf field: double tax_rate = 10;
     */
    taxRate: number; // tax rate (0-1)
    /**
     * @generated from protobuf field: double fee = 11;
     */
    fee: number; // sum of item fees
    /**
     * @generated from protobuf field: double fee_per_m3 = 12;
     */
    feePerM3: number; // fee per m3
}
/**
 * @generated from protobuf message etco_proto.BuybackAppraisalStatus
 */
export interface BuybackAppraisalStatus {
    /**
     * @generated from protobuf field: string code = 1;
     */
    code: string;
    /**
     * @generated from protobuf field: etco_proto.Contract contract = 2;
     */
    contract?: Contract;
}
/**
 * @generated from protobuf message etco_proto.BuybackParentItem
 */
export interface BuybackParentItem {
    /**
     * @generated from protobuf field: etco_proto.NamedTypeId type_id = 1;
     */
    typeId?: NamedTypeId;
    /**
     * @generated from protobuf field: int64 quantity = 2;
     */
    quantity: number;
    /**
     * @generated from protobuf field: double price_per_unit = 3;
     */
    pricePerUnit: number;
    /**
     * @generated from protobuf field: int32 description_str_index = 4;
     */
    descriptionStrIndex: number;
    /**
     * @generated from protobuf field: double fee_per_unit = 5;
     */
    feePerUnit: number;
    /**
     * @generated from protobuf field: repeated etco_proto.BuybackChildItem children = 6;
     */
    children: BuybackChildItem[];
}
/**
 * @generated from protobuf message etco_proto.BuybackChildItem
 */
export interface BuybackChildItem {
    /**
     * @generated from protobuf field: etco_proto.NamedTypeId type_id = 1;
     */
    typeId?: NamedTypeId;
    /**
     * @generated from protobuf field: double quantity_per_parent = 2;
     */
    quantityPerParent: number;
    /**
     * @generated from protobuf field: double price_per_unit = 3;
     */
    pricePerUnit: number;
    /**
     * @generated from protobuf field: int32 description_str_index = 4;
     */
    descriptionStrIndex: number;
}
/**
 * @generated from protobuf message etco_proto.ShopAppraisal
 */
export interface ShopAppraisal {
    /**
     * @generated from protobuf field: bool rejected = 1;
     */
    rejected: boolean;
    /**
     * @generated from protobuf field: string code = 2;
     */
    code: string; // AppraisalCode
    /**
     * @generated from protobuf field: int64 time = 3;
     */
    time: number; // time of the appraisal
    /**
     * @generated from protobuf field: repeated etco_proto.ShopItem items = 4;
     */
    items: ShopItem[];
    /**
     * @generated from protobuf field: string version = 5;
     */
    version: string; // version of the pricing scheme
    /**
     * @generated from protobuf field: int32 character_id = 6;
     */
    characterId: number; // 0 if anonymous or unauthorized to see
    /**
     * @generated from protobuf field: etco_proto.LocationInfo location_info = 7;
     */
    locationInfo?: LocationInfo;
    /**
     * @generated from protobuf field: double price = 8;
     */
    price: number; // sum of []item.price_total
    /**
     * @generated from protobuf field: double tax = 9;
     */
    tax: number;
    /**
     * @generated from protobuf field: double tax_rate = 10;
     */
    taxRate: number; // tax rate (0-1)
}
/**
 * @generated from protobuf message etco_proto.ShopAppraisalStatus
 */
export interface ShopAppraisalStatus {
    /**
     * @generated from protobuf field: string code = 1;
     */
    code: string;
    /**
     * @generated from protobuf field: etco_proto.Contract contract = 2;
     */
    contract?: Contract;
    /**
     * @generated from protobuf field: bool in_purchase_queue = 3;
     */
    inPurchaseQueue: boolean;
}
/**
 * @generated from protobuf message etco_proto.ShopItem
 */
export interface ShopItem {
    /**
     * @generated from protobuf field: etco_proto.NamedTypeId type_id = 1;
     */
    typeId?: NamedTypeId;
    /**
     * @generated from protobuf field: int64 quantity = 2;
     */
    quantity: number;
    /**
     * @generated from protobuf field: double price_per_unit = 3;
     */
    pricePerUnit: number;
    /**
     * @generated from protobuf field: int32 description_str_index = 4;
     */
    descriptionStrIndex: number;
}
/**
 * @generated from protobuf message etco_proto.PurchaseQueue
 */
export interface PurchaseQueue {
    /**
     * @generated from protobuf field: repeated string codes = 1;
     */
    codes: string[];
    /**
     * @generated from protobuf field: etco_proto.LocationInfo location_info = 2;
     */
    locationInfo?: LocationInfo;
}
/**
 * @generated from protobuf message etco_proto.Contract
 */
export interface Contract {
    /**
     * @generated from protobuf field: int32 contract_id = 1;
     */
    contractId: number;
    /**
     * @generated from protobuf field: etco_proto.ContractStatus status = 2;
     */
    status: ContractStatus;
    /**
     * @generated from protobuf field: int64 issued = 3;
     */
    issued: number;
    /**
     * @generated from protobuf field: int64 expires = 4;
     */
    expires: number;
    /**
     * @generated from protobuf field: etco_proto.LocationInfo location_info = 5;
     */
    locationInfo?: LocationInfo;
    /**
     * @generated from protobuf field: double price = 6;
     */
    price: number;
    /**
     * @generated from protobuf field: int32 issuer_corp_id = 7;
     */
    issuerCorpId: number;
    /**
     * @generated from protobuf field: int32 issuer_char_id = 8;
     */
    issuerCharId: number;
    /**
     * @generated from protobuf field: int32 assignee_id = 9;
     */
    assigneeId: number;
    /**
     * @generated from protobuf field: etco_proto.ContractAssigneeType assignee_type = 10;
     */
    assigneeType: ContractAssigneeType;
}
/**
 * @generated from protobuf message etco_proto.BuybackContractQueueEntry
 */
export interface BuybackContractQueueEntry {
    /**
     * @generated from protobuf field: string code = 1;
     */
    code: string; // AppraisalCode
    /**
     * @generated from protobuf field: etco_proto.Contract contract = 2;
     */
    contract?: Contract;
    /**
     * @generated from protobuf field: etco_proto.BuybackAppraisal appraisal = 3;
     */
    appraisal?: BuybackAppraisal; // items are empty
}
/**
 * @generated from protobuf message etco_proto.ShopContractQueueEntry
 */
export interface ShopContractQueueEntry {
    /**
     * @generated from protobuf field: string code = 1;
     */
    code: string; // AppraisalCode
    /**
     * @generated from protobuf field: etco_proto.Contract contract = 2;
     */
    contract?: Contract;
    /**
     * @generated from protobuf field: etco_proto.ShopAppraisal appraisal = 3;
     */
    appraisal?: ShopAppraisal; // items are empty
}
/**
 * @generated from protobuf message etco_proto.CfgTypePricing
 */
export interface CfgTypePricing {
    /**
     * @generated from protobuf field: bool is_buy = 1;
     */
    isBuy: boolean;
    /**
     * @generated from protobuf field: uint32 percentile = 2;
     */
    percentile: number;
    /**
     * @generated from protobuf field: uint32 modifier = 3;
     */
    modifier: number;
    /**
     * @generated from protobuf field: string market = 4;
     */
    market: string; // MarketKey
}
/**
 * @generated from protobuf message etco_proto.CfgBuybackTypePricing
 */
export interface CfgBuybackTypePricing {
    /**
     * at least one of these must be set
     *
     * @generated from protobuf field: etco_proto.CfgTypePricing pricing = 1;
     */
    pricing?: CfgTypePricing;
    /**
     * @generated from protobuf field: uint32 reprocessing_efficiency = 2;
     */
    reprocessingEfficiency: number; // 0 - 100
}
/**
 * wrapper for TypePricing
 *
 * @generated from protobuf message etco_proto.CfgShopTypePricing
 */
export interface CfgShopTypePricing {
    /**
     * @generated from protobuf field: etco_proto.CfgTypePricing inner = 1;
     */
    inner?: CfgTypePricing;
}
/**
 * wrapper for map<BuybackTypeMapKey, BuybackTypeValue>
 *
 * @generated from protobuf message etco_proto.CfgBuybackSystemTypeBundle
 */
export interface CfgBuybackSystemTypeBundle {
    /**
     * @generated from protobuf field: map<string, etco_proto.CfgBuybackTypePricing> inner = 1;
     */
    inner: {
        [key: string]: CfgBuybackTypePricing;
    };
}
/**
 * wrapper for map<ShopTypeMapKey, ShopTypeValue>
 *
 * @generated from protobuf message etco_proto.CfgShopLocationTypeBundle
 */
export interface CfgShopLocationTypeBundle {
    /**
     * @generated from protobuf field: map<string, etco_proto.CfgShopTypePricing> inner = 1;
     */
    inner: {
        [key: string]: CfgShopTypePricing;
    };
}
/**
 * @generated from protobuf message etco_proto.CfgBuybackSystem
 */
export interface CfgBuybackSystem {
    /**
     * @generated from protobuf field: string bundle_key = 1;
     */
    bundleKey: string; // BuybackSystemBundleKey
    /**
     * @generated from protobuf field: double m3_fee = 2;
     */
    m3Fee: number; // fee per m3
    /**
     * @generated from protobuf field: double tax_rate = 3;
     */
    taxRate: number; // tax rate (0-1)
}
/**
 * @generated from protobuf message etco_proto.CfgShopLocation
 */
export interface CfgShopLocation {
    /**
     * @generated from protobuf field: string bundle_key = 1;
     */
    bundleKey: string; // ShopLocationBundleKey
    /**
     * @generated from protobuf field: repeated string banned_flags = 2;
     */
    bannedFlags: string[]; // banned asset flags
    /**
     * @generated from protobuf field: double tax_rate = 3;
     */
    taxRate: number; // tax rate (0-1)
}
/**
 * @generated from protobuf message etco_proto.CfgMarket
 */
export interface CfgMarket {
    /**
     * @generated from protobuf field: string refresh_token = 1;
     */
    refreshToken: string; // web token
    /**
     * @generated from protobuf field: int64 location_id = 2;
     */
    locationId: number;
    /**
     * @generated from protobuf field: bool is_structure = 3;
     */
    isStructure: boolean;
}
/**
 * @generated from protobuf message etco_proto.CfgConstData
 */
export interface CfgConstData {
    /**
     * @generated from protobuf field: int32 purchase_max_active = 1;
     */
    purchaseMaxActive: number;
    /**
     * @generated from protobuf field: int32 make_purchase_cooldown = 2;
     */
    makePurchaseCooldown: number;
    /**
     * @generated from protobuf field: int32 cancel_purchase_cooldown = 3;
     */
    cancelPurchaseCooldown: number;
    /**
     * @generated from protobuf field: string corporation_web_refresh_token = 4;
     */
    corporationWebRefreshToken: string;
    /**
     * @generated from protobuf field: string structure_info_web_refresh_token = 5;
     */
    structureInfoWebRefreshToken: string;
    /**
     * @generated from protobuf field: string discord_channel = 6;
     */
    discordChannel: string;
    /**
     * @generated from protobuf field: bool buyback_contract_notifications = 7;
     */
    buybackContractNotifications: boolean;
    /**
     * @generated from protobuf field: bool shop_contract_notifications = 8;
     */
    shopContractNotifications: boolean;
    /**
     * @generated from protobuf field: bool purchase_notifications = 9;
     */
    purchaseNotifications: boolean;
}
/**
 * list of valid IDs for authentication
 *
 * @generated from protobuf message etco_proto.CfgAuthList
 */
export interface CfgAuthList {
    /**
     * authentication is checked in this exact order, stopping on first match
     *
     * @generated from protobuf field: repeated int32 banned_character_ids = 1;
     */
    bannedCharacterIds: number[]; // denied
    /**
     * @generated from protobuf field: repeated int32 permit_character_ids = 2;
     */
    permitCharacterIds: number[]; // allowed
    /**
     * @generated from protobuf field: repeated int32 banned_corporation_ids = 3;
     */
    bannedCorporationIds: number[]; // denied
    /**
     * @generated from protobuf field: repeated int32 permit_corporation_ids = 4;
     */
    permitCorporationIds: number[]; // allowed
    /**
     * @generated from protobuf field: repeated int32 permit_alliance_ids = 5;
     */
    permitAllianceIds: number[]; // allowed
}
// // Static Endpoints

/**
 * @generated from protobuf message etco_proto.TypesResponse
 */
export interface TypesResponse {
    /**
     * @generated from protobuf field: repeated int32 types = 1;
     */
    types: number[];
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 2;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message etco_proto.NamedTypesRequest
 */
export interface NamedTypesRequest {
    /**
     * @generated from protobuf field: repeated int32 types = 1;
     */
    types: number[];
}
/**
 * @generated from protobuf message etco_proto.NamedTypesResponse
 */
export interface NamedTypesResponse {
    /**
     * @generated from protobuf field: repeated etco_proto.NamedTypeId types = 1;
     */
    types: NamedTypeId[]; // same order as request
    /**
     * @generated from protobuf field: repeated string strs = 2;
     */
    strs: string[];
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse; // any invalid type_ids
}
/**
 * @generated from protobuf message etco_proto.SystemsRequest
 */
export interface SystemsRequest {
    /**
     * @generated from protobuf field: repeated int32 systems = 1;
     */
    systems: number[];
}
/**
 * @generated from protobuf message etco_proto.SystemsResponse
 */
export interface SystemsResponse {
    /**
     * @generated from protobuf field: repeated etco_proto.SystemInfo systems = 1;
     */
    systems: SystemInfo[]; // same order as request
    /**
     * @generated from protobuf field: repeated string strs = 2;
     */
    strs: string[];
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
// // Anonymous Endpoints

/**
 * @generated from protobuf message etco_proto.AllShopLocationsResponse
 */
export interface AllShopLocationsResponse {
    /**
     * @generated from protobuf field: repeated etco_proto.ShopLocationInfo locations = 1;
     */
    locations: ShopLocationInfo[];
    /**
     * @generated from protobuf field: repeated string strs = 2;
     */
    strs: string[];
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message etco_proto.LocationsRequest
 */
export interface LocationsRequest {
    /**
     * @generated from protobuf field: repeated int64 locations = 1;
     */
    locations: number[];
}
/**
 * @generated from protobuf message etco_proto.LocationsResponse
 */
export interface LocationsResponse {
    /**
     * @generated from protobuf field: repeated etco_proto.LocationInfo locations = 1;
     */
    locations: LocationInfo[]; // same order as request
    /**
     * @generated from protobuf field: repeated string strs = 2;
     */
    strs: string[];
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message etco_proto.ParseRequest
 */
export interface ParseRequest {
    /**
     * @generated from protobuf field: string text = 1;
     */
    text: string;
}
/**
 * @generated from protobuf message etco_proto.ParseResponse
 */
export interface ParseResponse {
    /**
     * @generated from protobuf field: repeated etco_proto.NamedBasicItem known_items = 1;
     */
    knownItems: NamedBasicItem[];
    /**
     * @generated from protobuf field: repeated etco_proto.NamedBasicItem unknown_items = 2;
     */
    unknownItems: NamedBasicItem[];
    /**
     * @generated from protobuf field: repeated string strs = 3;
     */
    strs: string[];
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 4;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message etco_proto.LoginRequest
 */
export interface LoginRequest {
    /**
     * @generated from protobuf field: string access_code = 1;
     */
    accessCode: string; // esi sso code
    /**
     * @generated from protobuf field: etco_proto.EsiApp app = 2;
     */
    app: EsiApp;
}
/**
 * @generated from protobuf message etco_proto.LoginResponse
 */
export interface LoginResponse {
    /**
     * @generated from protobuf field: string refresh_token = 1;
     */
    refreshToken: string;
    /**
     * @generated from protobuf field: int32 character_id = 2;
     */
    characterId: number;
    /**
     * @generated from protobuf field: bool admin = 3;
     */
    admin: boolean;
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 4;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message etco_proto.TokenInfoRequest
 */
export interface TokenInfoRequest {
    /**
     * @generated from protobuf field: string refresh_token = 1;
     */
    refreshToken: string;
    /**
     * @generated from protobuf field: etco_proto.EsiApp app = 2;
     */
    app: EsiApp;
}
/**
 * @generated from protobuf message etco_proto.TokenInfoResponse
 */
export interface TokenInfoResponse {
    /**
     * @generated from protobuf field: int32 character_id = 1;
     */
    characterId: number;
    /**
     * @generated from protobuf field: bool admin = 2;
     */
    admin: boolean;
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message etco_proto.EntityInfoRequest
 */
export interface EntityInfoRequest {
    /**
     * @generated from protobuf field: int32 entity_id = 1;
     */
    entityId: number;
}
/**
 * @generated from protobuf message etco_proto.CharacterInfoResponse
 */
export interface CharacterInfoResponse {
    /**
     * @generated from protobuf field: int32 character_id = 1;
     */
    characterId: number;
    /**
     * @generated from protobuf field: int32 corporation_id = 2;
     */
    corporationId: number;
    /**
     * @generated from protobuf field: int32 alliance_id = 3;
     */
    allianceId: number; // 0 = null
    /**
     * @generated from protobuf field: string name = 4;
     */
    name: string;
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 5;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message etco_proto.CorporationInfoResponse
 */
export interface CorporationInfoResponse {
    /**
     * @generated from protobuf field: int32 corporation_id = 1;
     */
    corporationId: number;
    /**
     * @generated from protobuf field: int32 alliance_id = 2;
     */
    allianceId: number; // 0 = null
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string ticker = 4;
     */
    ticker: string;
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 5;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message etco_proto.AllianceInfoResponse
 */
export interface AllianceInfoResponse {
    /**
     * @generated from protobuf field: int32 alliance_id = 1;
     */
    allianceId: number;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: string ticker = 3;
     */
    ticker: string;
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 4;
     */
    error?: ErrorResponse;
}
/**
 * won't include a code + won't be retrievable later
 *
 * @generated from protobuf message etco_proto.NewAppraisalRequest
 */
export interface NewAppraisalRequest {
    /**
     * @generated from protobuf field: int64 territory_id = 1;
     */
    territoryId: number; // SystemId / LocationId
    /**
     * @generated from protobuf field: repeated etco_proto.BasicItem items = 2;
     */
    items: BasicItem[];
}
// // Admin Endpoints

/**
 * @generated from protobuf message etco_proto.BuybackContractQueueResponse
 */
export interface BuybackContractQueueResponse {
    /**
     * @generated from protobuf field: repeated etco_proto.BuybackContractQueueEntry queue = 1;
     */
    queue: BuybackContractQueueEntry[];
    /**
     * @generated from protobuf field: repeated string strs = 2;
     */
    strs: string[];
    /**
     * @generated from protobuf field: bool authorized = 3;
     */
    authorized: boolean;
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 4;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message etco_proto.ShopContractQueueResponse
 */
export interface ShopContractQueueResponse {
    /**
     * @generated from protobuf field: repeated etco_proto.ShopContractQueueEntry queue = 1;
     */
    queue: ShopContractQueueEntry[];
    /**
     * @generated from protobuf field: repeated string strs = 2;
     */
    strs: string[];
    /**
     * @generated from protobuf field: bool authorized = 3;
     */
    authorized: boolean;
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 4;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message etco_proto.PurchaseQueueResponse
 */
export interface PurchaseQueueResponse {
    /**
     * @generated from protobuf field: map<int64, etco_proto.PurchaseQueue> queue = 1;
     */
    queue: {
        [key: string]: PurchaseQueue;
    };
    /**
     * @generated from protobuf field: repeated string strs = 2;
     */
    strs: string[];
    /**
     * @generated from protobuf field: bool authorized = 3;
     */
    authorized: boolean;
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 4;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message etco_proto.LocationPurchaseQueueRequest
 */
export interface LocationPurchaseQueueRequest {
    /**
     * @generated from protobuf field: int64 location_id = 1;
     */
    locationId: number; // LocationId
    /**
     * @generated from protobuf field: string refresh_token = 2;
     */
    refreshToken: string;
}
/**
 * @generated from protobuf message etco_proto.LocationPurchaseQueueResponse
 */
export interface LocationPurchaseQueueResponse {
    /**
     * @generated from protobuf field: etco_proto.PurchaseQueue queue = 1;
     */
    queue?: PurchaseQueue;
    /**
     * @generated from protobuf field: repeated string strs = 2;
     */
    strs: string[];
    /**
     * @generated from protobuf field: bool authorized = 3;
     */
    authorized: boolean;
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 4;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message etco_proto.DeletePurchasesRequest
 */
export interface DeletePurchasesRequest {
    /**
     * @generated from protobuf field: repeated etco_proto.CodeAndLocationId entries = 1;
     */
    entries: CodeAndLocationId[]; // AppraisalCode
    /**
     * @generated from protobuf field: string refresh_token = 2;
     */
    refreshToken: string;
}
/**
 * @generated from protobuf message etco_proto.DeletePurchasesResponse
 */
export interface DeletePurchasesResponse {
    /**
     * @generated from protobuf field: bool authorized = 1;
     */
    authorized: boolean; // true if admin
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 2;
     */
    error?: ErrorResponse;
}
// // User Endpoints

/**
 * will include a code + will be retrievable later
 *
 * @generated from protobuf message etco_proto.SaveAppraisalRequest
 */
export interface SaveAppraisalRequest {
    /**
     * @generated from protobuf field: int64 territory_id = 1;
     */
    territoryId: number; // SystemId / LocationId
    /**
     * @generated from protobuf field: repeated etco_proto.BasicItem items = 2;
     */
    items: BasicItem[];
    /**
     * @generated from protobuf field: string refresh_token = 3;
     */
    refreshToken: string; // optional
}
/**
 * @generated from protobuf message etco_proto.BuybackAppraisalResponse
 */
export interface BuybackAppraisalResponse {
    /**
     * @generated from protobuf field: etco_proto.BuybackAppraisal appraisal = 1;
     */
    appraisal?: BuybackAppraisal;
    /**
     * @generated from protobuf field: repeated string strs = 2;
     */
    strs: string[];
    /**
     * @generated from protobuf field: bool authorized = 3;
     */
    authorized: boolean; // true = not saving OR user OR admin OR saving as anonymous
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 4;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message etco_proto.ShopAppraisalResponse
 */
export interface ShopAppraisalResponse {
    /**
     * @generated from protobuf field: etco_proto.MakePurchaseStatus status = 1;
     */
    status: MakePurchaseStatus; // always success if not saving
    /**
     * @generated from protobuf field: etco_proto.ShopAppraisal appraisal = 2;
     */
    appraisal?: ShopAppraisal;
    /**
     * @generated from protobuf field: repeated string strs = 3;
     */
    strs: string[];
    /**
     * @generated from protobuf field: bool authorized = 4;
     */
    authorized: boolean; // true = not saving OR user OR admin OR saving as anonymous
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 5;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message etco_proto.ShopInventoryRequest
 */
export interface ShopInventoryRequest {
    /**
     * @generated from protobuf field: int64 location_id = 1;
     */
    locationId: number; // LocationId
    /**
     * @generated from protobuf field: string refresh_token = 2;
     */
    refreshToken: string;
}
/**
 * @generated from protobuf message etco_proto.ShopInventoryResponse
 */
export interface ShopInventoryResponse {
    /**
     * @generated from protobuf field: repeated etco_proto.ShopItem items = 1;
     */
    items: ShopItem[];
    /**
     * @generated from protobuf field: etco_proto.LocationInfo location_info = 2;
     */
    locationInfo?: LocationInfo;
    /**
     * @generated from protobuf field: repeated string strs = 3;
     */
    strs: string[];
    /**
     * @generated from protobuf field: bool authorized = 4;
     */
    authorized: boolean;
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 5;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message etco_proto.UserDataRequest
 */
export interface UserDataRequest {
    /**
     * @generated from protobuf field: int32 character_id = 1;
     */
    characterId: number;
    /**
     * @generated from protobuf field: string refresh_token = 2;
     */
    refreshToken: string;
}
/**
 * @generated from protobuf message etco_proto.UserTimePurchaseResponse
 */
export interface UserTimePurchaseResponse {
    /**
     * @generated from protobuf field: int64 time = 1;
     */
    time: number;
    /**
     * @generated from protobuf field: bool authorized = 2;
     */
    authorized: boolean; // true = user OR admin
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message etco_proto.UserAppraisalCodesResponse
 */
export interface UserAppraisalCodesResponse {
    /**
     * @generated from protobuf field: repeated string codes = 1;
     */
    codes: string[]; // AppraisalCodes
    /**
     * @generated from protobuf field: bool authorized = 2;
     */
    authorized: boolean; // true = user OR admin
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message etco_proto.CancelPurchaseRequest
 */
export interface CancelPurchaseRequest {
    /**
     * @generated from protobuf field: string code = 1;
     */
    code: string;
    /**
     * @generated from protobuf field: int64 location_id = 2;
     */
    locationId: number;
    /**
     * @generated from protobuf field: string refresh_token = 3;
     */
    refreshToken: string;
}
/**
 * @generated from protobuf message etco_proto.CancelPurchaseResponse
 */
export interface CancelPurchaseResponse {
    /**
     * @generated from protobuf field: etco_proto.CancelPurchaseStatus status = 1;
     */
    status: CancelPurchaseStatus;
    /**
     * @generated from protobuf field: bool authorized = 2;
     */
    authorized: boolean; // true = user OR admin
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message etco_proto.StatusAppraisalRequest
 */
export interface StatusAppraisalRequest {
    /**
     * @generated from protobuf field: string code = 1;
     */
    code: string; // AppraisalCode
    /**
     * @generated from protobuf field: bool include_items = 2;
     */
    includeItems: boolean;
    /**
     * @generated from protobuf field: string refresh_token = 3;
     */
    refreshToken: string;
}
/**
 * @generated from protobuf message etco_proto.StatusAppraisalResponse
 */
export interface StatusAppraisalResponse {
    /**
     * @generated from protobuf field: etco_proto.AppraisalStatus status = 1;
     */
    status: AppraisalStatus;
    /**
     * @generated from protobuf field: etco_proto.Contract contract = 2;
     */
    contract?: Contract; // null = status != AS_HAS_CONTRACT
    /**
     * @generated from protobuf field: repeated etco_proto.NamedBasicItem contract_items = 3;
     */
    contractItems: NamedBasicItem[]; // empty = status != AS_HAS_CONTRACT || !include_items
    /**
     * @generated from protobuf field: repeated string strs = 4;
     */
    strs: string[];
    /**
     * @generated from protobuf field: bool authorized = 5;
     */
    authorized: boolean; // true = appraisal-creator OR admin
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 6;
     */
    error?: ErrorResponse;
}
// // Dynamic Endpoints - Auth is optional, behavior depends on auth

/**
 * @generated from protobuf message etco_proto.GetAppraisalRequest
 */
export interface GetAppraisalRequest {
    /**
     * @generated from protobuf field: string code = 1;
     */
    code: string; // AppraisalCode
    /**
     * @generated from protobuf field: bool include_items = 2;
     */
    includeItems: boolean;
    /**
     * @generated from protobuf field: string refresh_token = 3;
     */
    refreshToken: string; // Optional
}
/**
 * @generated from protobuf message etco_proto.GetBuybackAppraisalResponse
 */
export interface GetBuybackAppraisalResponse {
    /**
     * @generated from protobuf field: etco_proto.BuybackAppraisal appraisal = 1;
     */
    appraisal?: BuybackAppraisal; // characterId == 0 if anonymous-appraisal || (!admin && !appraisal-creator)
    /**
     * @generated from protobuf field: bool anonymous = 2;
     */
    anonymous: boolean; // true = anonymous-appraisal
    /**
     * @generated from protobuf field: repeated string strs = 3;
     */
    strs: string[];
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 4;
     */
    error?: ErrorResponse; // code not exists
}
/**
 * @generated from protobuf message etco_proto.GetShopAppraisalResponse
 */
export interface GetShopAppraisalResponse {
    /**
     * @generated from protobuf field: etco_proto.ShopAppraisal appraisal = 1;
     */
    appraisal?: ShopAppraisal; // characterId == 0 if anonymous-appraisal || (!admin && !appraisal-creator)
    /**
     * @generated from protobuf field: bool anonymous = 2;
     */
    anonymous: boolean; // true = anonymous-appraisal
    /**
     * @generated from protobuf field: repeated string strs = 3;
     */
    strs: string[];
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 4;
     */
    error?: ErrorResponse; // code not exists
}
// // Cfg Endpoints

/**
 * @generated from protobuf message etco_proto.CfgUpdateResponse
 */
export interface CfgUpdateResponse {
    /**
     * @generated from protobuf field: bool modified = 1;
     */
    modified: boolean;
    /**
     * @generated from protobuf field: bool authorized = 2;
     */
    authorized: boolean;
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message etco_proto.CfgGetAuthListResponse
 */
export interface CfgGetAuthListResponse {
    /**
     * @generated from protobuf field: etco_proto.CfgAuthList auth_list = 1;
     */
    authList?: CfgAuthList;
    /**
     * @generated from protobuf field: bool authorized = 2;
     */
    authorized: boolean;
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message etco_proto.CfgSetAuthListRequest
 */
export interface CfgSetAuthListRequest {
    /**
     * @generated from protobuf field: etco_proto.CfgAuthList auth_list = 1;
     */
    authList?: CfgAuthList;
    /**
     * @generated from protobuf field: string refresh_token = 2;
     */
    refreshToken: string;
}
/**
 * @generated from protobuf message etco_proto.CfgGetConstDataResponse
 */
export interface CfgGetConstDataResponse {
    /**
     * @generated from protobuf field: etco_proto.CfgConstData const_data = 1;
     */
    constData?: CfgConstData;
    /**
     * @generated from protobuf field: bool authorized = 2;
     */
    authorized: boolean;
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message etco_proto.CfgSetConstDataRequest
 */
export interface CfgSetConstDataRequest {
    /**
     * @generated from protobuf field: etco_proto.CfgConstData const_data = 1;
     */
    constData?: CfgConstData;
    /**
     * @generated from protobuf field: string refresh_token = 2;
     */
    refreshToken: string;
}
/**
 * @generated from protobuf message etco_proto.CfgGetBuybackSystemTypeMapsBuilderResponse
 */
export interface CfgGetBuybackSystemTypeMapsBuilderResponse {
    /**
     * @generated from protobuf field: map<int32, etco_proto.CfgBuybackSystemTypeBundle> builder = 1;
     */
    builder: {
        [key: number]: CfgBuybackSystemTypeBundle;
    };
    /**
     * @generated from protobuf field: bool authorized = 2;
     */
    authorized: boolean;
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message etco_proto.CfgMergeBuybackSystemTypeMapsBuilderRequest
 */
export interface CfgMergeBuybackSystemTypeMapsBuilderRequest {
    /**
     * the program itself converts this to multiple map<TypeId, BuybackTypeMap>
     *
     * @generated from protobuf field: map<int32, etco_proto.CfgBuybackSystemTypeBundle> builder = 1;
     */
    builder: {
        [key: number]: CfgBuybackSystemTypeBundle;
    };
    /**
     * @generated from protobuf field: string refresh_token = 2;
     */
    refreshToken: string;
}
/**
 * @generated from protobuf message etco_proto.CfgGetShopLocationTypeMapsBuilderResponse
 */
export interface CfgGetShopLocationTypeMapsBuilderResponse {
    /**
     * @generated from protobuf field: map<int32, etco_proto.CfgShopLocationTypeBundle> builder = 1;
     */
    builder: {
        [key: number]: CfgShopLocationTypeBundle;
    };
    /**
     * @generated from protobuf field: bool authorized = 2;
     */
    authorized: boolean;
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message etco_proto.CfgMergeShopLocationTypeMapsBuilderRequest
 */
export interface CfgMergeShopLocationTypeMapsBuilderRequest {
    /**
     * the program itself converts this to multiple map<TypeId, ShopTypeMap>
     *
     * @generated from protobuf field: map<int32, etco_proto.CfgShopLocationTypeBundle> builder = 1;
     */
    builder: {
        [key: number]: CfgShopLocationTypeBundle;
    };
    /**
     * @generated from protobuf field: string refresh_token = 2;
     */
    refreshToken: string;
}
/**
 * @generated from protobuf message etco_proto.CfgGetBuybackSystemsResponse
 */
export interface CfgGetBuybackSystemsResponse {
    /**
     * @generated from protobuf field: map<int32, etco_proto.CfgBuybackSystem> systems = 1;
     */
    systems: {
        [key: number]: CfgBuybackSystem;
    };
    /**
     * @generated from protobuf field: bool authorized = 4;
     */
    authorized: boolean;
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 5;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message etco_proto.CfgMergeBuybackSystemsRequest
 */
export interface CfgMergeBuybackSystemsRequest {
    /**
     * @generated from protobuf field: map<int32, etco_proto.CfgBuybackSystem> systems = 1;
     */
    systems: {
        [key: number]: CfgBuybackSystem;
    };
    /**
     * @generated from protobuf field: string refresh_token = 2;
     */
    refreshToken: string;
}
/**
 * @generated from protobuf message etco_proto.CfgGetShopLocationsResponse
 */
export interface CfgGetShopLocationsResponse {
    /**
     * @generated from protobuf field: map<int64, etco_proto.CfgShopLocation> locations = 1;
     */
    locations: {
        [key: string]: CfgShopLocation;
    };
    /**
     * @generated from protobuf field: bool authorized = 4;
     */
    authorized: boolean;
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 5;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message etco_proto.CfgMergeShopLocationsRequest
 */
export interface CfgMergeShopLocationsRequest {
    /**
     * @generated from protobuf field: map<int64, etco_proto.CfgShopLocation> locations = 1;
     */
    locations: {
        [key: string]: CfgShopLocation;
    };
    /**
     * @generated from protobuf field: string refresh_token = 2;
     */
    refreshToken: string;
}
/**
 * @generated from protobuf message etco_proto.CfgGetMarketsResponse
 */
export interface CfgGetMarketsResponse {
    /**
     * @generated from protobuf field: map<string, etco_proto.CfgMarket> markets = 1;
     */
    markets: {
        [key: string]: CfgMarket;
    };
    /**
     * @generated from protobuf field: bool authorized = 4;
     */
    authorized: boolean;
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 5;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message etco_proto.CfgMergeMarketsRequest
 */
export interface CfgMergeMarketsRequest {
    /**
     * @generated from protobuf field: map<string, etco_proto.CfgMarket> markets = 1;
     */
    markets: {
        [key: string]: CfgMarket;
    };
    /**
     * @generated from protobuf field: string refresh_token = 2;
     */
    refreshToken: string;
}
/**
 * @generated from protobuf message etco_proto.CfgGetBuybackBundleKeysResponse
 */
export interface CfgGetBuybackBundleKeysResponse {
    /**
     * @generated from protobuf field: repeated string bundle_keys = 1;
     */
    bundleKeys: string[]; // BuybackSystemBundleKey
    /**
     * @generated from protobuf field: bool authorized = 2;
     */
    authorized: boolean;
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message etco_proto.CfgGetShopBundleKeysResponse
 */
export interface CfgGetShopBundleKeysResponse {
    /**
     * @generated from protobuf field: repeated string bundle_keys = 1;
     */
    bundleKeys: string[]; // ShopLocationBundleKey
    /**
     * @generated from protobuf field: bool authorized = 2;
     */
    authorized: boolean;
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf message etco_proto.CfgGetMarketNamesResponse
 */
export interface CfgGetMarketNamesResponse {
    /**
     * @generated from protobuf field: repeated string market_names = 1;
     */
    marketNames: string[];
    /**
     * @generated from protobuf field: bool authorized = 2;
     */
    authorized: boolean;
    /**
     * @generated from protobuf field: etco_proto.ErrorResponse error = 3;
     */
    error?: ErrorResponse;
}
/**
 * @generated from protobuf enum etco_proto.ErrorCode
 */
export enum ErrorCode {
    /**
     * @generated from protobuf enum value: EC_OK = 0;
     */
    EC_OK = 0,
    /**
     * @generated from protobuf enum value: EC_SERVER_ERROR = 1;
     */
    EC_SERVER_ERROR = 1,
    /**
     * @generated from protobuf enum value: EC_INVALID_REQUEST = 2;
     */
    EC_INVALID_REQUEST = 2,
    /**
     * @generated from protobuf enum value: EC_INVALID_MERGE = 3;
     */
    EC_INVALID_MERGE = 3,
    /**
     * @generated from protobuf enum value: EC_BOOTSTRAP_UNSET = 4;
     */
    EC_BOOTSTRAP_UNSET = 4,
    /**
     * @generated from protobuf enum value: EC_NOT_FOUND = 5;
     */
    EC_NOT_FOUND = 5,
    /**
     * @generated from protobuf enum value: EC_TOKEN_INVALID = 6;
     */
    EC_TOKEN_INVALID = 6
}
/**
 * @generated from protobuf enum etco_proto.EsiApp
 */
export enum EsiApp {
    /**
     * @generated from protobuf enum value: EA_AUTH = 0;
     */
    EA_AUTH = 0,
    /**
     * @generated from protobuf enum value: EA_MARKETS = 1;
     */
    EA_MARKETS = 1,
    /**
     * @generated from protobuf enum value: EA_CORPORATION = 2;
     */
    EA_CORPORATION = 2,
    /**
     * @generated from protobuf enum value: EA_STRUCTURE_INFO = 3;
     */
    EA_STRUCTURE_INFO = 3
}
/**
 * @generated from protobuf enum etco_proto.MakePurchaseStatus
 */
export enum MakePurchaseStatus {
    /**
     * @generated from protobuf enum value: MPS_NONE = 0;
     */
    MPS_NONE = 0,
    /**
     * @generated from protobuf enum value: MPS_SUCCESS = 1;
     */
    MPS_SUCCESS = 1,
    /**
     * @generated from protobuf enum value: MPS_COOLDOWN_LIMIT = 2;
     */
    MPS_COOLDOWN_LIMIT = 2,
    /**
     * @generated from protobuf enum value: MPS_MAX_ACTIVE_LIMIT = 3;
     */
    MPS_MAX_ACTIVE_LIMIT = 3,
    /**
     * @generated from protobuf enum value: MPS_ITEMS_REJECTED = 4;
     */
    MPS_ITEMS_REJECTED = 4,
    /**
     * @generated from protobuf enum value: MPS_ITEMS_UNAVAILABLE = 5;
     */
    MPS_ITEMS_UNAVAILABLE = 5,
    /**
     * @generated from protobuf enum value: MPS_ITEMS_REJECTED_AND_UNAVAILABLE = 6;
     */
    MPS_ITEMS_REJECTED_AND_UNAVAILABLE = 6
}
/**
 * @generated from protobuf enum etco_proto.CancelPurchaseStatus
 */
export enum CancelPurchaseStatus {
    /**
     * @generated from protobuf enum value: CPS_SUCCESS = 0;
     */
    CPS_SUCCESS = 0,
    /**
     * @generated from protobuf enum value: CPS_COOLDOWN_LIMIT = 1;
     */
    CPS_COOLDOWN_LIMIT = 1,
    /**
     * @generated from protobuf enum value: CPS_NOT_FOUND = 2;
     */
    CPS_NOT_FOUND = 2,
    /**
     * @generated from protobuf enum value: CPS_COOLDOWN_LIMIT_AND_NOT_FOUND = 3;
     */
    CPS_COOLDOWN_LIMIT_AND_NOT_FOUND = 3,
    /**
     * @generated from protobuf enum value: CPS_NOT_ACTIVE = 4;
     */
    CPS_NOT_ACTIVE = 4
}
/**
 * @generated from protobuf enum etco_proto.ContractStatus
 */
export enum ContractStatus {
    /**
     * @generated from protobuf enum value: CS_UNKNOWN = 0;
     */
    CS_UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: CS_OUTSTANDING = 1;
     */
    CS_OUTSTANDING = 1,
    /**
     * @generated from protobuf enum value: CS_IN_PROGRESS = 2;
     */
    CS_IN_PROGRESS = 2,
    /**
     * @generated from protobuf enum value: CS_FINISHED_ISSUER = 3;
     */
    CS_FINISHED_ISSUER = 3,
    /**
     * @generated from protobuf enum value: CS_FINISHED_CONTRACTOR = 4;
     */
    CS_FINISHED_CONTRACTOR = 4,
    /**
     * @generated from protobuf enum value: CS_FINISHED = 5;
     */
    CS_FINISHED = 5,
    /**
     * @generated from protobuf enum value: CS_CANCELLED = 6;
     */
    CS_CANCELLED = 6,
    /**
     * @generated from protobuf enum value: CS_REJECTED = 7;
     */
    CS_REJECTED = 7,
    /**
     * @generated from protobuf enum value: CS_FAILED = 8;
     */
    CS_FAILED = 8,
    /**
     * @generated from protobuf enum value: CS_DELETED = 9;
     */
    CS_DELETED = 9,
    /**
     * @generated from protobuf enum value: CS_REVERSED = 10;
     */
    CS_REVERSED = 10
}
/**
 * @generated from protobuf enum etco_proto.ContractAssigneeType
 */
export enum ContractAssigneeType {
    /**
     * @generated from protobuf enum value: CAT_UNKNOWN = 0;
     */
    CAT_UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: CAT_CORPORATION = 1;
     */
    CAT_CORPORATION = 1,
    /**
     * @generated from protobuf enum value: CAT_CHARACTER = 2;
     */
    CAT_CHARACTER = 2,
    /**
     * @generated from protobuf enum value: CAT_ALLIANCE = 3;
     */
    CAT_ALLIANCE = 3
}
/**
 * @generated from protobuf enum etco_proto.AppraisalStatus
 */
export enum AppraisalStatus {
    /**
     * @generated from protobuf enum value: AS_UNDEFINED = 0;
     */
    AS_UNDEFINED = 0,
    /**
     * @generated from protobuf enum value: AS_CONTRACT = 1;
     */
    AS_CONTRACT = 1,
    /**
     * @generated from protobuf enum value: AS_PURCHASE_QUEUE = 2;
     */
    AS_PURCHASE_QUEUE = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class EmptyRequest$Type extends MessageType<EmptyRequest> {
    constructor() {
        super("etco_proto.EmptyRequest", []);
    }
    create(value?: PartialMessage<EmptyRequest>): EmptyRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EmptyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EmptyRequest): EmptyRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: EmptyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.EmptyRequest
 */
export const EmptyRequest = new EmptyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BasicRequest$Type extends MessageType<BasicRequest> {
    constructor() {
        super("etco_proto.BasicRequest", [
            { no: 1, name: "refresh_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BasicRequest>): BasicRequest {
        const message = { refreshToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BasicRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BasicRequest): BasicRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string refresh_token */ 1:
                    message.refreshToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BasicRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string refresh_token = 1; */
        if (message.refreshToken !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.refreshToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.BasicRequest
 */
export const BasicRequest = new BasicRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ErrorResponse$Type extends MessageType<ErrorResponse> {
    constructor() {
        super("etco_proto.ErrorResponse", [
            { no: 1, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "enum", T: () => ["etco_proto.ErrorCode", ErrorCode] }
        ]);
    }
    create(value?: PartialMessage<ErrorResponse>): ErrorResponse {
        const message = { error: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ErrorResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ErrorResponse): ErrorResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string error */ 1:
                    message.error = reader.string();
                    break;
                case /* etco_proto.ErrorCode code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ErrorResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string error = 1; */
        if (message.error !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.error);
        /* etco_proto.ErrorCode code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.ErrorResponse
 */
export const ErrorResponse = new ErrorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NamedTypeId$Type extends MessageType<NamedTypeId> {
    constructor() {
        super("etco_proto.NamedTypeId", [
            { no: 1, name: "type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type_str_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "category_str_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "group_str_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "market_group_str_indexes", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<NamedTypeId>): NamedTypeId {
        const message = { typeId: 0, typeStrIndex: 0, categoryStrIndex: 0, groupStrIndex: 0, marketGroupStrIndexes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NamedTypeId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NamedTypeId): NamedTypeId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 type_id */ 1:
                    message.typeId = reader.int32();
                    break;
                case /* int32 type_str_index */ 2:
                    message.typeStrIndex = reader.int32();
                    break;
                case /* int32 category_str_index */ 3:
                    message.categoryStrIndex = reader.int32();
                    break;
                case /* int32 group_str_index */ 4:
                    message.groupStrIndex = reader.int32();
                    break;
                case /* repeated int32 market_group_str_indexes */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.marketGroupStrIndexes.push(reader.int32());
                    else
                        message.marketGroupStrIndexes.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NamedTypeId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 type_id = 1; */
        if (message.typeId !== 0)
            writer.tag(1, WireType.Varint).int32(message.typeId);
        /* int32 type_str_index = 2; */
        if (message.typeStrIndex !== 0)
            writer.tag(2, WireType.Varint).int32(message.typeStrIndex);
        /* int32 category_str_index = 3; */
        if (message.categoryStrIndex !== 0)
            writer.tag(3, WireType.Varint).int32(message.categoryStrIndex);
        /* int32 group_str_index = 4; */
        if (message.groupStrIndex !== 0)
            writer.tag(4, WireType.Varint).int32(message.groupStrIndex);
        /* repeated int32 market_group_str_indexes = 5; */
        if (message.marketGroupStrIndexes.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.marketGroupStrIndexes.length; i++)
                writer.int32(message.marketGroupStrIndexes[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.NamedTypeId
 */
export const NamedTypeId = new NamedTypeId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BasicItem$Type extends MessageType<BasicItem> {
    constructor() {
        super("etco_proto.BasicItem", [
            { no: 1, name: "type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<BasicItem>): BasicItem {
        const message = { typeId: 0, quantity: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BasicItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BasicItem): BasicItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 type_id */ 1:
                    message.typeId = reader.int32();
                    break;
                case /* int64 quantity */ 2:
                    message.quantity = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BasicItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 type_id = 1; */
        if (message.typeId !== 0)
            writer.tag(1, WireType.Varint).int32(message.typeId);
        /* int64 quantity = 2; */
        if (message.quantity !== 0)
            writer.tag(2, WireType.Varint).int64(message.quantity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.BasicItem
 */
export const BasicItem = new BasicItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NamedBasicItem$Type extends MessageType<NamedBasicItem> {
    constructor() {
        super("etco_proto.NamedBasicItem", [
            { no: 1, name: "type_id", kind: "message", T: () => NamedTypeId },
            { no: 2, name: "quantity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<NamedBasicItem>): NamedBasicItem {
        const message = { quantity: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NamedBasicItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NamedBasicItem): NamedBasicItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* etco_proto.NamedTypeId type_id */ 1:
                    message.typeId = NamedTypeId.internalBinaryRead(reader, reader.uint32(), options, message.typeId);
                    break;
                case /* int64 quantity */ 2:
                    message.quantity = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NamedBasicItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* etco_proto.NamedTypeId type_id = 1; */
        if (message.typeId)
            NamedTypeId.internalBinaryWrite(message.typeId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 quantity = 2; */
        if (message.quantity !== 0)
            writer.tag(2, WireType.Varint).int64(message.quantity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.NamedBasicItem
 */
export const NamedBasicItem = new NamedBasicItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopLocationInfo$Type extends MessageType<ShopLocationInfo> {
    constructor() {
        super("etco_proto.ShopLocationInfo", [
            { no: 1, name: "location_info", kind: "message", T: () => LocationInfo },
            { no: 2, name: "tax_rate", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<ShopLocationInfo>): ShopLocationInfo {
        const message = { taxRate: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopLocationInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopLocationInfo): ShopLocationInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* etco_proto.LocationInfo location_info */ 1:
                    message.locationInfo = LocationInfo.internalBinaryRead(reader, reader.uint32(), options, message.locationInfo);
                    break;
                case /* double tax_rate */ 2:
                    message.taxRate = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopLocationInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* etco_proto.LocationInfo location_info = 1; */
        if (message.locationInfo)
            LocationInfo.internalBinaryWrite(message.locationInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* double tax_rate = 2; */
        if (message.taxRate !== 0)
            writer.tag(2, WireType.Bit64).double(message.taxRate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.ShopLocationInfo
 */
export const ShopLocationInfo = new ShopLocationInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocationInfo$Type extends MessageType<LocationInfo> {
    constructor() {
        super("etco_proto.LocationInfo", [
            { no: 1, name: "location_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "location_str_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "is_structure", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "forbidden_structure", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "system_info", kind: "message", T: () => SystemInfo }
        ]);
    }
    create(value?: PartialMessage<LocationInfo>): LocationInfo {
        const message = { locationId: 0, locationStrIndex: 0, isStructure: false, forbiddenStructure: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LocationInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LocationInfo): LocationInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 location_id */ 1:
                    message.locationId = reader.int64().toNumber();
                    break;
                case /* int32 location_str_index */ 2:
                    message.locationStrIndex = reader.int32();
                    break;
                case /* bool is_structure */ 3:
                    message.isStructure = reader.bool();
                    break;
                case /* bool forbidden_structure */ 4:
                    message.forbiddenStructure = reader.bool();
                    break;
                case /* etco_proto.SystemInfo system_info */ 5:
                    message.systemInfo = SystemInfo.internalBinaryRead(reader, reader.uint32(), options, message.systemInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LocationInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 location_id = 1; */
        if (message.locationId !== 0)
            writer.tag(1, WireType.Varint).int64(message.locationId);
        /* int32 location_str_index = 2; */
        if (message.locationStrIndex !== 0)
            writer.tag(2, WireType.Varint).int32(message.locationStrIndex);
        /* bool is_structure = 3; */
        if (message.isStructure !== false)
            writer.tag(3, WireType.Varint).bool(message.isStructure);
        /* bool forbidden_structure = 4; */
        if (message.forbiddenStructure !== false)
            writer.tag(4, WireType.Varint).bool(message.forbiddenStructure);
        /* etco_proto.SystemInfo system_info = 5; */
        if (message.systemInfo)
            SystemInfo.internalBinaryWrite(message.systemInfo, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.LocationInfo
 */
export const LocationInfo = new LocationInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SystemInfo$Type extends MessageType<SystemInfo> {
    constructor() {
        super("etco_proto.SystemInfo", [
            { no: 1, name: "system_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "system_str_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "region_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "region_str_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SystemInfo>): SystemInfo {
        const message = { systemId: 0, systemStrIndex: 0, regionId: 0, regionStrIndex: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SystemInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SystemInfo): SystemInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 system_id */ 1:
                    message.systemId = reader.int32();
                    break;
                case /* int32 system_str_index */ 2:
                    message.systemStrIndex = reader.int32();
                    break;
                case /* int32 region_id */ 3:
                    message.regionId = reader.int32();
                    break;
                case /* int32 region_str_index */ 4:
                    message.regionStrIndex = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SystemInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 system_id = 1; */
        if (message.systemId !== 0)
            writer.tag(1, WireType.Varint).int32(message.systemId);
        /* int32 system_str_index = 2; */
        if (message.systemStrIndex !== 0)
            writer.tag(2, WireType.Varint).int32(message.systemStrIndex);
        /* int32 region_id = 3; */
        if (message.regionId !== 0)
            writer.tag(3, WireType.Varint).int32(message.regionId);
        /* int32 region_str_index = 4; */
        if (message.regionStrIndex !== 0)
            writer.tag(4, WireType.Varint).int32(message.regionStrIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.SystemInfo
 */
export const SystemInfo = new SystemInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CodeAndLocationId$Type extends MessageType<CodeAndLocationId> {
    constructor() {
        super("etco_proto.CodeAndLocationId", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "location_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<CodeAndLocationId>): CodeAndLocationId {
        const message = { code: "", locationId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CodeAndLocationId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CodeAndLocationId): CodeAndLocationId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* int64 location_id */ 2:
                    message.locationId = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CodeAndLocationId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* int64 location_id = 2; */
        if (message.locationId !== 0)
            writer.tag(2, WireType.Varint).int64(message.locationId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CodeAndLocationId
 */
export const CodeAndLocationId = new CodeAndLocationId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuybackAppraisal$Type extends MessageType<BuybackAppraisal> {
    constructor() {
        super("etco_proto.BuybackAppraisal", [
            { no: 1, name: "rejected", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "time", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BuybackParentItem },
            { no: 5, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "character_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "system_info", kind: "message", T: () => SystemInfo },
            { no: 8, name: "price", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 9, name: "tax", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 10, name: "tax_rate", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 11, name: "fee", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 12, name: "fee_per_m3", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<BuybackAppraisal>): BuybackAppraisal {
        const message = { rejected: false, code: "", time: 0, items: [], version: "", characterId: 0, price: 0, tax: 0, taxRate: 0, fee: 0, feePerM3: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BuybackAppraisal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuybackAppraisal): BuybackAppraisal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool rejected */ 1:
                    message.rejected = reader.bool();
                    break;
                case /* string code */ 2:
                    message.code = reader.string();
                    break;
                case /* int64 time */ 3:
                    message.time = reader.int64().toNumber();
                    break;
                case /* repeated etco_proto.BuybackParentItem items */ 4:
                    message.items.push(BuybackParentItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string version */ 5:
                    message.version = reader.string();
                    break;
                case /* int32 character_id */ 6:
                    message.characterId = reader.int32();
                    break;
                case /* etco_proto.SystemInfo system_info */ 7:
                    message.systemInfo = SystemInfo.internalBinaryRead(reader, reader.uint32(), options, message.systemInfo);
                    break;
                case /* double price */ 8:
                    message.price = reader.double();
                    break;
                case /* double tax */ 9:
                    message.tax = reader.double();
                    break;
                case /* double tax_rate */ 10:
                    message.taxRate = reader.double();
                    break;
                case /* double fee */ 11:
                    message.fee = reader.double();
                    break;
                case /* double fee_per_m3 */ 12:
                    message.feePerM3 = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BuybackAppraisal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool rejected = 1; */
        if (message.rejected !== false)
            writer.tag(1, WireType.Varint).bool(message.rejected);
        /* string code = 2; */
        if (message.code !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.code);
        /* int64 time = 3; */
        if (message.time !== 0)
            writer.tag(3, WireType.Varint).int64(message.time);
        /* repeated etco_proto.BuybackParentItem items = 4; */
        for (let i = 0; i < message.items.length; i++)
            BuybackParentItem.internalBinaryWrite(message.items[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string version = 5; */
        if (message.version !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.version);
        /* int32 character_id = 6; */
        if (message.characterId !== 0)
            writer.tag(6, WireType.Varint).int32(message.characterId);
        /* etco_proto.SystemInfo system_info = 7; */
        if (message.systemInfo)
            SystemInfo.internalBinaryWrite(message.systemInfo, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* double price = 8; */
        if (message.price !== 0)
            writer.tag(8, WireType.Bit64).double(message.price);
        /* double tax = 9; */
        if (message.tax !== 0)
            writer.tag(9, WireType.Bit64).double(message.tax);
        /* double tax_rate = 10; */
        if (message.taxRate !== 0)
            writer.tag(10, WireType.Bit64).double(message.taxRate);
        /* double fee = 11; */
        if (message.fee !== 0)
            writer.tag(11, WireType.Bit64).double(message.fee);
        /* double fee_per_m3 = 12; */
        if (message.feePerM3 !== 0)
            writer.tag(12, WireType.Bit64).double(message.feePerM3);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.BuybackAppraisal
 */
export const BuybackAppraisal = new BuybackAppraisal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuybackAppraisalStatus$Type extends MessageType<BuybackAppraisalStatus> {
    constructor() {
        super("etco_proto.BuybackAppraisalStatus", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "contract", kind: "message", T: () => Contract }
        ]);
    }
    create(value?: PartialMessage<BuybackAppraisalStatus>): BuybackAppraisalStatus {
        const message = { code: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BuybackAppraisalStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuybackAppraisalStatus): BuybackAppraisalStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* etco_proto.Contract contract */ 2:
                    message.contract = Contract.internalBinaryRead(reader, reader.uint32(), options, message.contract);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BuybackAppraisalStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* etco_proto.Contract contract = 2; */
        if (message.contract)
            Contract.internalBinaryWrite(message.contract, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.BuybackAppraisalStatus
 */
export const BuybackAppraisalStatus = new BuybackAppraisalStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuybackParentItem$Type extends MessageType<BuybackParentItem> {
    constructor() {
        super("etco_proto.BuybackParentItem", [
            { no: 1, name: "type_id", kind: "message", T: () => NamedTypeId },
            { no: 2, name: "quantity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "price_per_unit", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "description_str_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "fee_per_unit", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "children", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BuybackChildItem }
        ]);
    }
    create(value?: PartialMessage<BuybackParentItem>): BuybackParentItem {
        const message = { quantity: 0, pricePerUnit: 0, descriptionStrIndex: 0, feePerUnit: 0, children: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BuybackParentItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuybackParentItem): BuybackParentItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* etco_proto.NamedTypeId type_id */ 1:
                    message.typeId = NamedTypeId.internalBinaryRead(reader, reader.uint32(), options, message.typeId);
                    break;
                case /* int64 quantity */ 2:
                    message.quantity = reader.int64().toNumber();
                    break;
                case /* double price_per_unit */ 3:
                    message.pricePerUnit = reader.double();
                    break;
                case /* int32 description_str_index */ 4:
                    message.descriptionStrIndex = reader.int32();
                    break;
                case /* double fee_per_unit */ 5:
                    message.feePerUnit = reader.double();
                    break;
                case /* repeated etco_proto.BuybackChildItem children */ 6:
                    message.children.push(BuybackChildItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BuybackParentItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* etco_proto.NamedTypeId type_id = 1; */
        if (message.typeId)
            NamedTypeId.internalBinaryWrite(message.typeId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 quantity = 2; */
        if (message.quantity !== 0)
            writer.tag(2, WireType.Varint).int64(message.quantity);
        /* double price_per_unit = 3; */
        if (message.pricePerUnit !== 0)
            writer.tag(3, WireType.Bit64).double(message.pricePerUnit);
        /* int32 description_str_index = 4; */
        if (message.descriptionStrIndex !== 0)
            writer.tag(4, WireType.Varint).int32(message.descriptionStrIndex);
        /* double fee_per_unit = 5; */
        if (message.feePerUnit !== 0)
            writer.tag(5, WireType.Bit64).double(message.feePerUnit);
        /* repeated etco_proto.BuybackChildItem children = 6; */
        for (let i = 0; i < message.children.length; i++)
            BuybackChildItem.internalBinaryWrite(message.children[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.BuybackParentItem
 */
export const BuybackParentItem = new BuybackParentItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuybackChildItem$Type extends MessageType<BuybackChildItem> {
    constructor() {
        super("etco_proto.BuybackChildItem", [
            { no: 1, name: "type_id", kind: "message", T: () => NamedTypeId },
            { no: 2, name: "quantity_per_parent", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "price_per_unit", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "description_str_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<BuybackChildItem>): BuybackChildItem {
        const message = { quantityPerParent: 0, pricePerUnit: 0, descriptionStrIndex: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BuybackChildItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuybackChildItem): BuybackChildItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* etco_proto.NamedTypeId type_id */ 1:
                    message.typeId = NamedTypeId.internalBinaryRead(reader, reader.uint32(), options, message.typeId);
                    break;
                case /* double quantity_per_parent */ 2:
                    message.quantityPerParent = reader.double();
                    break;
                case /* double price_per_unit */ 3:
                    message.pricePerUnit = reader.double();
                    break;
                case /* int32 description_str_index */ 4:
                    message.descriptionStrIndex = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BuybackChildItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* etco_proto.NamedTypeId type_id = 1; */
        if (message.typeId)
            NamedTypeId.internalBinaryWrite(message.typeId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* double quantity_per_parent = 2; */
        if (message.quantityPerParent !== 0)
            writer.tag(2, WireType.Bit64).double(message.quantityPerParent);
        /* double price_per_unit = 3; */
        if (message.pricePerUnit !== 0)
            writer.tag(3, WireType.Bit64).double(message.pricePerUnit);
        /* int32 description_str_index = 4; */
        if (message.descriptionStrIndex !== 0)
            writer.tag(4, WireType.Varint).int32(message.descriptionStrIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.BuybackChildItem
 */
export const BuybackChildItem = new BuybackChildItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopAppraisal$Type extends MessageType<ShopAppraisal> {
    constructor() {
        super("etco_proto.ShopAppraisal", [
            { no: 1, name: "rejected", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "time", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ShopItem },
            { no: 5, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "character_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "location_info", kind: "message", T: () => LocationInfo },
            { no: 8, name: "price", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 9, name: "tax", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 10, name: "tax_rate", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<ShopAppraisal>): ShopAppraisal {
        const message = { rejected: false, code: "", time: 0, items: [], version: "", characterId: 0, price: 0, tax: 0, taxRate: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopAppraisal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopAppraisal): ShopAppraisal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool rejected */ 1:
                    message.rejected = reader.bool();
                    break;
                case /* string code */ 2:
                    message.code = reader.string();
                    break;
                case /* int64 time */ 3:
                    message.time = reader.int64().toNumber();
                    break;
                case /* repeated etco_proto.ShopItem items */ 4:
                    message.items.push(ShopItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string version */ 5:
                    message.version = reader.string();
                    break;
                case /* int32 character_id */ 6:
                    message.characterId = reader.int32();
                    break;
                case /* etco_proto.LocationInfo location_info */ 7:
                    message.locationInfo = LocationInfo.internalBinaryRead(reader, reader.uint32(), options, message.locationInfo);
                    break;
                case /* double price */ 8:
                    message.price = reader.double();
                    break;
                case /* double tax */ 9:
                    message.tax = reader.double();
                    break;
                case /* double tax_rate */ 10:
                    message.taxRate = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopAppraisal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool rejected = 1; */
        if (message.rejected !== false)
            writer.tag(1, WireType.Varint).bool(message.rejected);
        /* string code = 2; */
        if (message.code !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.code);
        /* int64 time = 3; */
        if (message.time !== 0)
            writer.tag(3, WireType.Varint).int64(message.time);
        /* repeated etco_proto.ShopItem items = 4; */
        for (let i = 0; i < message.items.length; i++)
            ShopItem.internalBinaryWrite(message.items[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string version = 5; */
        if (message.version !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.version);
        /* int32 character_id = 6; */
        if (message.characterId !== 0)
            writer.tag(6, WireType.Varint).int32(message.characterId);
        /* etco_proto.LocationInfo location_info = 7; */
        if (message.locationInfo)
            LocationInfo.internalBinaryWrite(message.locationInfo, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* double price = 8; */
        if (message.price !== 0)
            writer.tag(8, WireType.Bit64).double(message.price);
        /* double tax = 9; */
        if (message.tax !== 0)
            writer.tag(9, WireType.Bit64).double(message.tax);
        /* double tax_rate = 10; */
        if (message.taxRate !== 0)
            writer.tag(10, WireType.Bit64).double(message.taxRate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.ShopAppraisal
 */
export const ShopAppraisal = new ShopAppraisal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopAppraisalStatus$Type extends MessageType<ShopAppraisalStatus> {
    constructor() {
        super("etco_proto.ShopAppraisalStatus", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "contract", kind: "message", T: () => Contract },
            { no: 3, name: "in_purchase_queue", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ShopAppraisalStatus>): ShopAppraisalStatus {
        const message = { code: "", inPurchaseQueue: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopAppraisalStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopAppraisalStatus): ShopAppraisalStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* etco_proto.Contract contract */ 2:
                    message.contract = Contract.internalBinaryRead(reader, reader.uint32(), options, message.contract);
                    break;
                case /* bool in_purchase_queue */ 3:
                    message.inPurchaseQueue = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopAppraisalStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* etco_proto.Contract contract = 2; */
        if (message.contract)
            Contract.internalBinaryWrite(message.contract, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool in_purchase_queue = 3; */
        if (message.inPurchaseQueue !== false)
            writer.tag(3, WireType.Varint).bool(message.inPurchaseQueue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.ShopAppraisalStatus
 */
export const ShopAppraisalStatus = new ShopAppraisalStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopItem$Type extends MessageType<ShopItem> {
    constructor() {
        super("etco_proto.ShopItem", [
            { no: 1, name: "type_id", kind: "message", T: () => NamedTypeId },
            { no: 2, name: "quantity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "price_per_unit", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "description_str_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ShopItem>): ShopItem {
        const message = { quantity: 0, pricePerUnit: 0, descriptionStrIndex: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopItem): ShopItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* etco_proto.NamedTypeId type_id */ 1:
                    message.typeId = NamedTypeId.internalBinaryRead(reader, reader.uint32(), options, message.typeId);
                    break;
                case /* int64 quantity */ 2:
                    message.quantity = reader.int64().toNumber();
                    break;
                case /* double price_per_unit */ 3:
                    message.pricePerUnit = reader.double();
                    break;
                case /* int32 description_str_index */ 4:
                    message.descriptionStrIndex = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* etco_proto.NamedTypeId type_id = 1; */
        if (message.typeId)
            NamedTypeId.internalBinaryWrite(message.typeId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 quantity = 2; */
        if (message.quantity !== 0)
            writer.tag(2, WireType.Varint).int64(message.quantity);
        /* double price_per_unit = 3; */
        if (message.pricePerUnit !== 0)
            writer.tag(3, WireType.Bit64).double(message.pricePerUnit);
        /* int32 description_str_index = 4; */
        if (message.descriptionStrIndex !== 0)
            writer.tag(4, WireType.Varint).int32(message.descriptionStrIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.ShopItem
 */
export const ShopItem = new ShopItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PurchaseQueue$Type extends MessageType<PurchaseQueue> {
    constructor() {
        super("etco_proto.PurchaseQueue", [
            { no: 1, name: "codes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "location_info", kind: "message", T: () => LocationInfo }
        ]);
    }
    create(value?: PartialMessage<PurchaseQueue>): PurchaseQueue {
        const message = { codes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PurchaseQueue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PurchaseQueue): PurchaseQueue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string codes */ 1:
                    message.codes.push(reader.string());
                    break;
                case /* etco_proto.LocationInfo location_info */ 2:
                    message.locationInfo = LocationInfo.internalBinaryRead(reader, reader.uint32(), options, message.locationInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PurchaseQueue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string codes = 1; */
        for (let i = 0; i < message.codes.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.codes[i]);
        /* etco_proto.LocationInfo location_info = 2; */
        if (message.locationInfo)
            LocationInfo.internalBinaryWrite(message.locationInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.PurchaseQueue
 */
export const PurchaseQueue = new PurchaseQueue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Contract$Type extends MessageType<Contract> {
    constructor() {
        super("etco_proto.Contract", [
            { no: 1, name: "contract_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "status", kind: "enum", T: () => ["etco_proto.ContractStatus", ContractStatus] },
            { no: 3, name: "issued", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "expires", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 5, name: "location_info", kind: "message", T: () => LocationInfo },
            { no: 6, name: "price", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "issuer_corp_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "issuer_char_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "assignee_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "assignee_type", kind: "enum", T: () => ["etco_proto.ContractAssigneeType", ContractAssigneeType] }
        ]);
    }
    create(value?: PartialMessage<Contract>): Contract {
        const message = { contractId: 0, status: 0, issued: 0, expires: 0, price: 0, issuerCorpId: 0, issuerCharId: 0, assigneeId: 0, assigneeType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Contract>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Contract): Contract {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 contract_id */ 1:
                    message.contractId = reader.int32();
                    break;
                case /* etco_proto.ContractStatus status */ 2:
                    message.status = reader.int32();
                    break;
                case /* int64 issued */ 3:
                    message.issued = reader.int64().toNumber();
                    break;
                case /* int64 expires */ 4:
                    message.expires = reader.int64().toNumber();
                    break;
                case /* etco_proto.LocationInfo location_info */ 5:
                    message.locationInfo = LocationInfo.internalBinaryRead(reader, reader.uint32(), options, message.locationInfo);
                    break;
                case /* double price */ 6:
                    message.price = reader.double();
                    break;
                case /* int32 issuer_corp_id */ 7:
                    message.issuerCorpId = reader.int32();
                    break;
                case /* int32 issuer_char_id */ 8:
                    message.issuerCharId = reader.int32();
                    break;
                case /* int32 assignee_id */ 9:
                    message.assigneeId = reader.int32();
                    break;
                case /* etco_proto.ContractAssigneeType assignee_type */ 10:
                    message.assigneeType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Contract, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 contract_id = 1; */
        if (message.contractId !== 0)
            writer.tag(1, WireType.Varint).int32(message.contractId);
        /* etco_proto.ContractStatus status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).int32(message.status);
        /* int64 issued = 3; */
        if (message.issued !== 0)
            writer.tag(3, WireType.Varint).int64(message.issued);
        /* int64 expires = 4; */
        if (message.expires !== 0)
            writer.tag(4, WireType.Varint).int64(message.expires);
        /* etco_proto.LocationInfo location_info = 5; */
        if (message.locationInfo)
            LocationInfo.internalBinaryWrite(message.locationInfo, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* double price = 6; */
        if (message.price !== 0)
            writer.tag(6, WireType.Bit64).double(message.price);
        /* int32 issuer_corp_id = 7; */
        if (message.issuerCorpId !== 0)
            writer.tag(7, WireType.Varint).int32(message.issuerCorpId);
        /* int32 issuer_char_id = 8; */
        if (message.issuerCharId !== 0)
            writer.tag(8, WireType.Varint).int32(message.issuerCharId);
        /* int32 assignee_id = 9; */
        if (message.assigneeId !== 0)
            writer.tag(9, WireType.Varint).int32(message.assigneeId);
        /* etco_proto.ContractAssigneeType assignee_type = 10; */
        if (message.assigneeType !== 0)
            writer.tag(10, WireType.Varint).int32(message.assigneeType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.Contract
 */
export const Contract = new Contract$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuybackContractQueueEntry$Type extends MessageType<BuybackContractQueueEntry> {
    constructor() {
        super("etco_proto.BuybackContractQueueEntry", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "contract", kind: "message", T: () => Contract },
            { no: 3, name: "appraisal", kind: "message", T: () => BuybackAppraisal }
        ]);
    }
    create(value?: PartialMessage<BuybackContractQueueEntry>): BuybackContractQueueEntry {
        const message = { code: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BuybackContractQueueEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuybackContractQueueEntry): BuybackContractQueueEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* etco_proto.Contract contract */ 2:
                    message.contract = Contract.internalBinaryRead(reader, reader.uint32(), options, message.contract);
                    break;
                case /* etco_proto.BuybackAppraisal appraisal */ 3:
                    message.appraisal = BuybackAppraisal.internalBinaryRead(reader, reader.uint32(), options, message.appraisal);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BuybackContractQueueEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* etco_proto.Contract contract = 2; */
        if (message.contract)
            Contract.internalBinaryWrite(message.contract, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* etco_proto.BuybackAppraisal appraisal = 3; */
        if (message.appraisal)
            BuybackAppraisal.internalBinaryWrite(message.appraisal, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.BuybackContractQueueEntry
 */
export const BuybackContractQueueEntry = new BuybackContractQueueEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopContractQueueEntry$Type extends MessageType<ShopContractQueueEntry> {
    constructor() {
        super("etco_proto.ShopContractQueueEntry", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "contract", kind: "message", T: () => Contract },
            { no: 3, name: "appraisal", kind: "message", T: () => ShopAppraisal }
        ]);
    }
    create(value?: PartialMessage<ShopContractQueueEntry>): ShopContractQueueEntry {
        const message = { code: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopContractQueueEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopContractQueueEntry): ShopContractQueueEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* etco_proto.Contract contract */ 2:
                    message.contract = Contract.internalBinaryRead(reader, reader.uint32(), options, message.contract);
                    break;
                case /* etco_proto.ShopAppraisal appraisal */ 3:
                    message.appraisal = ShopAppraisal.internalBinaryRead(reader, reader.uint32(), options, message.appraisal);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopContractQueueEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* etco_proto.Contract contract = 2; */
        if (message.contract)
            Contract.internalBinaryWrite(message.contract, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* etco_proto.ShopAppraisal appraisal = 3; */
        if (message.appraisal)
            ShopAppraisal.internalBinaryWrite(message.appraisal, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.ShopContractQueueEntry
 */
export const ShopContractQueueEntry = new ShopContractQueueEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgTypePricing$Type extends MessageType<CfgTypePricing> {
    constructor() {
        super("etco_proto.CfgTypePricing", [
            { no: 1, name: "is_buy", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "percentile", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "modifier", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "market", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CfgTypePricing>): CfgTypePricing {
        const message = { isBuy: false, percentile: 0, modifier: 0, market: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgTypePricing>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgTypePricing): CfgTypePricing {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_buy */ 1:
                    message.isBuy = reader.bool();
                    break;
                case /* uint32 percentile */ 2:
                    message.percentile = reader.uint32();
                    break;
                case /* uint32 modifier */ 3:
                    message.modifier = reader.uint32();
                    break;
                case /* string market */ 4:
                    message.market = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgTypePricing, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_buy = 1; */
        if (message.isBuy !== false)
            writer.tag(1, WireType.Varint).bool(message.isBuy);
        /* uint32 percentile = 2; */
        if (message.percentile !== 0)
            writer.tag(2, WireType.Varint).uint32(message.percentile);
        /* uint32 modifier = 3; */
        if (message.modifier !== 0)
            writer.tag(3, WireType.Varint).uint32(message.modifier);
        /* string market = 4; */
        if (message.market !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.market);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CfgTypePricing
 */
export const CfgTypePricing = new CfgTypePricing$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgBuybackTypePricing$Type extends MessageType<CfgBuybackTypePricing> {
    constructor() {
        super("etco_proto.CfgBuybackTypePricing", [
            { no: 1, name: "pricing", kind: "message", T: () => CfgTypePricing },
            { no: 2, name: "reprocessing_efficiency", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CfgBuybackTypePricing>): CfgBuybackTypePricing {
        const message = { reprocessingEfficiency: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgBuybackTypePricing>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgBuybackTypePricing): CfgBuybackTypePricing {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* etco_proto.CfgTypePricing pricing */ 1:
                    message.pricing = CfgTypePricing.internalBinaryRead(reader, reader.uint32(), options, message.pricing);
                    break;
                case /* uint32 reprocessing_efficiency */ 2:
                    message.reprocessingEfficiency = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgBuybackTypePricing, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* etco_proto.CfgTypePricing pricing = 1; */
        if (message.pricing)
            CfgTypePricing.internalBinaryWrite(message.pricing, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 reprocessing_efficiency = 2; */
        if (message.reprocessingEfficiency !== 0)
            writer.tag(2, WireType.Varint).uint32(message.reprocessingEfficiency);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CfgBuybackTypePricing
 */
export const CfgBuybackTypePricing = new CfgBuybackTypePricing$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgShopTypePricing$Type extends MessageType<CfgShopTypePricing> {
    constructor() {
        super("etco_proto.CfgShopTypePricing", [
            { no: 1, name: "inner", kind: "message", T: () => CfgTypePricing }
        ]);
    }
    create(value?: PartialMessage<CfgShopTypePricing>): CfgShopTypePricing {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgShopTypePricing>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgShopTypePricing): CfgShopTypePricing {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* etco_proto.CfgTypePricing inner */ 1:
                    message.inner = CfgTypePricing.internalBinaryRead(reader, reader.uint32(), options, message.inner);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgShopTypePricing, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* etco_proto.CfgTypePricing inner = 1; */
        if (message.inner)
            CfgTypePricing.internalBinaryWrite(message.inner, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CfgShopTypePricing
 */
export const CfgShopTypePricing = new CfgShopTypePricing$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgBuybackSystemTypeBundle$Type extends MessageType<CfgBuybackSystemTypeBundle> {
    constructor() {
        super("etco_proto.CfgBuybackSystemTypeBundle", [
            { no: 1, name: "inner", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => CfgBuybackTypePricing } }
        ]);
    }
    create(value?: PartialMessage<CfgBuybackSystemTypeBundle>): CfgBuybackSystemTypeBundle {
        const message = { inner: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgBuybackSystemTypeBundle>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgBuybackSystemTypeBundle): CfgBuybackSystemTypeBundle {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, etco_proto.CfgBuybackTypePricing> inner */ 1:
                    this.binaryReadMap1(message.inner, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CfgBuybackSystemTypeBundle["inner"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CfgBuybackSystemTypeBundle["inner"] | undefined, val: CfgBuybackSystemTypeBundle["inner"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = CfgBuybackTypePricing.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field etco_proto.CfgBuybackSystemTypeBundle.inner");
            }
        }
        map[key ?? ""] = val ?? CfgBuybackTypePricing.create();
    }
    internalBinaryWrite(message: CfgBuybackSystemTypeBundle, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, etco_proto.CfgBuybackTypePricing> inner = 1; */
        for (let k of Object.keys(message.inner)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            CfgBuybackTypePricing.internalBinaryWrite(message.inner[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CfgBuybackSystemTypeBundle
 */
export const CfgBuybackSystemTypeBundle = new CfgBuybackSystemTypeBundle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgShopLocationTypeBundle$Type extends MessageType<CfgShopLocationTypeBundle> {
    constructor() {
        super("etco_proto.CfgShopLocationTypeBundle", [
            { no: 1, name: "inner", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => CfgShopTypePricing } }
        ]);
    }
    create(value?: PartialMessage<CfgShopLocationTypeBundle>): CfgShopLocationTypeBundle {
        const message = { inner: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgShopLocationTypeBundle>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgShopLocationTypeBundle): CfgShopLocationTypeBundle {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, etco_proto.CfgShopTypePricing> inner */ 1:
                    this.binaryReadMap1(message.inner, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CfgShopLocationTypeBundle["inner"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CfgShopLocationTypeBundle["inner"] | undefined, val: CfgShopLocationTypeBundle["inner"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = CfgShopTypePricing.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field etco_proto.CfgShopLocationTypeBundle.inner");
            }
        }
        map[key ?? ""] = val ?? CfgShopTypePricing.create();
    }
    internalBinaryWrite(message: CfgShopLocationTypeBundle, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, etco_proto.CfgShopTypePricing> inner = 1; */
        for (let k of Object.keys(message.inner)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            CfgShopTypePricing.internalBinaryWrite(message.inner[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CfgShopLocationTypeBundle
 */
export const CfgShopLocationTypeBundle = new CfgShopLocationTypeBundle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgBuybackSystem$Type extends MessageType<CfgBuybackSystem> {
    constructor() {
        super("etco_proto.CfgBuybackSystem", [
            { no: 1, name: "bundle_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "m3_fee", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "tax_rate", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<CfgBuybackSystem>): CfgBuybackSystem {
        const message = { bundleKey: "", m3Fee: 0, taxRate: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgBuybackSystem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgBuybackSystem): CfgBuybackSystem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string bundle_key */ 1:
                    message.bundleKey = reader.string();
                    break;
                case /* double m3_fee */ 2:
                    message.m3Fee = reader.double();
                    break;
                case /* double tax_rate */ 3:
                    message.taxRate = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgBuybackSystem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string bundle_key = 1; */
        if (message.bundleKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.bundleKey);
        /* double m3_fee = 2; */
        if (message.m3Fee !== 0)
            writer.tag(2, WireType.Bit64).double(message.m3Fee);
        /* double tax_rate = 3; */
        if (message.taxRate !== 0)
            writer.tag(3, WireType.Bit64).double(message.taxRate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CfgBuybackSystem
 */
export const CfgBuybackSystem = new CfgBuybackSystem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgShopLocation$Type extends MessageType<CfgShopLocation> {
    constructor() {
        super("etco_proto.CfgShopLocation", [
            { no: 1, name: "bundle_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "banned_flags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tax_rate", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<CfgShopLocation>): CfgShopLocation {
        const message = { bundleKey: "", bannedFlags: [], taxRate: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgShopLocation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgShopLocation): CfgShopLocation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string bundle_key */ 1:
                    message.bundleKey = reader.string();
                    break;
                case /* repeated string banned_flags */ 2:
                    message.bannedFlags.push(reader.string());
                    break;
                case /* double tax_rate */ 3:
                    message.taxRate = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgShopLocation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string bundle_key = 1; */
        if (message.bundleKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.bundleKey);
        /* repeated string banned_flags = 2; */
        for (let i = 0; i < message.bannedFlags.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.bannedFlags[i]);
        /* double tax_rate = 3; */
        if (message.taxRate !== 0)
            writer.tag(3, WireType.Bit64).double(message.taxRate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CfgShopLocation
 */
export const CfgShopLocation = new CfgShopLocation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgMarket$Type extends MessageType<CfgMarket> {
    constructor() {
        super("etco_proto.CfgMarket", [
            { no: 1, name: "refresh_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "location_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "is_structure", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CfgMarket>): CfgMarket {
        const message = { refreshToken: "", locationId: 0, isStructure: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgMarket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgMarket): CfgMarket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string refresh_token */ 1:
                    message.refreshToken = reader.string();
                    break;
                case /* int64 location_id */ 2:
                    message.locationId = reader.int64().toNumber();
                    break;
                case /* bool is_structure */ 3:
                    message.isStructure = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgMarket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string refresh_token = 1; */
        if (message.refreshToken !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.refreshToken);
        /* int64 location_id = 2; */
        if (message.locationId !== 0)
            writer.tag(2, WireType.Varint).int64(message.locationId);
        /* bool is_structure = 3; */
        if (message.isStructure !== false)
            writer.tag(3, WireType.Varint).bool(message.isStructure);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CfgMarket
 */
export const CfgMarket = new CfgMarket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgConstData$Type extends MessageType<CfgConstData> {
    constructor() {
        super("etco_proto.CfgConstData", [
            { no: 1, name: "purchase_max_active", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "make_purchase_cooldown", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "cancel_purchase_cooldown", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "corporation_web_refresh_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "structure_info_web_refresh_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "discord_channel", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "buyback_contract_notifications", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "shop_contract_notifications", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "purchase_notifications", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CfgConstData>): CfgConstData {
        const message = { purchaseMaxActive: 0, makePurchaseCooldown: 0, cancelPurchaseCooldown: 0, corporationWebRefreshToken: "", structureInfoWebRefreshToken: "", discordChannel: "", buybackContractNotifications: false, shopContractNotifications: false, purchaseNotifications: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgConstData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgConstData): CfgConstData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 purchase_max_active */ 1:
                    message.purchaseMaxActive = reader.int32();
                    break;
                case /* int32 make_purchase_cooldown */ 2:
                    message.makePurchaseCooldown = reader.int32();
                    break;
                case /* int32 cancel_purchase_cooldown */ 3:
                    message.cancelPurchaseCooldown = reader.int32();
                    break;
                case /* string corporation_web_refresh_token */ 4:
                    message.corporationWebRefreshToken = reader.string();
                    break;
                case /* string structure_info_web_refresh_token */ 5:
                    message.structureInfoWebRefreshToken = reader.string();
                    break;
                case /* string discord_channel */ 6:
                    message.discordChannel = reader.string();
                    break;
                case /* bool buyback_contract_notifications */ 7:
                    message.buybackContractNotifications = reader.bool();
                    break;
                case /* bool shop_contract_notifications */ 8:
                    message.shopContractNotifications = reader.bool();
                    break;
                case /* bool purchase_notifications */ 9:
                    message.purchaseNotifications = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgConstData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 purchase_max_active = 1; */
        if (message.purchaseMaxActive !== 0)
            writer.tag(1, WireType.Varint).int32(message.purchaseMaxActive);
        /* int32 make_purchase_cooldown = 2; */
        if (message.makePurchaseCooldown !== 0)
            writer.tag(2, WireType.Varint).int32(message.makePurchaseCooldown);
        /* int32 cancel_purchase_cooldown = 3; */
        if (message.cancelPurchaseCooldown !== 0)
            writer.tag(3, WireType.Varint).int32(message.cancelPurchaseCooldown);
        /* string corporation_web_refresh_token = 4; */
        if (message.corporationWebRefreshToken !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.corporationWebRefreshToken);
        /* string structure_info_web_refresh_token = 5; */
        if (message.structureInfoWebRefreshToken !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.structureInfoWebRefreshToken);
        /* string discord_channel = 6; */
        if (message.discordChannel !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.discordChannel);
        /* bool buyback_contract_notifications = 7; */
        if (message.buybackContractNotifications !== false)
            writer.tag(7, WireType.Varint).bool(message.buybackContractNotifications);
        /* bool shop_contract_notifications = 8; */
        if (message.shopContractNotifications !== false)
            writer.tag(8, WireType.Varint).bool(message.shopContractNotifications);
        /* bool purchase_notifications = 9; */
        if (message.purchaseNotifications !== false)
            writer.tag(9, WireType.Varint).bool(message.purchaseNotifications);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CfgConstData
 */
export const CfgConstData = new CfgConstData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgAuthList$Type extends MessageType<CfgAuthList> {
    constructor() {
        super("etco_proto.CfgAuthList", [
            { no: 1, name: "banned_character_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "permit_character_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "banned_corporation_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "permit_corporation_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "permit_alliance_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CfgAuthList>): CfgAuthList {
        const message = { bannedCharacterIds: [], permitCharacterIds: [], bannedCorporationIds: [], permitCorporationIds: [], permitAllianceIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgAuthList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgAuthList): CfgAuthList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 banned_character_ids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.bannedCharacterIds.push(reader.int32());
                    else
                        message.bannedCharacterIds.push(reader.int32());
                    break;
                case /* repeated int32 permit_character_ids */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.permitCharacterIds.push(reader.int32());
                    else
                        message.permitCharacterIds.push(reader.int32());
                    break;
                case /* repeated int32 banned_corporation_ids */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.bannedCorporationIds.push(reader.int32());
                    else
                        message.bannedCorporationIds.push(reader.int32());
                    break;
                case /* repeated int32 permit_corporation_ids */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.permitCorporationIds.push(reader.int32());
                    else
                        message.permitCorporationIds.push(reader.int32());
                    break;
                case /* repeated int32 permit_alliance_ids */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.permitAllianceIds.push(reader.int32());
                    else
                        message.permitAllianceIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgAuthList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 banned_character_ids = 1; */
        if (message.bannedCharacterIds.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.bannedCharacterIds.length; i++)
                writer.int32(message.bannedCharacterIds[i]);
            writer.join();
        }
        /* repeated int32 permit_character_ids = 2; */
        if (message.permitCharacterIds.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.permitCharacterIds.length; i++)
                writer.int32(message.permitCharacterIds[i]);
            writer.join();
        }
        /* repeated int32 banned_corporation_ids = 3; */
        if (message.bannedCorporationIds.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.bannedCorporationIds.length; i++)
                writer.int32(message.bannedCorporationIds[i]);
            writer.join();
        }
        /* repeated int32 permit_corporation_ids = 4; */
        if (message.permitCorporationIds.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.permitCorporationIds.length; i++)
                writer.int32(message.permitCorporationIds[i]);
            writer.join();
        }
        /* repeated int32 permit_alliance_ids = 5; */
        if (message.permitAllianceIds.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.permitAllianceIds.length; i++)
                writer.int32(message.permitAllianceIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CfgAuthList
 */
export const CfgAuthList = new CfgAuthList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypesResponse$Type extends MessageType<TypesResponse> {
    constructor() {
        super("etco_proto.TypesResponse", [
            { no: 1, name: "types", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<TypesResponse>): TypesResponse {
        const message = { types: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TypesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TypesResponse): TypesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 types */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.types.push(reader.int32());
                    else
                        message.types.push(reader.int32());
                    break;
                case /* etco_proto.ErrorResponse error */ 2:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TypesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 types = 1; */
        if (message.types.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.types.length; i++)
                writer.int32(message.types[i]);
            writer.join();
        }
        /* etco_proto.ErrorResponse error = 2; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.TypesResponse
 */
export const TypesResponse = new TypesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NamedTypesRequest$Type extends MessageType<NamedTypesRequest> {
    constructor() {
        super("etco_proto.NamedTypesRequest", [
            { no: 1, name: "types", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<NamedTypesRequest>): NamedTypesRequest {
        const message = { types: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NamedTypesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NamedTypesRequest): NamedTypesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 types */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.types.push(reader.int32());
                    else
                        message.types.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NamedTypesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 types = 1; */
        if (message.types.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.types.length; i++)
                writer.int32(message.types[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.NamedTypesRequest
 */
export const NamedTypesRequest = new NamedTypesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NamedTypesResponse$Type extends MessageType<NamedTypesResponse> {
    constructor() {
        super("etco_proto.NamedTypesResponse", [
            { no: 1, name: "types", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedTypeId },
            { no: 2, name: "strs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<NamedTypesResponse>): NamedTypesResponse {
        const message = { types: [], strs: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NamedTypesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NamedTypesResponse): NamedTypesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated etco_proto.NamedTypeId types */ 1:
                    message.types.push(NamedTypeId.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string strs */ 2:
                    message.strs.push(reader.string());
                    break;
                case /* etco_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NamedTypesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated etco_proto.NamedTypeId types = 1; */
        for (let i = 0; i < message.types.length; i++)
            NamedTypeId.internalBinaryWrite(message.types[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string strs = 2; */
        for (let i = 0; i < message.strs.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.strs[i]);
        /* etco_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.NamedTypesResponse
 */
export const NamedTypesResponse = new NamedTypesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SystemsRequest$Type extends MessageType<SystemsRequest> {
    constructor() {
        super("etco_proto.SystemsRequest", [
            { no: 1, name: "systems", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SystemsRequest>): SystemsRequest {
        const message = { systems: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SystemsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SystemsRequest): SystemsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 systems */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.systems.push(reader.int32());
                    else
                        message.systems.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SystemsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 systems = 1; */
        if (message.systems.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.systems.length; i++)
                writer.int32(message.systems[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.SystemsRequest
 */
export const SystemsRequest = new SystemsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SystemsResponse$Type extends MessageType<SystemsResponse> {
    constructor() {
        super("etco_proto.SystemsResponse", [
            { no: 1, name: "systems", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SystemInfo },
            { no: 2, name: "strs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<SystemsResponse>): SystemsResponse {
        const message = { systems: [], strs: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SystemsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SystemsResponse): SystemsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated etco_proto.SystemInfo systems */ 1:
                    message.systems.push(SystemInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string strs */ 2:
                    message.strs.push(reader.string());
                    break;
                case /* etco_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SystemsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated etco_proto.SystemInfo systems = 1; */
        for (let i = 0; i < message.systems.length; i++)
            SystemInfo.internalBinaryWrite(message.systems[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string strs = 2; */
        for (let i = 0; i < message.strs.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.strs[i]);
        /* etco_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.SystemsResponse
 */
export const SystemsResponse = new SystemsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AllShopLocationsResponse$Type extends MessageType<AllShopLocationsResponse> {
    constructor() {
        super("etco_proto.AllShopLocationsResponse", [
            { no: 1, name: "locations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ShopLocationInfo },
            { no: 2, name: "strs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<AllShopLocationsResponse>): AllShopLocationsResponse {
        const message = { locations: [], strs: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AllShopLocationsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AllShopLocationsResponse): AllShopLocationsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated etco_proto.ShopLocationInfo locations */ 1:
                    message.locations.push(ShopLocationInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string strs */ 2:
                    message.strs.push(reader.string());
                    break;
                case /* etco_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AllShopLocationsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated etco_proto.ShopLocationInfo locations = 1; */
        for (let i = 0; i < message.locations.length; i++)
            ShopLocationInfo.internalBinaryWrite(message.locations[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string strs = 2; */
        for (let i = 0; i < message.strs.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.strs[i]);
        /* etco_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.AllShopLocationsResponse
 */
export const AllShopLocationsResponse = new AllShopLocationsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocationsRequest$Type extends MessageType<LocationsRequest> {
    constructor() {
        super("etco_proto.LocationsRequest", [
            { no: 1, name: "locations", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<LocationsRequest>): LocationsRequest {
        const message = { locations: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LocationsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LocationsRequest): LocationsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int64 locations */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.locations.push(reader.int64().toNumber());
                    else
                        message.locations.push(reader.int64().toNumber());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LocationsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int64 locations = 1; */
        if (message.locations.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.locations.length; i++)
                writer.int64(message.locations[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.LocationsRequest
 */
export const LocationsRequest = new LocationsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocationsResponse$Type extends MessageType<LocationsResponse> {
    constructor() {
        super("etco_proto.LocationsResponse", [
            { no: 1, name: "locations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => LocationInfo },
            { no: 2, name: "strs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<LocationsResponse>): LocationsResponse {
        const message = { locations: [], strs: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LocationsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LocationsResponse): LocationsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated etco_proto.LocationInfo locations */ 1:
                    message.locations.push(LocationInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string strs */ 2:
                    message.strs.push(reader.string());
                    break;
                case /* etco_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LocationsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated etco_proto.LocationInfo locations = 1; */
        for (let i = 0; i < message.locations.length; i++)
            LocationInfo.internalBinaryWrite(message.locations[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string strs = 2; */
        for (let i = 0; i < message.strs.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.strs[i]);
        /* etco_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.LocationsResponse
 */
export const LocationsResponse = new LocationsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ParseRequest$Type extends MessageType<ParseRequest> {
    constructor() {
        super("etco_proto.ParseRequest", [
            { no: 1, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ParseRequest>): ParseRequest {
        const message = { text: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ParseRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ParseRequest): ParseRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string text */ 1:
                    message.text = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ParseRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string text = 1; */
        if (message.text !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.text);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.ParseRequest
 */
export const ParseRequest = new ParseRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ParseResponse$Type extends MessageType<ParseResponse> {
    constructor() {
        super("etco_proto.ParseResponse", [
            { no: 1, name: "known_items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedBasicItem },
            { no: 2, name: "unknown_items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedBasicItem },
            { no: 3, name: "strs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<ParseResponse>): ParseResponse {
        const message = { knownItems: [], unknownItems: [], strs: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ParseResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ParseResponse): ParseResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated etco_proto.NamedBasicItem known_items */ 1:
                    message.knownItems.push(NamedBasicItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated etco_proto.NamedBasicItem unknown_items */ 2:
                    message.unknownItems.push(NamedBasicItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string strs */ 3:
                    message.strs.push(reader.string());
                    break;
                case /* etco_proto.ErrorResponse error */ 4:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ParseResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated etco_proto.NamedBasicItem known_items = 1; */
        for (let i = 0; i < message.knownItems.length; i++)
            NamedBasicItem.internalBinaryWrite(message.knownItems[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated etco_proto.NamedBasicItem unknown_items = 2; */
        for (let i = 0; i < message.unknownItems.length; i++)
            NamedBasicItem.internalBinaryWrite(message.unknownItems[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated string strs = 3; */
        for (let i = 0; i < message.strs.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.strs[i]);
        /* etco_proto.ErrorResponse error = 4; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.ParseResponse
 */
export const ParseResponse = new ParseResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginRequest$Type extends MessageType<LoginRequest> {
    constructor() {
        super("etco_proto.LoginRequest", [
            { no: 1, name: "access_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "app", kind: "enum", T: () => ["etco_proto.EsiApp", EsiApp] }
        ]);
    }
    create(value?: PartialMessage<LoginRequest>): LoginRequest {
        const message = { accessCode: "", app: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LoginRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginRequest): LoginRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string access_code */ 1:
                    message.accessCode = reader.string();
                    break;
                case /* etco_proto.EsiApp app */ 2:
                    message.app = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string access_code = 1; */
        if (message.accessCode !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accessCode);
        /* etco_proto.EsiApp app = 2; */
        if (message.app !== 0)
            writer.tag(2, WireType.Varint).int32(message.app);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.LoginRequest
 */
export const LoginRequest = new LoginRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginResponse$Type extends MessageType<LoginResponse> {
    constructor() {
        super("etco_proto.LoginResponse", [
            { no: 1, name: "refresh_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "character_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "admin", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<LoginResponse>): LoginResponse {
        const message = { refreshToken: "", characterId: 0, admin: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LoginResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginResponse): LoginResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string refresh_token */ 1:
                    message.refreshToken = reader.string();
                    break;
                case /* int32 character_id */ 2:
                    message.characterId = reader.int32();
                    break;
                case /* bool admin */ 3:
                    message.admin = reader.bool();
                    break;
                case /* etco_proto.ErrorResponse error */ 4:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string refresh_token = 1; */
        if (message.refreshToken !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.refreshToken);
        /* int32 character_id = 2; */
        if (message.characterId !== 0)
            writer.tag(2, WireType.Varint).int32(message.characterId);
        /* bool admin = 3; */
        if (message.admin !== false)
            writer.tag(3, WireType.Varint).bool(message.admin);
        /* etco_proto.ErrorResponse error = 4; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.LoginResponse
 */
export const LoginResponse = new LoginResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenInfoRequest$Type extends MessageType<TokenInfoRequest> {
    constructor() {
        super("etco_proto.TokenInfoRequest", [
            { no: 1, name: "refresh_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "app", kind: "enum", T: () => ["etco_proto.EsiApp", EsiApp] }
        ]);
    }
    create(value?: PartialMessage<TokenInfoRequest>): TokenInfoRequest {
        const message = { refreshToken: "", app: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TokenInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenInfoRequest): TokenInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string refresh_token */ 1:
                    message.refreshToken = reader.string();
                    break;
                case /* etco_proto.EsiApp app */ 2:
                    message.app = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string refresh_token = 1; */
        if (message.refreshToken !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.refreshToken);
        /* etco_proto.EsiApp app = 2; */
        if (message.app !== 0)
            writer.tag(2, WireType.Varint).int32(message.app);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.TokenInfoRequest
 */
export const TokenInfoRequest = new TokenInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenInfoResponse$Type extends MessageType<TokenInfoResponse> {
    constructor() {
        super("etco_proto.TokenInfoResponse", [
            { no: 1, name: "character_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "admin", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<TokenInfoResponse>): TokenInfoResponse {
        const message = { characterId: 0, admin: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TokenInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenInfoResponse): TokenInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 character_id */ 1:
                    message.characterId = reader.int32();
                    break;
                case /* bool admin */ 2:
                    message.admin = reader.bool();
                    break;
                case /* etco_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 character_id = 1; */
        if (message.characterId !== 0)
            writer.tag(1, WireType.Varint).int32(message.characterId);
        /* bool admin = 2; */
        if (message.admin !== false)
            writer.tag(2, WireType.Varint).bool(message.admin);
        /* etco_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.TokenInfoResponse
 */
export const TokenInfoResponse = new TokenInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EntityInfoRequest$Type extends MessageType<EntityInfoRequest> {
    constructor() {
        super("etco_proto.EntityInfoRequest", [
            { no: 1, name: "entity_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<EntityInfoRequest>): EntityInfoRequest {
        const message = { entityId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EntityInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EntityInfoRequest): EntityInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 entity_id */ 1:
                    message.entityId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EntityInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 entity_id = 1; */
        if (message.entityId !== 0)
            writer.tag(1, WireType.Varint).int32(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.EntityInfoRequest
 */
export const EntityInfoRequest = new EntityInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CharacterInfoResponse$Type extends MessageType<CharacterInfoResponse> {
    constructor() {
        super("etco_proto.CharacterInfoResponse", [
            { no: 1, name: "character_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "corporation_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "alliance_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<CharacterInfoResponse>): CharacterInfoResponse {
        const message = { characterId: 0, corporationId: 0, allianceId: 0, name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CharacterInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CharacterInfoResponse): CharacterInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 character_id */ 1:
                    message.characterId = reader.int32();
                    break;
                case /* int32 corporation_id */ 2:
                    message.corporationId = reader.int32();
                    break;
                case /* int32 alliance_id */ 3:
                    message.allianceId = reader.int32();
                    break;
                case /* string name */ 4:
                    message.name = reader.string();
                    break;
                case /* etco_proto.ErrorResponse error */ 5:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CharacterInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 character_id = 1; */
        if (message.characterId !== 0)
            writer.tag(1, WireType.Varint).int32(message.characterId);
        /* int32 corporation_id = 2; */
        if (message.corporationId !== 0)
            writer.tag(2, WireType.Varint).int32(message.corporationId);
        /* int32 alliance_id = 3; */
        if (message.allianceId !== 0)
            writer.tag(3, WireType.Varint).int32(message.allianceId);
        /* string name = 4; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        /* etco_proto.ErrorResponse error = 5; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CharacterInfoResponse
 */
export const CharacterInfoResponse = new CharacterInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CorporationInfoResponse$Type extends MessageType<CorporationInfoResponse> {
    constructor() {
        super("etco_proto.CorporationInfoResponse", [
            { no: 1, name: "corporation_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "alliance_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<CorporationInfoResponse>): CorporationInfoResponse {
        const message = { corporationId: 0, allianceId: 0, name: "", ticker: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CorporationInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CorporationInfoResponse): CorporationInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 corporation_id */ 1:
                    message.corporationId = reader.int32();
                    break;
                case /* int32 alliance_id */ 2:
                    message.allianceId = reader.int32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string ticker */ 4:
                    message.ticker = reader.string();
                    break;
                case /* etco_proto.ErrorResponse error */ 5:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CorporationInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 corporation_id = 1; */
        if (message.corporationId !== 0)
            writer.tag(1, WireType.Varint).int32(message.corporationId);
        /* int32 alliance_id = 2; */
        if (message.allianceId !== 0)
            writer.tag(2, WireType.Varint).int32(message.allianceId);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string ticker = 4; */
        if (message.ticker !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.ticker);
        /* etco_proto.ErrorResponse error = 5; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CorporationInfoResponse
 */
export const CorporationInfoResponse = new CorporationInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AllianceInfoResponse$Type extends MessageType<AllianceInfoResponse> {
    constructor() {
        super("etco_proto.AllianceInfoResponse", [
            { no: 1, name: "alliance_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<AllianceInfoResponse>): AllianceInfoResponse {
        const message = { allianceId: 0, name: "", ticker: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AllianceInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AllianceInfoResponse): AllianceInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 alliance_id */ 1:
                    message.allianceId = reader.int32();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string ticker */ 3:
                    message.ticker = reader.string();
                    break;
                case /* etco_proto.ErrorResponse error */ 4:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AllianceInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 alliance_id = 1; */
        if (message.allianceId !== 0)
            writer.tag(1, WireType.Varint).int32(message.allianceId);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string ticker = 3; */
        if (message.ticker !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.ticker);
        /* etco_proto.ErrorResponse error = 4; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.AllianceInfoResponse
 */
export const AllianceInfoResponse = new AllianceInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NewAppraisalRequest$Type extends MessageType<NewAppraisalRequest> {
    constructor() {
        super("etco_proto.NewAppraisalRequest", [
            { no: 1, name: "territory_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BasicItem }
        ]);
    }
    create(value?: PartialMessage<NewAppraisalRequest>): NewAppraisalRequest {
        const message = { territoryId: 0, items: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NewAppraisalRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NewAppraisalRequest): NewAppraisalRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 territory_id */ 1:
                    message.territoryId = reader.int64().toNumber();
                    break;
                case /* repeated etco_proto.BasicItem items */ 2:
                    message.items.push(BasicItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NewAppraisalRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 territory_id = 1; */
        if (message.territoryId !== 0)
            writer.tag(1, WireType.Varint).int64(message.territoryId);
        /* repeated etco_proto.BasicItem items = 2; */
        for (let i = 0; i < message.items.length; i++)
            BasicItem.internalBinaryWrite(message.items[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.NewAppraisalRequest
 */
export const NewAppraisalRequest = new NewAppraisalRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuybackContractQueueResponse$Type extends MessageType<BuybackContractQueueResponse> {
    constructor() {
        super("etco_proto.BuybackContractQueueResponse", [
            { no: 1, name: "queue", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BuybackContractQueueEntry },
            { no: 2, name: "strs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "authorized", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<BuybackContractQueueResponse>): BuybackContractQueueResponse {
        const message = { queue: [], strs: [], authorized: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BuybackContractQueueResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuybackContractQueueResponse): BuybackContractQueueResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated etco_proto.BuybackContractQueueEntry queue */ 1:
                    message.queue.push(BuybackContractQueueEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string strs */ 2:
                    message.strs.push(reader.string());
                    break;
                case /* bool authorized */ 3:
                    message.authorized = reader.bool();
                    break;
                case /* etco_proto.ErrorResponse error */ 4:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BuybackContractQueueResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated etco_proto.BuybackContractQueueEntry queue = 1; */
        for (let i = 0; i < message.queue.length; i++)
            BuybackContractQueueEntry.internalBinaryWrite(message.queue[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string strs = 2; */
        for (let i = 0; i < message.strs.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.strs[i]);
        /* bool authorized = 3; */
        if (message.authorized !== false)
            writer.tag(3, WireType.Varint).bool(message.authorized);
        /* etco_proto.ErrorResponse error = 4; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.BuybackContractQueueResponse
 */
export const BuybackContractQueueResponse = new BuybackContractQueueResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopContractQueueResponse$Type extends MessageType<ShopContractQueueResponse> {
    constructor() {
        super("etco_proto.ShopContractQueueResponse", [
            { no: 1, name: "queue", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ShopContractQueueEntry },
            { no: 2, name: "strs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "authorized", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<ShopContractQueueResponse>): ShopContractQueueResponse {
        const message = { queue: [], strs: [], authorized: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopContractQueueResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopContractQueueResponse): ShopContractQueueResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated etco_proto.ShopContractQueueEntry queue */ 1:
                    message.queue.push(ShopContractQueueEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string strs */ 2:
                    message.strs.push(reader.string());
                    break;
                case /* bool authorized */ 3:
                    message.authorized = reader.bool();
                    break;
                case /* etco_proto.ErrorResponse error */ 4:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopContractQueueResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated etco_proto.ShopContractQueueEntry queue = 1; */
        for (let i = 0; i < message.queue.length; i++)
            ShopContractQueueEntry.internalBinaryWrite(message.queue[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string strs = 2; */
        for (let i = 0; i < message.strs.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.strs[i]);
        /* bool authorized = 3; */
        if (message.authorized !== false)
            writer.tag(3, WireType.Varint).bool(message.authorized);
        /* etco_proto.ErrorResponse error = 4; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.ShopContractQueueResponse
 */
export const ShopContractQueueResponse = new ShopContractQueueResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PurchaseQueueResponse$Type extends MessageType<PurchaseQueueResponse> {
    constructor() {
        super("etco_proto.PurchaseQueueResponse", [
            { no: 1, name: "queue", kind: "map", K: 3 /*ScalarType.INT64*/, V: { kind: "message", T: () => PurchaseQueue } },
            { no: 2, name: "strs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "authorized", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<PurchaseQueueResponse>): PurchaseQueueResponse {
        const message = { queue: {}, strs: [], authorized: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PurchaseQueueResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PurchaseQueueResponse): PurchaseQueueResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int64, etco_proto.PurchaseQueue> queue */ 1:
                    this.binaryReadMap1(message.queue, reader, options);
                    break;
                case /* repeated string strs */ 2:
                    message.strs.push(reader.string());
                    break;
                case /* bool authorized */ 3:
                    message.authorized = reader.bool();
                    break;
                case /* etco_proto.ErrorResponse error */ 4:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: PurchaseQueueResponse["queue"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof PurchaseQueueResponse["queue"] | undefined, val: PurchaseQueueResponse["queue"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int64().toString();
                    break;
                case 2:
                    val = PurchaseQueue.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field etco_proto.PurchaseQueueResponse.queue");
            }
        }
        map[key ?? "0"] = val ?? PurchaseQueue.create();
    }
    internalBinaryWrite(message: PurchaseQueueResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int64, etco_proto.PurchaseQueue> queue = 1; */
        for (let k of Object.keys(message.queue)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int64(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            PurchaseQueue.internalBinaryWrite(message.queue[k], writer, options);
            writer.join().join();
        }
        /* repeated string strs = 2; */
        for (let i = 0; i < message.strs.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.strs[i]);
        /* bool authorized = 3; */
        if (message.authorized !== false)
            writer.tag(3, WireType.Varint).bool(message.authorized);
        /* etco_proto.ErrorResponse error = 4; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.PurchaseQueueResponse
 */
export const PurchaseQueueResponse = new PurchaseQueueResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocationPurchaseQueueRequest$Type extends MessageType<LocationPurchaseQueueRequest> {
    constructor() {
        super("etco_proto.LocationPurchaseQueueRequest", [
            { no: 1, name: "location_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "refresh_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LocationPurchaseQueueRequest>): LocationPurchaseQueueRequest {
        const message = { locationId: 0, refreshToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LocationPurchaseQueueRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LocationPurchaseQueueRequest): LocationPurchaseQueueRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 location_id */ 1:
                    message.locationId = reader.int64().toNumber();
                    break;
                case /* string refresh_token */ 2:
                    message.refreshToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LocationPurchaseQueueRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 location_id = 1; */
        if (message.locationId !== 0)
            writer.tag(1, WireType.Varint).int64(message.locationId);
        /* string refresh_token = 2; */
        if (message.refreshToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.refreshToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.LocationPurchaseQueueRequest
 */
export const LocationPurchaseQueueRequest = new LocationPurchaseQueueRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocationPurchaseQueueResponse$Type extends MessageType<LocationPurchaseQueueResponse> {
    constructor() {
        super("etco_proto.LocationPurchaseQueueResponse", [
            { no: 1, name: "queue", kind: "message", T: () => PurchaseQueue },
            { no: 2, name: "strs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "authorized", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<LocationPurchaseQueueResponse>): LocationPurchaseQueueResponse {
        const message = { strs: [], authorized: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LocationPurchaseQueueResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LocationPurchaseQueueResponse): LocationPurchaseQueueResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* etco_proto.PurchaseQueue queue */ 1:
                    message.queue = PurchaseQueue.internalBinaryRead(reader, reader.uint32(), options, message.queue);
                    break;
                case /* repeated string strs */ 2:
                    message.strs.push(reader.string());
                    break;
                case /* bool authorized */ 3:
                    message.authorized = reader.bool();
                    break;
                case /* etco_proto.ErrorResponse error */ 4:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LocationPurchaseQueueResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* etco_proto.PurchaseQueue queue = 1; */
        if (message.queue)
            PurchaseQueue.internalBinaryWrite(message.queue, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string strs = 2; */
        for (let i = 0; i < message.strs.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.strs[i]);
        /* bool authorized = 3; */
        if (message.authorized !== false)
            writer.tag(3, WireType.Varint).bool(message.authorized);
        /* etco_proto.ErrorResponse error = 4; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.LocationPurchaseQueueResponse
 */
export const LocationPurchaseQueueResponse = new LocationPurchaseQueueResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeletePurchasesRequest$Type extends MessageType<DeletePurchasesRequest> {
    constructor() {
        super("etco_proto.DeletePurchasesRequest", [
            { no: 1, name: "entries", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CodeAndLocationId },
            { no: 2, name: "refresh_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeletePurchasesRequest>): DeletePurchasesRequest {
        const message = { entries: [], refreshToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeletePurchasesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeletePurchasesRequest): DeletePurchasesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated etco_proto.CodeAndLocationId entries */ 1:
                    message.entries.push(CodeAndLocationId.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string refresh_token */ 2:
                    message.refreshToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeletePurchasesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated etco_proto.CodeAndLocationId entries = 1; */
        for (let i = 0; i < message.entries.length; i++)
            CodeAndLocationId.internalBinaryWrite(message.entries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string refresh_token = 2; */
        if (message.refreshToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.refreshToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.DeletePurchasesRequest
 */
export const DeletePurchasesRequest = new DeletePurchasesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeletePurchasesResponse$Type extends MessageType<DeletePurchasesResponse> {
    constructor() {
        super("etco_proto.DeletePurchasesResponse", [
            { no: 1, name: "authorized", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<DeletePurchasesResponse>): DeletePurchasesResponse {
        const message = { authorized: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeletePurchasesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeletePurchasesResponse): DeletePurchasesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool authorized */ 1:
                    message.authorized = reader.bool();
                    break;
                case /* etco_proto.ErrorResponse error */ 2:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeletePurchasesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool authorized = 1; */
        if (message.authorized !== false)
            writer.tag(1, WireType.Varint).bool(message.authorized);
        /* etco_proto.ErrorResponse error = 2; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.DeletePurchasesResponse
 */
export const DeletePurchasesResponse = new DeletePurchasesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveAppraisalRequest$Type extends MessageType<SaveAppraisalRequest> {
    constructor() {
        super("etco_proto.SaveAppraisalRequest", [
            { no: 1, name: "territory_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BasicItem },
            { no: 3, name: "refresh_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SaveAppraisalRequest>): SaveAppraisalRequest {
        const message = { territoryId: 0, items: [], refreshToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SaveAppraisalRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveAppraisalRequest): SaveAppraisalRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 territory_id */ 1:
                    message.territoryId = reader.int64().toNumber();
                    break;
                case /* repeated etco_proto.BasicItem items */ 2:
                    message.items.push(BasicItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string refresh_token */ 3:
                    message.refreshToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveAppraisalRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 territory_id = 1; */
        if (message.territoryId !== 0)
            writer.tag(1, WireType.Varint).int64(message.territoryId);
        /* repeated etco_proto.BasicItem items = 2; */
        for (let i = 0; i < message.items.length; i++)
            BasicItem.internalBinaryWrite(message.items[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string refresh_token = 3; */
        if (message.refreshToken !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.refreshToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.SaveAppraisalRequest
 */
export const SaveAppraisalRequest = new SaveAppraisalRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuybackAppraisalResponse$Type extends MessageType<BuybackAppraisalResponse> {
    constructor() {
        super("etco_proto.BuybackAppraisalResponse", [
            { no: 1, name: "appraisal", kind: "message", T: () => BuybackAppraisal },
            { no: 2, name: "strs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "authorized", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<BuybackAppraisalResponse>): BuybackAppraisalResponse {
        const message = { strs: [], authorized: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BuybackAppraisalResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuybackAppraisalResponse): BuybackAppraisalResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* etco_proto.BuybackAppraisal appraisal */ 1:
                    message.appraisal = BuybackAppraisal.internalBinaryRead(reader, reader.uint32(), options, message.appraisal);
                    break;
                case /* repeated string strs */ 2:
                    message.strs.push(reader.string());
                    break;
                case /* bool authorized */ 3:
                    message.authorized = reader.bool();
                    break;
                case /* etco_proto.ErrorResponse error */ 4:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BuybackAppraisalResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* etco_proto.BuybackAppraisal appraisal = 1; */
        if (message.appraisal)
            BuybackAppraisal.internalBinaryWrite(message.appraisal, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string strs = 2; */
        for (let i = 0; i < message.strs.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.strs[i]);
        /* bool authorized = 3; */
        if (message.authorized !== false)
            writer.tag(3, WireType.Varint).bool(message.authorized);
        /* etco_proto.ErrorResponse error = 4; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.BuybackAppraisalResponse
 */
export const BuybackAppraisalResponse = new BuybackAppraisalResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopAppraisalResponse$Type extends MessageType<ShopAppraisalResponse> {
    constructor() {
        super("etco_proto.ShopAppraisalResponse", [
            { no: 1, name: "status", kind: "enum", T: () => ["etco_proto.MakePurchaseStatus", MakePurchaseStatus] },
            { no: 2, name: "appraisal", kind: "message", T: () => ShopAppraisal },
            { no: 3, name: "strs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "authorized", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<ShopAppraisalResponse>): ShopAppraisalResponse {
        const message = { status: 0, strs: [], authorized: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopAppraisalResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopAppraisalResponse): ShopAppraisalResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* etco_proto.MakePurchaseStatus status */ 1:
                    message.status = reader.int32();
                    break;
                case /* etco_proto.ShopAppraisal appraisal */ 2:
                    message.appraisal = ShopAppraisal.internalBinaryRead(reader, reader.uint32(), options, message.appraisal);
                    break;
                case /* repeated string strs */ 3:
                    message.strs.push(reader.string());
                    break;
                case /* bool authorized */ 4:
                    message.authorized = reader.bool();
                    break;
                case /* etco_proto.ErrorResponse error */ 5:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopAppraisalResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* etco_proto.MakePurchaseStatus status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        /* etco_proto.ShopAppraisal appraisal = 2; */
        if (message.appraisal)
            ShopAppraisal.internalBinaryWrite(message.appraisal, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated string strs = 3; */
        for (let i = 0; i < message.strs.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.strs[i]);
        /* bool authorized = 4; */
        if (message.authorized !== false)
            writer.tag(4, WireType.Varint).bool(message.authorized);
        /* etco_proto.ErrorResponse error = 5; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.ShopAppraisalResponse
 */
export const ShopAppraisalResponse = new ShopAppraisalResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopInventoryRequest$Type extends MessageType<ShopInventoryRequest> {
    constructor() {
        super("etco_proto.ShopInventoryRequest", [
            { no: 1, name: "location_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "refresh_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ShopInventoryRequest>): ShopInventoryRequest {
        const message = { locationId: 0, refreshToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopInventoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopInventoryRequest): ShopInventoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 location_id */ 1:
                    message.locationId = reader.int64().toNumber();
                    break;
                case /* string refresh_token */ 2:
                    message.refreshToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopInventoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 location_id = 1; */
        if (message.locationId !== 0)
            writer.tag(1, WireType.Varint).int64(message.locationId);
        /* string refresh_token = 2; */
        if (message.refreshToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.refreshToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.ShopInventoryRequest
 */
export const ShopInventoryRequest = new ShopInventoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopInventoryResponse$Type extends MessageType<ShopInventoryResponse> {
    constructor() {
        super("etco_proto.ShopInventoryResponse", [
            { no: 1, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ShopItem },
            { no: 2, name: "location_info", kind: "message", T: () => LocationInfo },
            { no: 3, name: "strs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "authorized", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<ShopInventoryResponse>): ShopInventoryResponse {
        const message = { items: [], strs: [], authorized: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopInventoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopInventoryResponse): ShopInventoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated etco_proto.ShopItem items */ 1:
                    message.items.push(ShopItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* etco_proto.LocationInfo location_info */ 2:
                    message.locationInfo = LocationInfo.internalBinaryRead(reader, reader.uint32(), options, message.locationInfo);
                    break;
                case /* repeated string strs */ 3:
                    message.strs.push(reader.string());
                    break;
                case /* bool authorized */ 4:
                    message.authorized = reader.bool();
                    break;
                case /* etco_proto.ErrorResponse error */ 5:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopInventoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated etco_proto.ShopItem items = 1; */
        for (let i = 0; i < message.items.length; i++)
            ShopItem.internalBinaryWrite(message.items[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* etco_proto.LocationInfo location_info = 2; */
        if (message.locationInfo)
            LocationInfo.internalBinaryWrite(message.locationInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated string strs = 3; */
        for (let i = 0; i < message.strs.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.strs[i]);
        /* bool authorized = 4; */
        if (message.authorized !== false)
            writer.tag(4, WireType.Varint).bool(message.authorized);
        /* etco_proto.ErrorResponse error = 5; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.ShopInventoryResponse
 */
export const ShopInventoryResponse = new ShopInventoryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDataRequest$Type extends MessageType<UserDataRequest> {
    constructor() {
        super("etco_proto.UserDataRequest", [
            { no: 1, name: "character_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "refresh_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserDataRequest>): UserDataRequest {
        const message = { characterId: 0, refreshToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UserDataRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserDataRequest): UserDataRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 character_id */ 1:
                    message.characterId = reader.int32();
                    break;
                case /* string refresh_token */ 2:
                    message.refreshToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserDataRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 character_id = 1; */
        if (message.characterId !== 0)
            writer.tag(1, WireType.Varint).int32(message.characterId);
        /* string refresh_token = 2; */
        if (message.refreshToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.refreshToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.UserDataRequest
 */
export const UserDataRequest = new UserDataRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserTimePurchaseResponse$Type extends MessageType<UserTimePurchaseResponse> {
    constructor() {
        super("etco_proto.UserTimePurchaseResponse", [
            { no: 1, name: "time", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "authorized", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<UserTimePurchaseResponse>): UserTimePurchaseResponse {
        const message = { time: 0, authorized: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UserTimePurchaseResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserTimePurchaseResponse): UserTimePurchaseResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 time */ 1:
                    message.time = reader.int64().toNumber();
                    break;
                case /* bool authorized */ 2:
                    message.authorized = reader.bool();
                    break;
                case /* etco_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserTimePurchaseResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 time = 1; */
        if (message.time !== 0)
            writer.tag(1, WireType.Varint).int64(message.time);
        /* bool authorized = 2; */
        if (message.authorized !== false)
            writer.tag(2, WireType.Varint).bool(message.authorized);
        /* etco_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.UserTimePurchaseResponse
 */
export const UserTimePurchaseResponse = new UserTimePurchaseResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserAppraisalCodesResponse$Type extends MessageType<UserAppraisalCodesResponse> {
    constructor() {
        super("etco_proto.UserAppraisalCodesResponse", [
            { no: 1, name: "codes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "authorized", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<UserAppraisalCodesResponse>): UserAppraisalCodesResponse {
        const message = { codes: [], authorized: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UserAppraisalCodesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserAppraisalCodesResponse): UserAppraisalCodesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string codes */ 1:
                    message.codes.push(reader.string());
                    break;
                case /* bool authorized */ 2:
                    message.authorized = reader.bool();
                    break;
                case /* etco_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserAppraisalCodesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string codes = 1; */
        for (let i = 0; i < message.codes.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.codes[i]);
        /* bool authorized = 2; */
        if (message.authorized !== false)
            writer.tag(2, WireType.Varint).bool(message.authorized);
        /* etco_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.UserAppraisalCodesResponse
 */
export const UserAppraisalCodesResponse = new UserAppraisalCodesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CancelPurchaseRequest$Type extends MessageType<CancelPurchaseRequest> {
    constructor() {
        super("etco_proto.CancelPurchaseRequest", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "location_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "refresh_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CancelPurchaseRequest>): CancelPurchaseRequest {
        const message = { code: "", locationId: 0, refreshToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CancelPurchaseRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CancelPurchaseRequest): CancelPurchaseRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* int64 location_id */ 2:
                    message.locationId = reader.int64().toNumber();
                    break;
                case /* string refresh_token */ 3:
                    message.refreshToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CancelPurchaseRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* int64 location_id = 2; */
        if (message.locationId !== 0)
            writer.tag(2, WireType.Varint).int64(message.locationId);
        /* string refresh_token = 3; */
        if (message.refreshToken !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.refreshToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CancelPurchaseRequest
 */
export const CancelPurchaseRequest = new CancelPurchaseRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CancelPurchaseResponse$Type extends MessageType<CancelPurchaseResponse> {
    constructor() {
        super("etco_proto.CancelPurchaseResponse", [
            { no: 1, name: "status", kind: "enum", T: () => ["etco_proto.CancelPurchaseStatus", CancelPurchaseStatus] },
            { no: 2, name: "authorized", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<CancelPurchaseResponse>): CancelPurchaseResponse {
        const message = { status: 0, authorized: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CancelPurchaseResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CancelPurchaseResponse): CancelPurchaseResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* etco_proto.CancelPurchaseStatus status */ 1:
                    message.status = reader.int32();
                    break;
                case /* bool authorized */ 2:
                    message.authorized = reader.bool();
                    break;
                case /* etco_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CancelPurchaseResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* etco_proto.CancelPurchaseStatus status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        /* bool authorized = 2; */
        if (message.authorized !== false)
            writer.tag(2, WireType.Varint).bool(message.authorized);
        /* etco_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CancelPurchaseResponse
 */
export const CancelPurchaseResponse = new CancelPurchaseResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatusAppraisalRequest$Type extends MessageType<StatusAppraisalRequest> {
    constructor() {
        super("etco_proto.StatusAppraisalRequest", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "include_items", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "refresh_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StatusAppraisalRequest>): StatusAppraisalRequest {
        const message = { code: "", includeItems: false, refreshToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StatusAppraisalRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatusAppraisalRequest): StatusAppraisalRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* bool include_items */ 2:
                    message.includeItems = reader.bool();
                    break;
                case /* string refresh_token */ 3:
                    message.refreshToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatusAppraisalRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* bool include_items = 2; */
        if (message.includeItems !== false)
            writer.tag(2, WireType.Varint).bool(message.includeItems);
        /* string refresh_token = 3; */
        if (message.refreshToken !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.refreshToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.StatusAppraisalRequest
 */
export const StatusAppraisalRequest = new StatusAppraisalRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatusAppraisalResponse$Type extends MessageType<StatusAppraisalResponse> {
    constructor() {
        super("etco_proto.StatusAppraisalResponse", [
            { no: 1, name: "status", kind: "enum", T: () => ["etco_proto.AppraisalStatus", AppraisalStatus] },
            { no: 2, name: "contract", kind: "message", T: () => Contract },
            { no: 3, name: "contract_items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedBasicItem },
            { no: 4, name: "strs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "authorized", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<StatusAppraisalResponse>): StatusAppraisalResponse {
        const message = { status: 0, contractItems: [], strs: [], authorized: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StatusAppraisalResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatusAppraisalResponse): StatusAppraisalResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* etco_proto.AppraisalStatus status */ 1:
                    message.status = reader.int32();
                    break;
                case /* etco_proto.Contract contract */ 2:
                    message.contract = Contract.internalBinaryRead(reader, reader.uint32(), options, message.contract);
                    break;
                case /* repeated etco_proto.NamedBasicItem contract_items */ 3:
                    message.contractItems.push(NamedBasicItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string strs */ 4:
                    message.strs.push(reader.string());
                    break;
                case /* bool authorized */ 5:
                    message.authorized = reader.bool();
                    break;
                case /* etco_proto.ErrorResponse error */ 6:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatusAppraisalResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* etco_proto.AppraisalStatus status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        /* etco_proto.Contract contract = 2; */
        if (message.contract)
            Contract.internalBinaryWrite(message.contract, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated etco_proto.NamedBasicItem contract_items = 3; */
        for (let i = 0; i < message.contractItems.length; i++)
            NamedBasicItem.internalBinaryWrite(message.contractItems[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated string strs = 4; */
        for (let i = 0; i < message.strs.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.strs[i]);
        /* bool authorized = 5; */
        if (message.authorized !== false)
            writer.tag(5, WireType.Varint).bool(message.authorized);
        /* etco_proto.ErrorResponse error = 6; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.StatusAppraisalResponse
 */
export const StatusAppraisalResponse = new StatusAppraisalResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAppraisalRequest$Type extends MessageType<GetAppraisalRequest> {
    constructor() {
        super("etco_proto.GetAppraisalRequest", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "include_items", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "refresh_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetAppraisalRequest>): GetAppraisalRequest {
        const message = { code: "", includeItems: false, refreshToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetAppraisalRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAppraisalRequest): GetAppraisalRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* bool include_items */ 2:
                    message.includeItems = reader.bool();
                    break;
                case /* string refresh_token */ 3:
                    message.refreshToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAppraisalRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* bool include_items = 2; */
        if (message.includeItems !== false)
            writer.tag(2, WireType.Varint).bool(message.includeItems);
        /* string refresh_token = 3; */
        if (message.refreshToken !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.refreshToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.GetAppraisalRequest
 */
export const GetAppraisalRequest = new GetAppraisalRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBuybackAppraisalResponse$Type extends MessageType<GetBuybackAppraisalResponse> {
    constructor() {
        super("etco_proto.GetBuybackAppraisalResponse", [
            { no: 1, name: "appraisal", kind: "message", T: () => BuybackAppraisal },
            { no: 2, name: "anonymous", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "strs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<GetBuybackAppraisalResponse>): GetBuybackAppraisalResponse {
        const message = { anonymous: false, strs: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetBuybackAppraisalResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBuybackAppraisalResponse): GetBuybackAppraisalResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* etco_proto.BuybackAppraisal appraisal */ 1:
                    message.appraisal = BuybackAppraisal.internalBinaryRead(reader, reader.uint32(), options, message.appraisal);
                    break;
                case /* bool anonymous */ 2:
                    message.anonymous = reader.bool();
                    break;
                case /* repeated string strs */ 3:
                    message.strs.push(reader.string());
                    break;
                case /* etco_proto.ErrorResponse error */ 4:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBuybackAppraisalResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* etco_proto.BuybackAppraisal appraisal = 1; */
        if (message.appraisal)
            BuybackAppraisal.internalBinaryWrite(message.appraisal, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool anonymous = 2; */
        if (message.anonymous !== false)
            writer.tag(2, WireType.Varint).bool(message.anonymous);
        /* repeated string strs = 3; */
        for (let i = 0; i < message.strs.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.strs[i]);
        /* etco_proto.ErrorResponse error = 4; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.GetBuybackAppraisalResponse
 */
export const GetBuybackAppraisalResponse = new GetBuybackAppraisalResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetShopAppraisalResponse$Type extends MessageType<GetShopAppraisalResponse> {
    constructor() {
        super("etco_proto.GetShopAppraisalResponse", [
            { no: 1, name: "appraisal", kind: "message", T: () => ShopAppraisal },
            { no: 2, name: "anonymous", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "strs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<GetShopAppraisalResponse>): GetShopAppraisalResponse {
        const message = { anonymous: false, strs: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetShopAppraisalResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetShopAppraisalResponse): GetShopAppraisalResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* etco_proto.ShopAppraisal appraisal */ 1:
                    message.appraisal = ShopAppraisal.internalBinaryRead(reader, reader.uint32(), options, message.appraisal);
                    break;
                case /* bool anonymous */ 2:
                    message.anonymous = reader.bool();
                    break;
                case /* repeated string strs */ 3:
                    message.strs.push(reader.string());
                    break;
                case /* etco_proto.ErrorResponse error */ 4:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetShopAppraisalResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* etco_proto.ShopAppraisal appraisal = 1; */
        if (message.appraisal)
            ShopAppraisal.internalBinaryWrite(message.appraisal, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool anonymous = 2; */
        if (message.anonymous !== false)
            writer.tag(2, WireType.Varint).bool(message.anonymous);
        /* repeated string strs = 3; */
        for (let i = 0; i < message.strs.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.strs[i]);
        /* etco_proto.ErrorResponse error = 4; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.GetShopAppraisalResponse
 */
export const GetShopAppraisalResponse = new GetShopAppraisalResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgUpdateResponse$Type extends MessageType<CfgUpdateResponse> {
    constructor() {
        super("etco_proto.CfgUpdateResponse", [
            { no: 1, name: "modified", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "authorized", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<CfgUpdateResponse>): CfgUpdateResponse {
        const message = { modified: false, authorized: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgUpdateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgUpdateResponse): CfgUpdateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool modified */ 1:
                    message.modified = reader.bool();
                    break;
                case /* bool authorized */ 2:
                    message.authorized = reader.bool();
                    break;
                case /* etco_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgUpdateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool modified = 1; */
        if (message.modified !== false)
            writer.tag(1, WireType.Varint).bool(message.modified);
        /* bool authorized = 2; */
        if (message.authorized !== false)
            writer.tag(2, WireType.Varint).bool(message.authorized);
        /* etco_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CfgUpdateResponse
 */
export const CfgUpdateResponse = new CfgUpdateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgGetAuthListResponse$Type extends MessageType<CfgGetAuthListResponse> {
    constructor() {
        super("etco_proto.CfgGetAuthListResponse", [
            { no: 1, name: "auth_list", kind: "message", T: () => CfgAuthList },
            { no: 2, name: "authorized", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<CfgGetAuthListResponse>): CfgGetAuthListResponse {
        const message = { authorized: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgGetAuthListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgGetAuthListResponse): CfgGetAuthListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* etco_proto.CfgAuthList auth_list */ 1:
                    message.authList = CfgAuthList.internalBinaryRead(reader, reader.uint32(), options, message.authList);
                    break;
                case /* bool authorized */ 2:
                    message.authorized = reader.bool();
                    break;
                case /* etco_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgGetAuthListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* etco_proto.CfgAuthList auth_list = 1; */
        if (message.authList)
            CfgAuthList.internalBinaryWrite(message.authList, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool authorized = 2; */
        if (message.authorized !== false)
            writer.tag(2, WireType.Varint).bool(message.authorized);
        /* etco_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CfgGetAuthListResponse
 */
export const CfgGetAuthListResponse = new CfgGetAuthListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgSetAuthListRequest$Type extends MessageType<CfgSetAuthListRequest> {
    constructor() {
        super("etco_proto.CfgSetAuthListRequest", [
            { no: 1, name: "auth_list", kind: "message", T: () => CfgAuthList },
            { no: 2, name: "refresh_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CfgSetAuthListRequest>): CfgSetAuthListRequest {
        const message = { refreshToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgSetAuthListRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgSetAuthListRequest): CfgSetAuthListRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* etco_proto.CfgAuthList auth_list */ 1:
                    message.authList = CfgAuthList.internalBinaryRead(reader, reader.uint32(), options, message.authList);
                    break;
                case /* string refresh_token */ 2:
                    message.refreshToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgSetAuthListRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* etco_proto.CfgAuthList auth_list = 1; */
        if (message.authList)
            CfgAuthList.internalBinaryWrite(message.authList, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string refresh_token = 2; */
        if (message.refreshToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.refreshToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CfgSetAuthListRequest
 */
export const CfgSetAuthListRequest = new CfgSetAuthListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgGetConstDataResponse$Type extends MessageType<CfgGetConstDataResponse> {
    constructor() {
        super("etco_proto.CfgGetConstDataResponse", [
            { no: 1, name: "const_data", kind: "message", T: () => CfgConstData },
            { no: 2, name: "authorized", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<CfgGetConstDataResponse>): CfgGetConstDataResponse {
        const message = { authorized: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgGetConstDataResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgGetConstDataResponse): CfgGetConstDataResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* etco_proto.CfgConstData const_data */ 1:
                    message.constData = CfgConstData.internalBinaryRead(reader, reader.uint32(), options, message.constData);
                    break;
                case /* bool authorized */ 2:
                    message.authorized = reader.bool();
                    break;
                case /* etco_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgGetConstDataResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* etco_proto.CfgConstData const_data = 1; */
        if (message.constData)
            CfgConstData.internalBinaryWrite(message.constData, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool authorized = 2; */
        if (message.authorized !== false)
            writer.tag(2, WireType.Varint).bool(message.authorized);
        /* etco_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CfgGetConstDataResponse
 */
export const CfgGetConstDataResponse = new CfgGetConstDataResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgSetConstDataRequest$Type extends MessageType<CfgSetConstDataRequest> {
    constructor() {
        super("etco_proto.CfgSetConstDataRequest", [
            { no: 1, name: "const_data", kind: "message", T: () => CfgConstData },
            { no: 2, name: "refresh_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CfgSetConstDataRequest>): CfgSetConstDataRequest {
        const message = { refreshToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgSetConstDataRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgSetConstDataRequest): CfgSetConstDataRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* etco_proto.CfgConstData const_data */ 1:
                    message.constData = CfgConstData.internalBinaryRead(reader, reader.uint32(), options, message.constData);
                    break;
                case /* string refresh_token */ 2:
                    message.refreshToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgSetConstDataRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* etco_proto.CfgConstData const_data = 1; */
        if (message.constData)
            CfgConstData.internalBinaryWrite(message.constData, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string refresh_token = 2; */
        if (message.refreshToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.refreshToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CfgSetConstDataRequest
 */
export const CfgSetConstDataRequest = new CfgSetConstDataRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgGetBuybackSystemTypeMapsBuilderResponse$Type extends MessageType<CfgGetBuybackSystemTypeMapsBuilderResponse> {
    constructor() {
        super("etco_proto.CfgGetBuybackSystemTypeMapsBuilderResponse", [
            { no: 1, name: "builder", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "message", T: () => CfgBuybackSystemTypeBundle } },
            { no: 2, name: "authorized", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<CfgGetBuybackSystemTypeMapsBuilderResponse>): CfgGetBuybackSystemTypeMapsBuilderResponse {
        const message = { builder: {}, authorized: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgGetBuybackSystemTypeMapsBuilderResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgGetBuybackSystemTypeMapsBuilderResponse): CfgGetBuybackSystemTypeMapsBuilderResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, etco_proto.CfgBuybackSystemTypeBundle> builder */ 1:
                    this.binaryReadMap1(message.builder, reader, options);
                    break;
                case /* bool authorized */ 2:
                    message.authorized = reader.bool();
                    break;
                case /* etco_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CfgGetBuybackSystemTypeMapsBuilderResponse["builder"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CfgGetBuybackSystemTypeMapsBuilderResponse["builder"] | undefined, val: CfgGetBuybackSystemTypeMapsBuilderResponse["builder"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = CfgBuybackSystemTypeBundle.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field etco_proto.CfgGetBuybackSystemTypeMapsBuilderResponse.builder");
            }
        }
        map[key ?? 0] = val ?? CfgBuybackSystemTypeBundle.create();
    }
    internalBinaryWrite(message: CfgGetBuybackSystemTypeMapsBuilderResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, etco_proto.CfgBuybackSystemTypeBundle> builder = 1; */
        for (let k of Object.keys(message.builder)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            CfgBuybackSystemTypeBundle.internalBinaryWrite(message.builder[k as any], writer, options);
            writer.join().join();
        }
        /* bool authorized = 2; */
        if (message.authorized !== false)
            writer.tag(2, WireType.Varint).bool(message.authorized);
        /* etco_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CfgGetBuybackSystemTypeMapsBuilderResponse
 */
export const CfgGetBuybackSystemTypeMapsBuilderResponse = new CfgGetBuybackSystemTypeMapsBuilderResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgMergeBuybackSystemTypeMapsBuilderRequest$Type extends MessageType<CfgMergeBuybackSystemTypeMapsBuilderRequest> {
    constructor() {
        super("etco_proto.CfgMergeBuybackSystemTypeMapsBuilderRequest", [
            { no: 1, name: "builder", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "message", T: () => CfgBuybackSystemTypeBundle } },
            { no: 2, name: "refresh_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CfgMergeBuybackSystemTypeMapsBuilderRequest>): CfgMergeBuybackSystemTypeMapsBuilderRequest {
        const message = { builder: {}, refreshToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgMergeBuybackSystemTypeMapsBuilderRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgMergeBuybackSystemTypeMapsBuilderRequest): CfgMergeBuybackSystemTypeMapsBuilderRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, etco_proto.CfgBuybackSystemTypeBundle> builder */ 1:
                    this.binaryReadMap1(message.builder, reader, options);
                    break;
                case /* string refresh_token */ 2:
                    message.refreshToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CfgMergeBuybackSystemTypeMapsBuilderRequest["builder"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CfgMergeBuybackSystemTypeMapsBuilderRequest["builder"] | undefined, val: CfgMergeBuybackSystemTypeMapsBuilderRequest["builder"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = CfgBuybackSystemTypeBundle.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field etco_proto.CfgMergeBuybackSystemTypeMapsBuilderRequest.builder");
            }
        }
        map[key ?? 0] = val ?? CfgBuybackSystemTypeBundle.create();
    }
    internalBinaryWrite(message: CfgMergeBuybackSystemTypeMapsBuilderRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, etco_proto.CfgBuybackSystemTypeBundle> builder = 1; */
        for (let k of Object.keys(message.builder)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            CfgBuybackSystemTypeBundle.internalBinaryWrite(message.builder[k as any], writer, options);
            writer.join().join();
        }
        /* string refresh_token = 2; */
        if (message.refreshToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.refreshToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CfgMergeBuybackSystemTypeMapsBuilderRequest
 */
export const CfgMergeBuybackSystemTypeMapsBuilderRequest = new CfgMergeBuybackSystemTypeMapsBuilderRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgGetShopLocationTypeMapsBuilderResponse$Type extends MessageType<CfgGetShopLocationTypeMapsBuilderResponse> {
    constructor() {
        super("etco_proto.CfgGetShopLocationTypeMapsBuilderResponse", [
            { no: 1, name: "builder", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "message", T: () => CfgShopLocationTypeBundle } },
            { no: 2, name: "authorized", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<CfgGetShopLocationTypeMapsBuilderResponse>): CfgGetShopLocationTypeMapsBuilderResponse {
        const message = { builder: {}, authorized: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgGetShopLocationTypeMapsBuilderResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgGetShopLocationTypeMapsBuilderResponse): CfgGetShopLocationTypeMapsBuilderResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, etco_proto.CfgShopLocationTypeBundle> builder */ 1:
                    this.binaryReadMap1(message.builder, reader, options);
                    break;
                case /* bool authorized */ 2:
                    message.authorized = reader.bool();
                    break;
                case /* etco_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CfgGetShopLocationTypeMapsBuilderResponse["builder"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CfgGetShopLocationTypeMapsBuilderResponse["builder"] | undefined, val: CfgGetShopLocationTypeMapsBuilderResponse["builder"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = CfgShopLocationTypeBundle.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field etco_proto.CfgGetShopLocationTypeMapsBuilderResponse.builder");
            }
        }
        map[key ?? 0] = val ?? CfgShopLocationTypeBundle.create();
    }
    internalBinaryWrite(message: CfgGetShopLocationTypeMapsBuilderResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, etco_proto.CfgShopLocationTypeBundle> builder = 1; */
        for (let k of Object.keys(message.builder)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            CfgShopLocationTypeBundle.internalBinaryWrite(message.builder[k as any], writer, options);
            writer.join().join();
        }
        /* bool authorized = 2; */
        if (message.authorized !== false)
            writer.tag(2, WireType.Varint).bool(message.authorized);
        /* etco_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CfgGetShopLocationTypeMapsBuilderResponse
 */
export const CfgGetShopLocationTypeMapsBuilderResponse = new CfgGetShopLocationTypeMapsBuilderResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgMergeShopLocationTypeMapsBuilderRequest$Type extends MessageType<CfgMergeShopLocationTypeMapsBuilderRequest> {
    constructor() {
        super("etco_proto.CfgMergeShopLocationTypeMapsBuilderRequest", [
            { no: 1, name: "builder", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "message", T: () => CfgShopLocationTypeBundle } },
            { no: 2, name: "refresh_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CfgMergeShopLocationTypeMapsBuilderRequest>): CfgMergeShopLocationTypeMapsBuilderRequest {
        const message = { builder: {}, refreshToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgMergeShopLocationTypeMapsBuilderRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgMergeShopLocationTypeMapsBuilderRequest): CfgMergeShopLocationTypeMapsBuilderRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, etco_proto.CfgShopLocationTypeBundle> builder */ 1:
                    this.binaryReadMap1(message.builder, reader, options);
                    break;
                case /* string refresh_token */ 2:
                    message.refreshToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CfgMergeShopLocationTypeMapsBuilderRequest["builder"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CfgMergeShopLocationTypeMapsBuilderRequest["builder"] | undefined, val: CfgMergeShopLocationTypeMapsBuilderRequest["builder"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = CfgShopLocationTypeBundle.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field etco_proto.CfgMergeShopLocationTypeMapsBuilderRequest.builder");
            }
        }
        map[key ?? 0] = val ?? CfgShopLocationTypeBundle.create();
    }
    internalBinaryWrite(message: CfgMergeShopLocationTypeMapsBuilderRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, etco_proto.CfgShopLocationTypeBundle> builder = 1; */
        for (let k of Object.keys(message.builder)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            CfgShopLocationTypeBundle.internalBinaryWrite(message.builder[k as any], writer, options);
            writer.join().join();
        }
        /* string refresh_token = 2; */
        if (message.refreshToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.refreshToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CfgMergeShopLocationTypeMapsBuilderRequest
 */
export const CfgMergeShopLocationTypeMapsBuilderRequest = new CfgMergeShopLocationTypeMapsBuilderRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgGetBuybackSystemsResponse$Type extends MessageType<CfgGetBuybackSystemsResponse> {
    constructor() {
        super("etco_proto.CfgGetBuybackSystemsResponse", [
            { no: 1, name: "systems", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "message", T: () => CfgBuybackSystem } },
            { no: 4, name: "authorized", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<CfgGetBuybackSystemsResponse>): CfgGetBuybackSystemsResponse {
        const message = { systems: {}, authorized: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgGetBuybackSystemsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgGetBuybackSystemsResponse): CfgGetBuybackSystemsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, etco_proto.CfgBuybackSystem> systems */ 1:
                    this.binaryReadMap1(message.systems, reader, options);
                    break;
                case /* bool authorized */ 4:
                    message.authorized = reader.bool();
                    break;
                case /* etco_proto.ErrorResponse error */ 5:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CfgGetBuybackSystemsResponse["systems"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CfgGetBuybackSystemsResponse["systems"] | undefined, val: CfgGetBuybackSystemsResponse["systems"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = CfgBuybackSystem.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field etco_proto.CfgGetBuybackSystemsResponse.systems");
            }
        }
        map[key ?? 0] = val ?? CfgBuybackSystem.create();
    }
    internalBinaryWrite(message: CfgGetBuybackSystemsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, etco_proto.CfgBuybackSystem> systems = 1; */
        for (let k of Object.keys(message.systems)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            CfgBuybackSystem.internalBinaryWrite(message.systems[k as any], writer, options);
            writer.join().join();
        }
        /* bool authorized = 4; */
        if (message.authorized !== false)
            writer.tag(4, WireType.Varint).bool(message.authorized);
        /* etco_proto.ErrorResponse error = 5; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CfgGetBuybackSystemsResponse
 */
export const CfgGetBuybackSystemsResponse = new CfgGetBuybackSystemsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgMergeBuybackSystemsRequest$Type extends MessageType<CfgMergeBuybackSystemsRequest> {
    constructor() {
        super("etco_proto.CfgMergeBuybackSystemsRequest", [
            { no: 1, name: "systems", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "message", T: () => CfgBuybackSystem } },
            { no: 2, name: "refresh_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CfgMergeBuybackSystemsRequest>): CfgMergeBuybackSystemsRequest {
        const message = { systems: {}, refreshToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgMergeBuybackSystemsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgMergeBuybackSystemsRequest): CfgMergeBuybackSystemsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, etco_proto.CfgBuybackSystem> systems */ 1:
                    this.binaryReadMap1(message.systems, reader, options);
                    break;
                case /* string refresh_token */ 2:
                    message.refreshToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CfgMergeBuybackSystemsRequest["systems"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CfgMergeBuybackSystemsRequest["systems"] | undefined, val: CfgMergeBuybackSystemsRequest["systems"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = CfgBuybackSystem.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field etco_proto.CfgMergeBuybackSystemsRequest.systems");
            }
        }
        map[key ?? 0] = val ?? CfgBuybackSystem.create();
    }
    internalBinaryWrite(message: CfgMergeBuybackSystemsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, etco_proto.CfgBuybackSystem> systems = 1; */
        for (let k of Object.keys(message.systems)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            CfgBuybackSystem.internalBinaryWrite(message.systems[k as any], writer, options);
            writer.join().join();
        }
        /* string refresh_token = 2; */
        if (message.refreshToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.refreshToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CfgMergeBuybackSystemsRequest
 */
export const CfgMergeBuybackSystemsRequest = new CfgMergeBuybackSystemsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgGetShopLocationsResponse$Type extends MessageType<CfgGetShopLocationsResponse> {
    constructor() {
        super("etco_proto.CfgGetShopLocationsResponse", [
            { no: 1, name: "locations", kind: "map", K: 3 /*ScalarType.INT64*/, V: { kind: "message", T: () => CfgShopLocation } },
            { no: 4, name: "authorized", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<CfgGetShopLocationsResponse>): CfgGetShopLocationsResponse {
        const message = { locations: {}, authorized: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgGetShopLocationsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgGetShopLocationsResponse): CfgGetShopLocationsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int64, etco_proto.CfgShopLocation> locations */ 1:
                    this.binaryReadMap1(message.locations, reader, options);
                    break;
                case /* bool authorized */ 4:
                    message.authorized = reader.bool();
                    break;
                case /* etco_proto.ErrorResponse error */ 5:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CfgGetShopLocationsResponse["locations"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CfgGetShopLocationsResponse["locations"] | undefined, val: CfgGetShopLocationsResponse["locations"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int64().toString();
                    break;
                case 2:
                    val = CfgShopLocation.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field etco_proto.CfgGetShopLocationsResponse.locations");
            }
        }
        map[key ?? "0"] = val ?? CfgShopLocation.create();
    }
    internalBinaryWrite(message: CfgGetShopLocationsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int64, etco_proto.CfgShopLocation> locations = 1; */
        for (let k of Object.keys(message.locations)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int64(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            CfgShopLocation.internalBinaryWrite(message.locations[k], writer, options);
            writer.join().join();
        }
        /* bool authorized = 4; */
        if (message.authorized !== false)
            writer.tag(4, WireType.Varint).bool(message.authorized);
        /* etco_proto.ErrorResponse error = 5; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CfgGetShopLocationsResponse
 */
export const CfgGetShopLocationsResponse = new CfgGetShopLocationsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgMergeShopLocationsRequest$Type extends MessageType<CfgMergeShopLocationsRequest> {
    constructor() {
        super("etco_proto.CfgMergeShopLocationsRequest", [
            { no: 1, name: "locations", kind: "map", K: 3 /*ScalarType.INT64*/, V: { kind: "message", T: () => CfgShopLocation } },
            { no: 2, name: "refresh_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CfgMergeShopLocationsRequest>): CfgMergeShopLocationsRequest {
        const message = { locations: {}, refreshToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgMergeShopLocationsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgMergeShopLocationsRequest): CfgMergeShopLocationsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int64, etco_proto.CfgShopLocation> locations */ 1:
                    this.binaryReadMap1(message.locations, reader, options);
                    break;
                case /* string refresh_token */ 2:
                    message.refreshToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CfgMergeShopLocationsRequest["locations"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CfgMergeShopLocationsRequest["locations"] | undefined, val: CfgMergeShopLocationsRequest["locations"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int64().toString();
                    break;
                case 2:
                    val = CfgShopLocation.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field etco_proto.CfgMergeShopLocationsRequest.locations");
            }
        }
        map[key ?? "0"] = val ?? CfgShopLocation.create();
    }
    internalBinaryWrite(message: CfgMergeShopLocationsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int64, etco_proto.CfgShopLocation> locations = 1; */
        for (let k of Object.keys(message.locations)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int64(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            CfgShopLocation.internalBinaryWrite(message.locations[k], writer, options);
            writer.join().join();
        }
        /* string refresh_token = 2; */
        if (message.refreshToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.refreshToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CfgMergeShopLocationsRequest
 */
export const CfgMergeShopLocationsRequest = new CfgMergeShopLocationsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgGetMarketsResponse$Type extends MessageType<CfgGetMarketsResponse> {
    constructor() {
        super("etco_proto.CfgGetMarketsResponse", [
            { no: 1, name: "markets", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => CfgMarket } },
            { no: 4, name: "authorized", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<CfgGetMarketsResponse>): CfgGetMarketsResponse {
        const message = { markets: {}, authorized: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgGetMarketsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgGetMarketsResponse): CfgGetMarketsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, etco_proto.CfgMarket> markets */ 1:
                    this.binaryReadMap1(message.markets, reader, options);
                    break;
                case /* bool authorized */ 4:
                    message.authorized = reader.bool();
                    break;
                case /* etco_proto.ErrorResponse error */ 5:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CfgGetMarketsResponse["markets"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CfgGetMarketsResponse["markets"] | undefined, val: CfgGetMarketsResponse["markets"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = CfgMarket.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field etco_proto.CfgGetMarketsResponse.markets");
            }
        }
        map[key ?? ""] = val ?? CfgMarket.create();
    }
    internalBinaryWrite(message: CfgGetMarketsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, etco_proto.CfgMarket> markets = 1; */
        for (let k of Object.keys(message.markets)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            CfgMarket.internalBinaryWrite(message.markets[k], writer, options);
            writer.join().join();
        }
        /* bool authorized = 4; */
        if (message.authorized !== false)
            writer.tag(4, WireType.Varint).bool(message.authorized);
        /* etco_proto.ErrorResponse error = 5; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CfgGetMarketsResponse
 */
export const CfgGetMarketsResponse = new CfgGetMarketsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgMergeMarketsRequest$Type extends MessageType<CfgMergeMarketsRequest> {
    constructor() {
        super("etco_proto.CfgMergeMarketsRequest", [
            { no: 1, name: "markets", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => CfgMarket } },
            { no: 2, name: "refresh_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CfgMergeMarketsRequest>): CfgMergeMarketsRequest {
        const message = { markets: {}, refreshToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgMergeMarketsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgMergeMarketsRequest): CfgMergeMarketsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, etco_proto.CfgMarket> markets */ 1:
                    this.binaryReadMap1(message.markets, reader, options);
                    break;
                case /* string refresh_token */ 2:
                    message.refreshToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CfgMergeMarketsRequest["markets"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CfgMergeMarketsRequest["markets"] | undefined, val: CfgMergeMarketsRequest["markets"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = CfgMarket.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field etco_proto.CfgMergeMarketsRequest.markets");
            }
        }
        map[key ?? ""] = val ?? CfgMarket.create();
    }
    internalBinaryWrite(message: CfgMergeMarketsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, etco_proto.CfgMarket> markets = 1; */
        for (let k of Object.keys(message.markets)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            CfgMarket.internalBinaryWrite(message.markets[k], writer, options);
            writer.join().join();
        }
        /* string refresh_token = 2; */
        if (message.refreshToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.refreshToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CfgMergeMarketsRequest
 */
export const CfgMergeMarketsRequest = new CfgMergeMarketsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgGetBuybackBundleKeysResponse$Type extends MessageType<CfgGetBuybackBundleKeysResponse> {
    constructor() {
        super("etco_proto.CfgGetBuybackBundleKeysResponse", [
            { no: 1, name: "bundle_keys", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "authorized", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<CfgGetBuybackBundleKeysResponse>): CfgGetBuybackBundleKeysResponse {
        const message = { bundleKeys: [], authorized: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgGetBuybackBundleKeysResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgGetBuybackBundleKeysResponse): CfgGetBuybackBundleKeysResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string bundle_keys */ 1:
                    message.bundleKeys.push(reader.string());
                    break;
                case /* bool authorized */ 2:
                    message.authorized = reader.bool();
                    break;
                case /* etco_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgGetBuybackBundleKeysResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string bundle_keys = 1; */
        for (let i = 0; i < message.bundleKeys.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.bundleKeys[i]);
        /* bool authorized = 2; */
        if (message.authorized !== false)
            writer.tag(2, WireType.Varint).bool(message.authorized);
        /* etco_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CfgGetBuybackBundleKeysResponse
 */
export const CfgGetBuybackBundleKeysResponse = new CfgGetBuybackBundleKeysResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgGetShopBundleKeysResponse$Type extends MessageType<CfgGetShopBundleKeysResponse> {
    constructor() {
        super("etco_proto.CfgGetShopBundleKeysResponse", [
            { no: 1, name: "bundle_keys", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "authorized", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<CfgGetShopBundleKeysResponse>): CfgGetShopBundleKeysResponse {
        const message = { bundleKeys: [], authorized: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgGetShopBundleKeysResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgGetShopBundleKeysResponse): CfgGetShopBundleKeysResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string bundle_keys */ 1:
                    message.bundleKeys.push(reader.string());
                    break;
                case /* bool authorized */ 2:
                    message.authorized = reader.bool();
                    break;
                case /* etco_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgGetShopBundleKeysResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string bundle_keys = 1; */
        for (let i = 0; i < message.bundleKeys.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.bundleKeys[i]);
        /* bool authorized = 2; */
        if (message.authorized !== false)
            writer.tag(2, WireType.Varint).bool(message.authorized);
        /* etco_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CfgGetShopBundleKeysResponse
 */
export const CfgGetShopBundleKeysResponse = new CfgGetShopBundleKeysResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CfgGetMarketNamesResponse$Type extends MessageType<CfgGetMarketNamesResponse> {
    constructor() {
        super("etco_proto.CfgGetMarketNamesResponse", [
            { no: 1, name: "market_names", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "authorized", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "error", kind: "message", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<CfgGetMarketNamesResponse>): CfgGetMarketNamesResponse {
        const message = { marketNames: [], authorized: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CfgGetMarketNamesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CfgGetMarketNamesResponse): CfgGetMarketNamesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string market_names */ 1:
                    message.marketNames.push(reader.string());
                    break;
                case /* bool authorized */ 2:
                    message.authorized = reader.bool();
                    break;
                case /* etco_proto.ErrorResponse error */ 3:
                    message.error = ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CfgGetMarketNamesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string market_names = 1; */
        for (let i = 0; i < message.marketNames.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.marketNames[i]);
        /* bool authorized = 2; */
        if (message.authorized !== false)
            writer.tag(2, WireType.Varint).bool(message.authorized);
        /* etco_proto.ErrorResponse error = 3; */
        if (message.error)
            ErrorResponse.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message etco_proto.CfgGetMarketNamesResponse
 */
export const CfgGetMarketNamesResponse = new CfgGetMarketNamesResponse$Type();
/**
 * @generated ServiceType for protobuf service etco_proto.EveTradingCo
 */
export const EveTradingCo = new ServiceType("etco_proto.EveTradingCo", [
    { name: "AllTypes", options: {}, I: EmptyRequest, O: TypesResponse },
    { name: "AllNamedTypes", options: {}, I: EmptyRequest, O: NamedTypesResponse },
    { name: "NamedTypes", options: {}, I: NamedTypesRequest, O: NamedTypesResponse },
    { name: "AllBuybackSystems", options: {}, I: EmptyRequest, O: SystemsResponse },
    { name: "AllSystems", options: {}, I: EmptyRequest, O: SystemsResponse },
    { name: "Systems", options: {}, I: SystemsRequest, O: SystemsResponse },
    { name: "AllShopLocations", options: {}, I: EmptyRequest, O: AllShopLocationsResponse },
    { name: "Locations", options: {}, I: LocationsRequest, O: LocationsResponse },
    { name: "Login", options: {}, I: LoginRequest, O: LoginResponse },
    { name: "Parse", options: {}, I: ParseRequest, O: ParseResponse },
    { name: "CharacterInfo", options: {}, I: EntityInfoRequest, O: CharacterInfoResponse },
    { name: "CorporationInfo", options: {}, I: EntityInfoRequest, O: CorporationInfoResponse },
    { name: "AllianceInfo", options: {}, I: EntityInfoRequest, O: AllianceInfoResponse },
    { name: "NewBuybackAppraisal", options: {}, I: NewAppraisalRequest, O: BuybackAppraisalResponse },
    { name: "NewShopAppraisal", options: {}, I: NewAppraisalRequest, O: ShopAppraisalResponse },
    { name: "TokenInfo", options: {}, I: TokenInfoRequest, O: TokenInfoResponse },
    { name: "BuybackContractQueue", options: {}, I: BasicRequest, O: BuybackContractQueueResponse },
    { name: "ShopContractQueue", options: {}, I: BasicRequest, O: ShopContractQueueResponse },
    { name: "PurchaseQueue", options: {}, I: BasicRequest, O: PurchaseQueueResponse },
    { name: "LocationPurchaseQueue", options: {}, I: LocationPurchaseQueueRequest, O: LocationPurchaseQueueResponse },
    { name: "DeletePurchases", options: {}, I: DeletePurchasesRequest, O: DeletePurchasesResponse },
    { name: "CancelPurchase", options: {}, I: CancelPurchaseRequest, O: CancelPurchaseResponse },
    { name: "UserBuybackAppraisalCodes", options: {}, I: UserDataRequest, O: UserAppraisalCodesResponse },
    { name: "UserShopAppraisalCodes", options: {}, I: UserDataRequest, O: UserAppraisalCodesResponse },
    { name: "UserMadePurchase", options: {}, I: UserDataRequest, O: UserTimePurchaseResponse },
    { name: "UserCancelledPurchase", options: {}, I: UserDataRequest, O: UserTimePurchaseResponse },
    { name: "ShopInventory", options: {}, I: ShopInventoryRequest, O: ShopInventoryResponse },
    { name: "SaveBuybackAppraisal", options: {}, I: SaveAppraisalRequest, O: BuybackAppraisalResponse },
    { name: "SaveShopAppraisal", options: {}, I: SaveAppraisalRequest, O: ShopAppraisalResponse },
    { name: "StatusBuybackAppraisal", options: {}, I: StatusAppraisalRequest, O: StatusAppraisalResponse },
    { name: "StatusShopAppraisal", options: {}, I: StatusAppraisalRequest, O: StatusAppraisalResponse },
    { name: "GetBuybackAppraisal", options: {}, I: GetAppraisalRequest, O: GetBuybackAppraisalResponse },
    { name: "GetShopAppraisal", options: {}, I: GetAppraisalRequest, O: GetShopAppraisalResponse },
    { name: "CfgGetUserAuthList", options: {}, I: BasicRequest, O: CfgGetAuthListResponse },
    { name: "CfgGetAdminAuthList", options: {}, I: BasicRequest, O: CfgGetAuthListResponse },
    { name: "CfgGetBuybackSystemTypeMapsBuilder", options: {}, I: BasicRequest, O: CfgGetBuybackSystemTypeMapsBuilderResponse },
    { name: "CfgGetShopLocationTypeMapsBuilder", options: {}, I: BasicRequest, O: CfgGetShopLocationTypeMapsBuilderResponse },
    { name: "CfgGetBuybackSystems", options: {}, I: BasicRequest, O: CfgGetBuybackSystemsResponse },
    { name: "CfgGetShopLocations", options: {}, I: BasicRequest, O: CfgGetShopLocationsResponse },
    { name: "CfgGetMarkets", options: {}, I: BasicRequest, O: CfgGetMarketsResponse },
    { name: "CfgGetMarketNames", options: {}, I: BasicRequest, O: CfgGetMarketNamesResponse },
    { name: "CfgGetBuybackBundleKeys", options: {}, I: BasicRequest, O: CfgGetBuybackBundleKeysResponse },
    { name: "CfgGetShopBundleKeys", options: {}, I: BasicRequest, O: CfgGetShopBundleKeysResponse },
    { name: "CfgGetConstData", options: {}, I: BasicRequest, O: CfgGetConstDataResponse },
    { name: "CfgSetUserAuthList", options: {}, I: CfgSetAuthListRequest, O: CfgUpdateResponse },
    { name: "CfgSetAdminAuthList", options: {}, I: CfgSetAuthListRequest, O: CfgUpdateResponse },
    { name: "CfgSetConstData", options: {}, I: CfgSetConstDataRequest, O: CfgUpdateResponse },
    { name: "CfgMergeBuybackSystemTypeMapsBuilder", options: {}, I: CfgMergeBuybackSystemTypeMapsBuilderRequest, O: CfgUpdateResponse },
    { name: "CfgMergeShopLocationTypeMapsBuilder", options: {}, I: CfgMergeShopLocationTypeMapsBuilderRequest, O: CfgUpdateResponse },
    { name: "CfgMergeBuybackSystems", options: {}, I: CfgMergeBuybackSystemsRequest, O: CfgUpdateResponse },
    { name: "CfgMergeShopLocations", options: {}, I: CfgMergeShopLocationsRequest, O: CfgUpdateResponse },
    { name: "CfgMergeMarkets", options: {}, I: CfgMergeMarketsRequest, O: CfgUpdateResponse }
]);
